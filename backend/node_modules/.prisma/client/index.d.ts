
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ClientType
 * 
 */
export type ClientType = $Result.DefaultSelection<Prisma.$ClientTypePayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model MachineParameter
 * 
 */
export type MachineParameter = $Result.DefaultSelection<Prisma.$MachineParameterPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model SparePart
 * 
 */
export type SparePart = $Result.DefaultSelection<Prisma.$SparePartPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model MaintenanceRequest
 * 
 */
export type MaintenanceRequest = $Result.DefaultSelection<Prisma.$MaintenanceRequestPayload>
/**
 * Model PriceChangeLog
 * 
 */
export type PriceChangeLog = $Result.DefaultSelection<Prisma.$PriceChangeLogPayload>
/**
 * Model UsedPartLog
 * 
 */
export type UsedPartLog = $Result.DefaultSelection<Prisma.$UsedPartLogPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model MachineMovementLog
 * 
 */
export type MachineMovementLog = $Result.DefaultSelection<Prisma.$MachineMovementLogPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model Installment
 * 
 */
export type Installment = $Result.DefaultSelection<Prisma.$InstallmentPayload>
/**
 * Model MachineSale
 * 
 */
export type MachineSale = $Result.DefaultSelection<Prisma.$MachineSalePayload>
/**
 * Model PosMachine
 * 
 */
export type PosMachine = $Result.DefaultSelection<Prisma.$PosMachinePayload>
/**
 * Model SimCard
 * 
 */
export type SimCard = $Result.DefaultSelection<Prisma.$SimCardPayload>
/**
 * Model WarehouseMachine
 * 
 */
export type WarehouseMachine = $Result.DefaultSelection<Prisma.$WarehouseMachinePayload>
/**
 * Model WarehouseSim
 * 
 */
export type WarehouseSim = $Result.DefaultSelection<Prisma.$WarehouseSimPayload>
/**
 * Model SimMovementLog
 * 
 */
export type SimMovementLog = $Result.DefaultSelection<Prisma.$SimMovementLogPayload>
/**
 * Model TransferOrder
 * 
 */
export type TransferOrder = $Result.DefaultSelection<Prisma.$TransferOrderPayload>
/**
 * Model TransferOrderItem
 * 
 */
export type TransferOrderItem = $Result.DefaultSelection<Prisma.$TransferOrderItemPayload>
/**
 * Model MaintenanceApproval
 * 
 */
export type MaintenanceApproval = $Result.DefaultSelection<Prisma.$MaintenanceApprovalPayload>
/**
 * Model RepairVoucher
 * 
 */
export type RepairVoucher = $Result.DefaultSelection<Prisma.$RepairVoucherPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ServiceAssignment
 * 
 */
export type ServiceAssignment = $Result.DefaultSelection<Prisma.$ServiceAssignmentPayload>
/**
 * Model ServiceAssignmentLog
 * 
 */
export type ServiceAssignmentLog = $Result.DefaultSelection<Prisma.$ServiceAssignmentLogPayload>
/**
 * Model BranchDebt
 * 
 */
export type BranchDebt = $Result.DefaultSelection<Prisma.$BranchDebtPayload>
/**
 * Model MaintenanceApprovalRequest
 * 
 */
export type MaintenanceApprovalRequest = $Result.DefaultSelection<Prisma.$MaintenanceApprovalRequestPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.clientType`: Exposes CRUD operations for the **ClientType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientTypes
    * const clientTypes = await prisma.clientType.findMany()
    * ```
    */
  get clientType(): Prisma.ClientTypeDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.machineParameter`: Exposes CRUD operations for the **MachineParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineParameters
    * const machineParameters = await prisma.machineParameter.findMany()
    * ```
    */
  get machineParameter(): Prisma.MachineParameterDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.sparePart`: Exposes CRUD operations for the **SparePart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpareParts
    * const spareParts = await prisma.sparePart.findMany()
    * ```
    */
  get sparePart(): Prisma.SparePartDelegate<ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceRequest`: Exposes CRUD operations for the **MaintenanceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRequests
    * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
    * ```
    */
  get maintenanceRequest(): Prisma.MaintenanceRequestDelegate<ExtArgs>;

  /**
   * `prisma.priceChangeLog`: Exposes CRUD operations for the **PriceChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceChangeLogs
    * const priceChangeLogs = await prisma.priceChangeLog.findMany()
    * ```
    */
  get priceChangeLog(): Prisma.PriceChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.usedPartLog`: Exposes CRUD operations for the **UsedPartLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsedPartLogs
    * const usedPartLogs = await prisma.usedPartLog.findMany()
    * ```
    */
  get usedPartLog(): Prisma.UsedPartLogDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.machineMovementLog`: Exposes CRUD operations for the **MachineMovementLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineMovementLogs
    * const machineMovementLogs = await prisma.machineMovementLog.findMany()
    * ```
    */
  get machineMovementLog(): Prisma.MachineMovementLogDelegate<ExtArgs>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs>;

  /**
   * `prisma.installment`: Exposes CRUD operations for the **Installment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installments
    * const installments = await prisma.installment.findMany()
    * ```
    */
  get installment(): Prisma.InstallmentDelegate<ExtArgs>;

  /**
   * `prisma.machineSale`: Exposes CRUD operations for the **MachineSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineSales
    * const machineSales = await prisma.machineSale.findMany()
    * ```
    */
  get machineSale(): Prisma.MachineSaleDelegate<ExtArgs>;

  /**
   * `prisma.posMachine`: Exposes CRUD operations for the **PosMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosMachines
    * const posMachines = await prisma.posMachine.findMany()
    * ```
    */
  get posMachine(): Prisma.PosMachineDelegate<ExtArgs>;

  /**
   * `prisma.simCard`: Exposes CRUD operations for the **SimCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimCards
    * const simCards = await prisma.simCard.findMany()
    * ```
    */
  get simCard(): Prisma.SimCardDelegate<ExtArgs>;

  /**
   * `prisma.warehouseMachine`: Exposes CRUD operations for the **WarehouseMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseMachines
    * const warehouseMachines = await prisma.warehouseMachine.findMany()
    * ```
    */
  get warehouseMachine(): Prisma.WarehouseMachineDelegate<ExtArgs>;

  /**
   * `prisma.warehouseSim`: Exposes CRUD operations for the **WarehouseSim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseSims
    * const warehouseSims = await prisma.warehouseSim.findMany()
    * ```
    */
  get warehouseSim(): Prisma.WarehouseSimDelegate<ExtArgs>;

  /**
   * `prisma.simMovementLog`: Exposes CRUD operations for the **SimMovementLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimMovementLogs
    * const simMovementLogs = await prisma.simMovementLog.findMany()
    * ```
    */
  get simMovementLog(): Prisma.SimMovementLogDelegate<ExtArgs>;

  /**
   * `prisma.transferOrder`: Exposes CRUD operations for the **TransferOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferOrders
    * const transferOrders = await prisma.transferOrder.findMany()
    * ```
    */
  get transferOrder(): Prisma.TransferOrderDelegate<ExtArgs>;

  /**
   * `prisma.transferOrderItem`: Exposes CRUD operations for the **TransferOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferOrderItems
    * const transferOrderItems = await prisma.transferOrderItem.findMany()
    * ```
    */
  get transferOrderItem(): Prisma.TransferOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceApproval`: Exposes CRUD operations for the **MaintenanceApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceApprovals
    * const maintenanceApprovals = await prisma.maintenanceApproval.findMany()
    * ```
    */
  get maintenanceApproval(): Prisma.MaintenanceApprovalDelegate<ExtArgs>;

  /**
   * `prisma.repairVoucher`: Exposes CRUD operations for the **RepairVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairVouchers
    * const repairVouchers = await prisma.repairVoucher.findMany()
    * ```
    */
  get repairVoucher(): Prisma.RepairVoucherDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.serviceAssignment`: Exposes CRUD operations for the **ServiceAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAssignments
    * const serviceAssignments = await prisma.serviceAssignment.findMany()
    * ```
    */
  get serviceAssignment(): Prisma.ServiceAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.serviceAssignmentLog`: Exposes CRUD operations for the **ServiceAssignmentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAssignmentLogs
    * const serviceAssignmentLogs = await prisma.serviceAssignmentLog.findMany()
    * ```
    */
  get serviceAssignmentLog(): Prisma.ServiceAssignmentLogDelegate<ExtArgs>;

  /**
   * `prisma.branchDebt`: Exposes CRUD operations for the **BranchDebt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchDebts
    * const branchDebts = await prisma.branchDebt.findMany()
    * ```
    */
  get branchDebt(): Prisma.BranchDebtDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceApprovalRequest`: Exposes CRUD operations for the **MaintenanceApprovalRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceApprovalRequests
    * const maintenanceApprovalRequests = await prisma.maintenanceApprovalRequest.findMany()
    * ```
    */
  get maintenanceApprovalRequest(): Prisma.MaintenanceApprovalRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ClientType: 'ClientType',
    Branch: 'Branch',
    Customer: 'Customer',
    MachineParameter: 'MachineParameter',
    RolePermission: 'RolePermission',
    SparePart: 'SparePart',
    InventoryItem: 'InventoryItem',
    MaintenanceRequest: 'MaintenanceRequest',
    PriceChangeLog: 'PriceChangeLog',
    UsedPartLog: 'UsedPartLog',
    StockMovement: 'StockMovement',
    Payment: 'Payment',
    MachineMovementLog: 'MachineMovementLog',
    SystemLog: 'SystemLog',
    Installment: 'Installment',
    MachineSale: 'MachineSale',
    PosMachine: 'PosMachine',
    SimCard: 'SimCard',
    WarehouseMachine: 'WarehouseMachine',
    WarehouseSim: 'WarehouseSim',
    SimMovementLog: 'SimMovementLog',
    TransferOrder: 'TransferOrder',
    TransferOrderItem: 'TransferOrderItem',
    MaintenanceApproval: 'MaintenanceApproval',
    RepairVoucher: 'RepairVoucher',
    Notification: 'Notification',
    ServiceAssignment: 'ServiceAssignment',
    ServiceAssignmentLog: 'ServiceAssignmentLog',
    BranchDebt: 'BranchDebt',
    MaintenanceApprovalRequest: 'MaintenanceApprovalRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "clientType" | "branch" | "customer" | "machineParameter" | "rolePermission" | "sparePart" | "inventoryItem" | "maintenanceRequest" | "priceChangeLog" | "usedPartLog" | "stockMovement" | "payment" | "machineMovementLog" | "systemLog" | "installment" | "machineSale" | "posMachine" | "simCard" | "warehouseMachine" | "warehouseSim" | "simMovementLog" | "transferOrder" | "transferOrderItem" | "maintenanceApproval" | "repairVoucher" | "notification" | "serviceAssignment" | "serviceAssignmentLog" | "branchDebt" | "maintenanceApprovalRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ClientType: {
        payload: Prisma.$ClientTypePayload<ExtArgs>
        fields: Prisma.ClientTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          findFirst: {
            args: Prisma.ClientTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          findMany: {
            args: Prisma.ClientTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>[]
          }
          create: {
            args: Prisma.ClientTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          createMany: {
            args: Prisma.ClientTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>[]
          }
          delete: {
            args: Prisma.ClientTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          update: {
            args: Prisma.ClientTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          deleteMany: {
            args: Prisma.ClientTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTypePayload>
          }
          aggregate: {
            args: Prisma.ClientTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientType>
          }
          groupBy: {
            args: Prisma.ClientTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ClientTypeCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      MachineParameter: {
        payload: Prisma.$MachineParameterPayload<ExtArgs>
        fields: Prisma.MachineParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          findFirst: {
            args: Prisma.MachineParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          findMany: {
            args: Prisma.MachineParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>[]
          }
          create: {
            args: Prisma.MachineParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          createMany: {
            args: Prisma.MachineParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>[]
          }
          delete: {
            args: Prisma.MachineParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          update: {
            args: Prisma.MachineParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          deleteMany: {
            args: Prisma.MachineParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MachineParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineParameterPayload>
          }
          aggregate: {
            args: Prisma.MachineParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineParameter>
          }
          groupBy: {
            args: Prisma.MachineParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineParameterCountArgs<ExtArgs>
            result: $Utils.Optional<MachineParameterCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      SparePart: {
        payload: Prisma.$SparePartPayload<ExtArgs>
        fields: Prisma.SparePartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SparePartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SparePartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          findFirst: {
            args: Prisma.SparePartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SparePartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          findMany: {
            args: Prisma.SparePartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>[]
          }
          create: {
            args: Prisma.SparePartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          createMany: {
            args: Prisma.SparePartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SparePartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>[]
          }
          delete: {
            args: Prisma.SparePartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          update: {
            args: Prisma.SparePartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          deleteMany: {
            args: Prisma.SparePartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SparePartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SparePartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SparePartPayload>
          }
          aggregate: {
            args: Prisma.SparePartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSparePart>
          }
          groupBy: {
            args: Prisma.SparePartGroupByArgs<ExtArgs>
            result: $Utils.Optional<SparePartGroupByOutputType>[]
          }
          count: {
            args: Prisma.SparePartCountArgs<ExtArgs>
            result: $Utils.Optional<SparePartCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRequest: {
        payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestCountAggregateOutputType> | number
          }
        }
      }
      PriceChangeLog: {
        payload: Prisma.$PriceChangeLogPayload<ExtArgs>
        fields: Prisma.PriceChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          findFirst: {
            args: Prisma.PriceChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          findMany: {
            args: Prisma.PriceChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>[]
          }
          create: {
            args: Prisma.PriceChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          createMany: {
            args: Prisma.PriceChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>[]
          }
          delete: {
            args: Prisma.PriceChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          update: {
            args: Prisma.PriceChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.PriceChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceChangeLogPayload>
          }
          aggregate: {
            args: Prisma.PriceChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceChangeLog>
          }
          groupBy: {
            args: Prisma.PriceChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<PriceChangeLogCountAggregateOutputType> | number
          }
        }
      }
      UsedPartLog: {
        payload: Prisma.$UsedPartLogPayload<ExtArgs>
        fields: Prisma.UsedPartLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsedPartLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsedPartLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          findFirst: {
            args: Prisma.UsedPartLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsedPartLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          findMany: {
            args: Prisma.UsedPartLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>[]
          }
          create: {
            args: Prisma.UsedPartLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          createMany: {
            args: Prisma.UsedPartLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsedPartLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>[]
          }
          delete: {
            args: Prisma.UsedPartLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          update: {
            args: Prisma.UsedPartLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          deleteMany: {
            args: Prisma.UsedPartLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsedPartLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsedPartLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsedPartLogPayload>
          }
          aggregate: {
            args: Prisma.UsedPartLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsedPartLog>
          }
          groupBy: {
            args: Prisma.UsedPartLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsedPartLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsedPartLogCountArgs<ExtArgs>
            result: $Utils.Optional<UsedPartLogCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      MachineMovementLog: {
        payload: Prisma.$MachineMovementLogPayload<ExtArgs>
        fields: Prisma.MachineMovementLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineMovementLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineMovementLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          findFirst: {
            args: Prisma.MachineMovementLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineMovementLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          findMany: {
            args: Prisma.MachineMovementLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>[]
          }
          create: {
            args: Prisma.MachineMovementLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          createMany: {
            args: Prisma.MachineMovementLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineMovementLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>[]
          }
          delete: {
            args: Prisma.MachineMovementLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          update: {
            args: Prisma.MachineMovementLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          deleteMany: {
            args: Prisma.MachineMovementLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineMovementLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MachineMovementLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMovementLogPayload>
          }
          aggregate: {
            args: Prisma.MachineMovementLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineMovementLog>
          }
          groupBy: {
            args: Prisma.MachineMovementLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineMovementLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineMovementLogCountArgs<ExtArgs>
            result: $Utils.Optional<MachineMovementLogCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      Installment: {
        payload: Prisma.$InstallmentPayload<ExtArgs>
        fields: Prisma.InstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findFirst: {
            args: Prisma.InstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findMany: {
            args: Prisma.InstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          create: {
            args: Prisma.InstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          createMany: {
            args: Prisma.InstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          delete: {
            args: Prisma.InstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          update: {
            args: Prisma.InstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          deleteMany: {
            args: Prisma.InstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          aggregate: {
            args: Prisma.InstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallment>
          }
          groupBy: {
            args: Prisma.InstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstallmentCountAggregateOutputType> | number
          }
        }
      }
      MachineSale: {
        payload: Prisma.$MachineSalePayload<ExtArgs>
        fields: Prisma.MachineSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          findFirst: {
            args: Prisma.MachineSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          findMany: {
            args: Prisma.MachineSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>[]
          }
          create: {
            args: Prisma.MachineSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          createMany: {
            args: Prisma.MachineSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>[]
          }
          delete: {
            args: Prisma.MachineSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          update: {
            args: Prisma.MachineSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          deleteMany: {
            args: Prisma.MachineSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MachineSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSalePayload>
          }
          aggregate: {
            args: Prisma.MachineSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineSale>
          }
          groupBy: {
            args: Prisma.MachineSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineSaleCountArgs<ExtArgs>
            result: $Utils.Optional<MachineSaleCountAggregateOutputType> | number
          }
        }
      }
      PosMachine: {
        payload: Prisma.$PosMachinePayload<ExtArgs>
        fields: Prisma.PosMachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosMachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosMachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          findFirst: {
            args: Prisma.PosMachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosMachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          findMany: {
            args: Prisma.PosMachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>[]
          }
          create: {
            args: Prisma.PosMachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          createMany: {
            args: Prisma.PosMachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosMachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>[]
          }
          delete: {
            args: Prisma.PosMachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          update: {
            args: Prisma.PosMachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          deleteMany: {
            args: Prisma.PosMachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosMachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PosMachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosMachinePayload>
          }
          aggregate: {
            args: Prisma.PosMachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosMachine>
          }
          groupBy: {
            args: Prisma.PosMachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosMachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosMachineCountArgs<ExtArgs>
            result: $Utils.Optional<PosMachineCountAggregateOutputType> | number
          }
        }
      }
      SimCard: {
        payload: Prisma.$SimCardPayload<ExtArgs>
        fields: Prisma.SimCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          findFirst: {
            args: Prisma.SimCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          findMany: {
            args: Prisma.SimCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>[]
          }
          create: {
            args: Prisma.SimCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          createMany: {
            args: Prisma.SimCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>[]
          }
          delete: {
            args: Prisma.SimCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          update: {
            args: Prisma.SimCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          deleteMany: {
            args: Prisma.SimCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimCardPayload>
          }
          aggregate: {
            args: Prisma.SimCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimCard>
          }
          groupBy: {
            args: Prisma.SimCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimCardCountArgs<ExtArgs>
            result: $Utils.Optional<SimCardCountAggregateOutputType> | number
          }
        }
      }
      WarehouseMachine: {
        payload: Prisma.$WarehouseMachinePayload<ExtArgs>
        fields: Prisma.WarehouseMachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseMachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseMachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          findFirst: {
            args: Prisma.WarehouseMachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseMachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          findMany: {
            args: Prisma.WarehouseMachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>[]
          }
          create: {
            args: Prisma.WarehouseMachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          createMany: {
            args: Prisma.WarehouseMachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseMachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>[]
          }
          delete: {
            args: Prisma.WarehouseMachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          update: {
            args: Prisma.WarehouseMachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseMachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseMachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseMachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseMachinePayload>
          }
          aggregate: {
            args: Prisma.WarehouseMachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseMachine>
          }
          groupBy: {
            args: Prisma.WarehouseMachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseMachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseMachineCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseMachineCountAggregateOutputType> | number
          }
        }
      }
      WarehouseSim: {
        payload: Prisma.$WarehouseSimPayload<ExtArgs>
        fields: Prisma.WarehouseSimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseSimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseSimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          findFirst: {
            args: Prisma.WarehouseSimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseSimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          findMany: {
            args: Prisma.WarehouseSimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>[]
          }
          create: {
            args: Prisma.WarehouseSimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          createMany: {
            args: Prisma.WarehouseSimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseSimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>[]
          }
          delete: {
            args: Prisma.WarehouseSimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          update: {
            args: Prisma.WarehouseSimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseSimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseSimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseSimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseSimPayload>
          }
          aggregate: {
            args: Prisma.WarehouseSimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseSim>
          }
          groupBy: {
            args: Prisma.WarehouseSimGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseSimGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseSimCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseSimCountAggregateOutputType> | number
          }
        }
      }
      SimMovementLog: {
        payload: Prisma.$SimMovementLogPayload<ExtArgs>
        fields: Prisma.SimMovementLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimMovementLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimMovementLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          findFirst: {
            args: Prisma.SimMovementLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimMovementLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          findMany: {
            args: Prisma.SimMovementLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>[]
          }
          create: {
            args: Prisma.SimMovementLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          createMany: {
            args: Prisma.SimMovementLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimMovementLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>[]
          }
          delete: {
            args: Prisma.SimMovementLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          update: {
            args: Prisma.SimMovementLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          deleteMany: {
            args: Prisma.SimMovementLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimMovementLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimMovementLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimMovementLogPayload>
          }
          aggregate: {
            args: Prisma.SimMovementLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimMovementLog>
          }
          groupBy: {
            args: Prisma.SimMovementLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimMovementLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimMovementLogCountArgs<ExtArgs>
            result: $Utils.Optional<SimMovementLogCountAggregateOutputType> | number
          }
        }
      }
      TransferOrder: {
        payload: Prisma.$TransferOrderPayload<ExtArgs>
        fields: Prisma.TransferOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          findFirst: {
            args: Prisma.TransferOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          findMany: {
            args: Prisma.TransferOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>[]
          }
          create: {
            args: Prisma.TransferOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          createMany: {
            args: Prisma.TransferOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>[]
          }
          delete: {
            args: Prisma.TransferOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          update: {
            args: Prisma.TransferOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          deleteMany: {
            args: Prisma.TransferOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          aggregate: {
            args: Prisma.TransferOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferOrder>
          }
          groupBy: {
            args: Prisma.TransferOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferOrderCountArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderCountAggregateOutputType> | number
          }
        }
      }
      TransferOrderItem: {
        payload: Prisma.$TransferOrderItemPayload<ExtArgs>
        fields: Prisma.TransferOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          findFirst: {
            args: Prisma.TransferOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          findMany: {
            args: Prisma.TransferOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>[]
          }
          create: {
            args: Prisma.TransferOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          createMany: {
            args: Prisma.TransferOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>[]
          }
          delete: {
            args: Prisma.TransferOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          update: {
            args: Prisma.TransferOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.TransferOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          aggregate: {
            args: Prisma.TransferOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferOrderItem>
          }
          groupBy: {
            args: Prisma.TransferOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderItemCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceApproval: {
        payload: Prisma.$MaintenanceApprovalPayload<ExtArgs>
        fields: Prisma.MaintenanceApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          findMany: {
            args: Prisma.MaintenanceApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>[]
          }
          create: {
            args: Prisma.MaintenanceApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          createMany: {
            args: Prisma.MaintenanceApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          update: {
            args: Prisma.MaintenanceApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceApproval>
          }
          groupBy: {
            args: Prisma.MaintenanceApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceApprovalCountAggregateOutputType> | number
          }
        }
      }
      RepairVoucher: {
        payload: Prisma.$RepairVoucherPayload<ExtArgs>
        fields: Prisma.RepairVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairVoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairVoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          findFirst: {
            args: Prisma.RepairVoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairVoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          findMany: {
            args: Prisma.RepairVoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>[]
          }
          create: {
            args: Prisma.RepairVoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          createMany: {
            args: Prisma.RepairVoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepairVoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>[]
          }
          delete: {
            args: Prisma.RepairVoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          update: {
            args: Prisma.RepairVoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          deleteMany: {
            args: Prisma.RepairVoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepairVoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepairVoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairVoucherPayload>
          }
          aggregate: {
            args: Prisma.RepairVoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepairVoucher>
          }
          groupBy: {
            args: Prisma.RepairVoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepairVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairVoucherCountArgs<ExtArgs>
            result: $Utils.Optional<RepairVoucherCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ServiceAssignment: {
        payload: Prisma.$ServiceAssignmentPayload<ExtArgs>
        fields: Prisma.ServiceAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ServiceAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          findMany: {
            args: Prisma.ServiceAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
          }
          create: {
            args: Prisma.ServiceAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          createMany: {
            args: Prisma.ServiceAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ServiceAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          update: {
            args: Prisma.ServiceAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ServiceAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAssignment>
          }
          groupBy: {
            args: Prisma.ServiceAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ServiceAssignmentLog: {
        payload: Prisma.$ServiceAssignmentLogPayload<ExtArgs>
        fields: Prisma.ServiceAssignmentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAssignmentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAssignmentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          findFirst: {
            args: Prisma.ServiceAssignmentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAssignmentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          findMany: {
            args: Prisma.ServiceAssignmentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>[]
          }
          create: {
            args: Prisma.ServiceAssignmentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          createMany: {
            args: Prisma.ServiceAssignmentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAssignmentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>[]
          }
          delete: {
            args: Prisma.ServiceAssignmentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          update: {
            args: Prisma.ServiceAssignmentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAssignmentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAssignmentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceAssignmentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentLogPayload>
          }
          aggregate: {
            args: Prisma.ServiceAssignmentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAssignmentLog>
          }
          groupBy: {
            args: Prisma.ServiceAssignmentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAssignmentLogCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentLogCountAggregateOutputType> | number
          }
        }
      }
      BranchDebt: {
        payload: Prisma.$BranchDebtPayload<ExtArgs>
        fields: Prisma.BranchDebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchDebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchDebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          findFirst: {
            args: Prisma.BranchDebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchDebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          findMany: {
            args: Prisma.BranchDebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>[]
          }
          create: {
            args: Prisma.BranchDebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          createMany: {
            args: Prisma.BranchDebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchDebtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>[]
          }
          delete: {
            args: Prisma.BranchDebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          update: {
            args: Prisma.BranchDebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          deleteMany: {
            args: Prisma.BranchDebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchDebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchDebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchDebtPayload>
          }
          aggregate: {
            args: Prisma.BranchDebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchDebt>
          }
          groupBy: {
            args: Prisma.BranchDebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchDebtGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchDebtCountArgs<ExtArgs>
            result: $Utils.Optional<BranchDebtCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceApprovalRequest: {
        payload: Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceApprovalRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceApprovalRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceApprovalRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceApprovalRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceApprovalRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceApprovalRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceApprovalRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceApprovalRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceApprovalRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceApprovalRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceApprovalRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceApprovalRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceApprovalRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceApprovalRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceApprovalRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceApprovalRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceApprovalRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceApprovalRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceApprovalRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceApprovalRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceApprovalRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    servicedBranches: number
    childBranches: number
    customers: number
    installments: number
    inventory: number
    machineMovements: number
    sales: number
    approvals: number
    requests: number
    notifications: number
    payments: number
    posMachines: number
    vouchers: number
    simCards: number
    simMovements: number
    stockMovements: number
    systemLogs: number
    receivedTransfers: number
    sentTransfers: number
    usedPartLogs: number
    users: number
    warehouseMachines: number
    warehouseSims: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicedBranches?: boolean | BranchCountOutputTypeCountServicedBranchesArgs
    childBranches?: boolean | BranchCountOutputTypeCountChildBranchesArgs
    customers?: boolean | BranchCountOutputTypeCountCustomersArgs
    installments?: boolean | BranchCountOutputTypeCountInstallmentsArgs
    inventory?: boolean | BranchCountOutputTypeCountInventoryArgs
    machineMovements?: boolean | BranchCountOutputTypeCountMachineMovementsArgs
    sales?: boolean | BranchCountOutputTypeCountSalesArgs
    approvals?: boolean | BranchCountOutputTypeCountApprovalsArgs
    requests?: boolean | BranchCountOutputTypeCountRequestsArgs
    notifications?: boolean | BranchCountOutputTypeCountNotificationsArgs
    payments?: boolean | BranchCountOutputTypeCountPaymentsArgs
    posMachines?: boolean | BranchCountOutputTypeCountPosMachinesArgs
    vouchers?: boolean | BranchCountOutputTypeCountVouchersArgs
    simCards?: boolean | BranchCountOutputTypeCountSimCardsArgs
    simMovements?: boolean | BranchCountOutputTypeCountSimMovementsArgs
    stockMovements?: boolean | BranchCountOutputTypeCountStockMovementsArgs
    systemLogs?: boolean | BranchCountOutputTypeCountSystemLogsArgs
    receivedTransfers?: boolean | BranchCountOutputTypeCountReceivedTransfersArgs
    sentTransfers?: boolean | BranchCountOutputTypeCountSentTransfersArgs
    usedPartLogs?: boolean | BranchCountOutputTypeCountUsedPartLogsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    warehouseMachines?: boolean | BranchCountOutputTypeCountWarehouseMachinesArgs
    warehouseSims?: boolean | BranchCountOutputTypeCountWarehouseSimsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServicedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountChildBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMachineMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineMovementLogWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineSaleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceApprovalWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPosMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosMachineWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairVoucherWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSimCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimCardWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSimMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimMovementLogWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSystemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsedPartLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsedPartLogWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWarehouseMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseMachineWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWarehouseSimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseSimWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
    requests: number
    payments: number
    machines: number
    simCards: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    requests?: boolean | CustomerCountOutputTypeCountRequestsArgs
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
    machines?: boolean | CustomerCountOutputTypeCountMachinesArgs
    simCards?: boolean | CustomerCountOutputTypeCountSimCardsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineSaleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosMachineWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSimCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimCardWhereInput
  }


  /**
   * Count Type SparePartCountOutputType
   */

  export type SparePartCountOutputType = {
    inventoryItems: number
  }

  export type SparePartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | SparePartCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * SparePartCountOutputType without action
   */
  export type SparePartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePartCountOutputType
     */
    select?: SparePartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SparePartCountOutputType without action
   */
  export type SparePartCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type MaintenanceRequestCountOutputType
   */

  export type MaintenanceRequestCountOutputType = {
    vouchers: number
  }

  export type MaintenanceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vouchers?: boolean | MaintenanceRequestCountOutputTypeCountVouchersArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequestCountOutputType
     */
    select?: MaintenanceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairVoucherWhereInput
  }


  /**
   * Count Type MachineSaleCountOutputType
   */

  export type MachineSaleCountOutputType = {
    installments: number
  }

  export type MachineSaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | MachineSaleCountOutputTypeCountInstallmentsArgs
  }

  // Custom InputTypes
  /**
   * MachineSaleCountOutputType without action
   */
  export type MachineSaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSaleCountOutputType
     */
    select?: MachineSaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MachineSaleCountOutputType without action
   */
  export type MachineSaleCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }


  /**
   * Count Type PosMachineCountOutputType
   */

  export type PosMachineCountOutputType = {
    requests: number
  }

  export type PosMachineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | PosMachineCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * PosMachineCountOutputType without action
   */
  export type PosMachineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachineCountOutputType
     */
    select?: PosMachineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PosMachineCountOutputType without action
   */
  export type PosMachineCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }


  /**
   * Count Type WarehouseMachineCountOutputType
   */

  export type WarehouseMachineCountOutputType = {
    serviceAssignments: number
  }

  export type WarehouseMachineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceAssignments?: boolean | WarehouseMachineCountOutputTypeCountServiceAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseMachineCountOutputType without action
   */
  export type WarehouseMachineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachineCountOutputType
     */
    select?: WarehouseMachineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseMachineCountOutputType without action
   */
  export type WarehouseMachineCountOutputTypeCountServiceAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
  }


  /**
   * Count Type TransferOrderCountOutputType
   */

  export type TransferOrderCountOutputType = {
    items: number
  }

  export type TransferOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransferOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TransferOrderCountOutputType without action
   */
  export type TransferOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderCountOutputType
     */
    select?: TransferOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferOrderCountOutputType without action
   */
  export type TransferOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderItemWhereInput
  }


  /**
   * Count Type ServiceAssignmentCountOutputType
   */

  export type ServiceAssignmentCountOutputType = {
    logs: number
  }

  export type ServiceAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | ServiceAssignmentCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ServiceAssignmentCountOutputType without action
   */
  export type ServiceAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentCountOutputType
     */
    select?: ServiceAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceAssignmentCountOutputType without action
   */
  export type ServiceAssignmentCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    uid: string | null
    email: string | null
    displayName: string | null
    role: string | null
    canDoMaintenance: boolean | null
    password: string | null
    theme: string | null
    fontFamily: string | null
    fontSize: string | null
    highlightEffect: boolean | null
    notificationSound: boolean | null
    mobilePush: boolean | null
    createdAt: Date | null
    branchId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    uid: string | null
    email: string | null
    displayName: string | null
    role: string | null
    canDoMaintenance: boolean | null
    password: string | null
    theme: string | null
    fontFamily: string | null
    fontSize: string | null
    highlightEffect: boolean | null
    notificationSound: boolean | null
    mobilePush: boolean | null
    createdAt: Date | null
    branchId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uid: number
    email: number
    displayName: number
    role: number
    canDoMaintenance: number
    password: number
    theme: number
    fontFamily: number
    fontSize: number
    highlightEffect: number
    notificationSound: number
    mobilePush: number
    createdAt: number
    branchId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    displayName?: true
    role?: true
    canDoMaintenance?: true
    password?: true
    theme?: true
    fontFamily?: true
    fontSize?: true
    highlightEffect?: true
    notificationSound?: true
    mobilePush?: true
    createdAt?: true
    branchId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    displayName?: true
    role?: true
    canDoMaintenance?: true
    password?: true
    theme?: true
    fontFamily?: true
    fontSize?: true
    highlightEffect?: true
    notificationSound?: true
    mobilePush?: true
    createdAt?: true
    branchId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    displayName?: true
    role?: true
    canDoMaintenance?: true
    password?: true
    theme?: true
    fontFamily?: true
    fontSize?: true
    highlightEffect?: true
    notificationSound?: true
    mobilePush?: true
    createdAt?: true
    branchId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    uid: string | null
    email: string | null
    displayName: string | null
    role: string | null
    canDoMaintenance: boolean
    password: string | null
    theme: string | null
    fontFamily: string | null
    fontSize: string | null
    highlightEffect: boolean
    notificationSound: boolean
    mobilePush: boolean
    createdAt: Date
    branchId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    canDoMaintenance?: boolean
    password?: boolean
    theme?: boolean
    fontFamily?: boolean
    fontSize?: boolean
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: boolean
    branchId?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    canDoMaintenance?: boolean
    password?: boolean
    theme?: boolean
    fontFamily?: boolean
    fontSize?: boolean
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: boolean
    branchId?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    uid?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    canDoMaintenance?: boolean
    password?: boolean
    theme?: boolean
    fontFamily?: boolean
    fontSize?: boolean
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: boolean
    branchId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uid: string | null
      email: string | null
      displayName: string | null
      role: string | null
      canDoMaintenance: boolean
      password: string | null
      theme: string | null
      fontFamily: string | null
      fontSize: string | null
      highlightEffect: boolean
      notificationSound: boolean
      mobilePush: boolean
      createdAt: Date
      branchId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly uid: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly canDoMaintenance: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly theme: FieldRef<"User", 'String'>
    readonly fontFamily: FieldRef<"User", 'String'>
    readonly fontSize: FieldRef<"User", 'String'>
    readonly highlightEffect: FieldRef<"User", 'Boolean'>
    readonly notificationSound: FieldRef<"User", 'Boolean'>
    readonly mobilePush: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly branchId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ClientType
   */

  export type AggregateClientType = {
    _count: ClientTypeCountAggregateOutputType | null
    _min: ClientTypeMinAggregateOutputType | null
    _max: ClientTypeMaxAggregateOutputType | null
  }

  export type ClientTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ClientTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ClientTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type ClientTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ClientTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ClientTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ClientTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientType to aggregate.
     */
    where?: ClientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTypes to fetch.
     */
    orderBy?: ClientTypeOrderByWithRelationInput | ClientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientTypes
    **/
    _count?: true | ClientTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientTypeMaxAggregateInputType
  }

  export type GetClientTypeAggregateType<T extends ClientTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateClientType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientType[P]>
      : GetScalarType<T[P], AggregateClientType[P]>
  }




  export type ClientTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientTypeWhereInput
    orderBy?: ClientTypeOrderByWithAggregationInput | ClientTypeOrderByWithAggregationInput[]
    by: ClientTypeScalarFieldEnum[] | ClientTypeScalarFieldEnum
    having?: ClientTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientTypeCountAggregateInputType | true
    _min?: ClientTypeMinAggregateInputType
    _max?: ClientTypeMaxAggregateInputType
  }

  export type ClientTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    _count: ClientTypeCountAggregateOutputType | null
    _min: ClientTypeMinAggregateOutputType | null
    _max: ClientTypeMaxAggregateOutputType | null
  }

  type GetClientTypeGroupByPayload<T extends ClientTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ClientTypeGroupByOutputType[P]>
        }
      >
    >


  export type ClientTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clientType"]>

  export type ClientTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clientType"]>

  export type ClientTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }


  export type $ClientTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["clientType"]>
    composites: {}
  }

  type ClientTypeGetPayload<S extends boolean | null | undefined | ClientTypeDefaultArgs> = $Result.GetResult<Prisma.$ClientTypePayload, S>

  type ClientTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientTypeCountAggregateInputType | true
    }

  export interface ClientTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientType'], meta: { name: 'ClientType' } }
    /**
     * Find zero or one ClientType that matches the filter.
     * @param {ClientTypeFindUniqueArgs} args - Arguments to find a ClientType
     * @example
     * // Get one ClientType
     * const clientType = await prisma.clientType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientTypeFindUniqueArgs>(args: SelectSubset<T, ClientTypeFindUniqueArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientTypeFindUniqueOrThrowArgs} args - Arguments to find a ClientType
     * @example
     * // Get one ClientType
     * const clientType = await prisma.clientType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeFindFirstArgs} args - Arguments to find a ClientType
     * @example
     * // Get one ClientType
     * const clientType = await prisma.clientType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientTypeFindFirstArgs>(args?: SelectSubset<T, ClientTypeFindFirstArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeFindFirstOrThrowArgs} args - Arguments to find a ClientType
     * @example
     * // Get one ClientType
     * const clientType = await prisma.clientType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientTypes
     * const clientTypes = await prisma.clientType.findMany()
     * 
     * // Get first 10 ClientTypes
     * const clientTypes = await prisma.clientType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientTypeWithIdOnly = await prisma.clientType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientTypeFindManyArgs>(args?: SelectSubset<T, ClientTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientType.
     * @param {ClientTypeCreateArgs} args - Arguments to create a ClientType.
     * @example
     * // Create one ClientType
     * const ClientType = await prisma.clientType.create({
     *   data: {
     *     // ... data to create a ClientType
     *   }
     * })
     * 
     */
    create<T extends ClientTypeCreateArgs>(args: SelectSubset<T, ClientTypeCreateArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientTypes.
     * @param {ClientTypeCreateManyArgs} args - Arguments to create many ClientTypes.
     * @example
     * // Create many ClientTypes
     * const clientType = await prisma.clientType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientTypeCreateManyArgs>(args?: SelectSubset<T, ClientTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientTypes and returns the data saved in the database.
     * @param {ClientTypeCreateManyAndReturnArgs} args - Arguments to create many ClientTypes.
     * @example
     * // Create many ClientTypes
     * const clientType = await prisma.clientType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientTypes and only return the `id`
     * const clientTypeWithIdOnly = await prisma.clientType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientType.
     * @param {ClientTypeDeleteArgs} args - Arguments to delete one ClientType.
     * @example
     * // Delete one ClientType
     * const ClientType = await prisma.clientType.delete({
     *   where: {
     *     // ... filter to delete one ClientType
     *   }
     * })
     * 
     */
    delete<T extends ClientTypeDeleteArgs>(args: SelectSubset<T, ClientTypeDeleteArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientType.
     * @param {ClientTypeUpdateArgs} args - Arguments to update one ClientType.
     * @example
     * // Update one ClientType
     * const clientType = await prisma.clientType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientTypeUpdateArgs>(args: SelectSubset<T, ClientTypeUpdateArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientTypes.
     * @param {ClientTypeDeleteManyArgs} args - Arguments to filter ClientTypes to delete.
     * @example
     * // Delete a few ClientTypes
     * const { count } = await prisma.clientType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientTypeDeleteManyArgs>(args?: SelectSubset<T, ClientTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientTypes
     * const clientType = await prisma.clientType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientTypeUpdateManyArgs>(args: SelectSubset<T, ClientTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientType.
     * @param {ClientTypeUpsertArgs} args - Arguments to update or create a ClientType.
     * @example
     * // Update or create a ClientType
     * const clientType = await prisma.clientType.upsert({
     *   create: {
     *     // ... data to create a ClientType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientType we want to update
     *   }
     * })
     */
    upsert<T extends ClientTypeUpsertArgs>(args: SelectSubset<T, ClientTypeUpsertArgs<ExtArgs>>): Prisma__ClientTypeClient<$Result.GetResult<Prisma.$ClientTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeCountArgs} args - Arguments to filter ClientTypes to count.
     * @example
     * // Count the number of ClientTypes
     * const count = await prisma.clientType.count({
     *   where: {
     *     // ... the filter for the ClientTypes we want to count
     *   }
     * })
    **/
    count<T extends ClientTypeCountArgs>(
      args?: Subset<T, ClientTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientTypeAggregateArgs>(args: Subset<T, ClientTypeAggregateArgs>): Prisma.PrismaPromise<GetClientTypeAggregateType<T>>

    /**
     * Group by ClientType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientTypeGroupByArgs['orderBy'] }
        : { orderBy?: ClientTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientType model
   */
  readonly fields: ClientTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientType model
   */ 
  interface ClientTypeFieldRefs {
    readonly id: FieldRef<"ClientType", 'String'>
    readonly name: FieldRef<"ClientType", 'String'>
    readonly description: FieldRef<"ClientType", 'String'>
    readonly createdAt: FieldRef<"ClientType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientType findUnique
   */
  export type ClientTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter, which ClientType to fetch.
     */
    where: ClientTypeWhereUniqueInput
  }

  /**
   * ClientType findUniqueOrThrow
   */
  export type ClientTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter, which ClientType to fetch.
     */
    where: ClientTypeWhereUniqueInput
  }

  /**
   * ClientType findFirst
   */
  export type ClientTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter, which ClientType to fetch.
     */
    where?: ClientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTypes to fetch.
     */
    orderBy?: ClientTypeOrderByWithRelationInput | ClientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientTypes.
     */
    cursor?: ClientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientTypes.
     */
    distinct?: ClientTypeScalarFieldEnum | ClientTypeScalarFieldEnum[]
  }

  /**
   * ClientType findFirstOrThrow
   */
  export type ClientTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter, which ClientType to fetch.
     */
    where?: ClientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTypes to fetch.
     */
    orderBy?: ClientTypeOrderByWithRelationInput | ClientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientTypes.
     */
    cursor?: ClientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientTypes.
     */
    distinct?: ClientTypeScalarFieldEnum | ClientTypeScalarFieldEnum[]
  }

  /**
   * ClientType findMany
   */
  export type ClientTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter, which ClientTypes to fetch.
     */
    where?: ClientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTypes to fetch.
     */
    orderBy?: ClientTypeOrderByWithRelationInput | ClientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientTypes.
     */
    cursor?: ClientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTypes.
     */
    skip?: number
    distinct?: ClientTypeScalarFieldEnum | ClientTypeScalarFieldEnum[]
  }

  /**
   * ClientType create
   */
  export type ClientTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a ClientType.
     */
    data: XOR<ClientTypeCreateInput, ClientTypeUncheckedCreateInput>
  }

  /**
   * ClientType createMany
   */
  export type ClientTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientTypes.
     */
    data: ClientTypeCreateManyInput | ClientTypeCreateManyInput[]
  }

  /**
   * ClientType createManyAndReturn
   */
  export type ClientTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientTypes.
     */
    data: ClientTypeCreateManyInput | ClientTypeCreateManyInput[]
  }

  /**
   * ClientType update
   */
  export type ClientTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a ClientType.
     */
    data: XOR<ClientTypeUpdateInput, ClientTypeUncheckedUpdateInput>
    /**
     * Choose, which ClientType to update.
     */
    where: ClientTypeWhereUniqueInput
  }

  /**
   * ClientType updateMany
   */
  export type ClientTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientTypes.
     */
    data: XOR<ClientTypeUpdateManyMutationInput, ClientTypeUncheckedUpdateManyInput>
    /**
     * Filter which ClientTypes to update
     */
    where?: ClientTypeWhereInput
  }

  /**
   * ClientType upsert
   */
  export type ClientTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the ClientType to update in case it exists.
     */
    where: ClientTypeWhereUniqueInput
    /**
     * In case the ClientType found by the `where` argument doesn't exist, create a new ClientType with this data.
     */
    create: XOR<ClientTypeCreateInput, ClientTypeUncheckedCreateInput>
    /**
     * In case the ClientType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientTypeUpdateInput, ClientTypeUncheckedUpdateInput>
  }

  /**
   * ClientType delete
   */
  export type ClientTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
    /**
     * Filter which ClientType to delete.
     */
    where: ClientTypeWhereUniqueInput
  }

  /**
   * ClientType deleteMany
   */
  export type ClientTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientTypes to delete
     */
    where?: ClientTypeWhereInput
  }

  /**
   * ClientType without action
   */
  export type ClientTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientType
     */
    select?: ClientTypeSelect<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    type: string | null
    isActive: boolean | null
    parentBranchId: string | null
    maintenanceCenterId: string | null
    createdAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    type: string | null
    isActive: boolean | null
    parentBranchId: string | null
    maintenanceCenterId: string | null
    createdAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    type: number
    isActive: number
    parentBranchId: number
    maintenanceCenterId: number
    createdAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    type?: true
    isActive?: true
    parentBranchId?: true
    maintenanceCenterId?: true
    createdAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    type?: true
    isActive?: true
    parentBranchId?: true
    maintenanceCenterId?: true
    createdAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    type?: true
    isActive?: true
    parentBranchId?: true
    maintenanceCenterId?: true
    createdAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    code: string
    name: string
    address: string | null
    type: string
    isActive: boolean
    parentBranchId: string | null
    maintenanceCenterId: string | null
    createdAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    isActive?: boolean
    parentBranchId?: boolean
    maintenanceCenterId?: boolean
    createdAt?: boolean
    maintenanceCenter?: boolean | Branch$maintenanceCenterArgs<ExtArgs>
    servicedBranches?: boolean | Branch$servicedBranchesArgs<ExtArgs>
    parentBranch?: boolean | Branch$parentBranchArgs<ExtArgs>
    childBranches?: boolean | Branch$childBranchesArgs<ExtArgs>
    customers?: boolean | Branch$customersArgs<ExtArgs>
    installments?: boolean | Branch$installmentsArgs<ExtArgs>
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    machineMovements?: boolean | Branch$machineMovementsArgs<ExtArgs>
    sales?: boolean | Branch$salesArgs<ExtArgs>
    approvals?: boolean | Branch$approvalsArgs<ExtArgs>
    requests?: boolean | Branch$requestsArgs<ExtArgs>
    notifications?: boolean | Branch$notificationsArgs<ExtArgs>
    payments?: boolean | Branch$paymentsArgs<ExtArgs>
    posMachines?: boolean | Branch$posMachinesArgs<ExtArgs>
    vouchers?: boolean | Branch$vouchersArgs<ExtArgs>
    simCards?: boolean | Branch$simCardsArgs<ExtArgs>
    simMovements?: boolean | Branch$simMovementsArgs<ExtArgs>
    stockMovements?: boolean | Branch$stockMovementsArgs<ExtArgs>
    systemLogs?: boolean | Branch$systemLogsArgs<ExtArgs>
    receivedTransfers?: boolean | Branch$receivedTransfersArgs<ExtArgs>
    sentTransfers?: boolean | Branch$sentTransfersArgs<ExtArgs>
    usedPartLogs?: boolean | Branch$usedPartLogsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    warehouseMachines?: boolean | Branch$warehouseMachinesArgs<ExtArgs>
    warehouseSims?: boolean | Branch$warehouseSimsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    isActive?: boolean
    parentBranchId?: boolean
    maintenanceCenterId?: boolean
    createdAt?: boolean
    maintenanceCenter?: boolean | Branch$maintenanceCenterArgs<ExtArgs>
    parentBranch?: boolean | Branch$parentBranchArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    type?: boolean
    isActive?: boolean
    parentBranchId?: boolean
    maintenanceCenterId?: boolean
    createdAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceCenter?: boolean | Branch$maintenanceCenterArgs<ExtArgs>
    servicedBranches?: boolean | Branch$servicedBranchesArgs<ExtArgs>
    parentBranch?: boolean | Branch$parentBranchArgs<ExtArgs>
    childBranches?: boolean | Branch$childBranchesArgs<ExtArgs>
    customers?: boolean | Branch$customersArgs<ExtArgs>
    installments?: boolean | Branch$installmentsArgs<ExtArgs>
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    machineMovements?: boolean | Branch$machineMovementsArgs<ExtArgs>
    sales?: boolean | Branch$salesArgs<ExtArgs>
    approvals?: boolean | Branch$approvalsArgs<ExtArgs>
    requests?: boolean | Branch$requestsArgs<ExtArgs>
    notifications?: boolean | Branch$notificationsArgs<ExtArgs>
    payments?: boolean | Branch$paymentsArgs<ExtArgs>
    posMachines?: boolean | Branch$posMachinesArgs<ExtArgs>
    vouchers?: boolean | Branch$vouchersArgs<ExtArgs>
    simCards?: boolean | Branch$simCardsArgs<ExtArgs>
    simMovements?: boolean | Branch$simMovementsArgs<ExtArgs>
    stockMovements?: boolean | Branch$stockMovementsArgs<ExtArgs>
    systemLogs?: boolean | Branch$systemLogsArgs<ExtArgs>
    receivedTransfers?: boolean | Branch$receivedTransfersArgs<ExtArgs>
    sentTransfers?: boolean | Branch$sentTransfersArgs<ExtArgs>
    usedPartLogs?: boolean | Branch$usedPartLogsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    warehouseMachines?: boolean | Branch$warehouseMachinesArgs<ExtArgs>
    warehouseSims?: boolean | Branch$warehouseSimsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceCenter?: boolean | Branch$maintenanceCenterArgs<ExtArgs>
    parentBranch?: boolean | Branch$parentBranchArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      maintenanceCenter: Prisma.$BranchPayload<ExtArgs> | null
      servicedBranches: Prisma.$BranchPayload<ExtArgs>[]
      parentBranch: Prisma.$BranchPayload<ExtArgs> | null
      childBranches: Prisma.$BranchPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      installments: Prisma.$InstallmentPayload<ExtArgs>[]
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
      machineMovements: Prisma.$MachineMovementLogPayload<ExtArgs>[]
      sales: Prisma.$MachineSalePayload<ExtArgs>[]
      approvals: Prisma.$MaintenanceApprovalPayload<ExtArgs>[]
      requests: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      posMachines: Prisma.$PosMachinePayload<ExtArgs>[]
      vouchers: Prisma.$RepairVoucherPayload<ExtArgs>[]
      simCards: Prisma.$SimCardPayload<ExtArgs>[]
      simMovements: Prisma.$SimMovementLogPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      systemLogs: Prisma.$SystemLogPayload<ExtArgs>[]
      receivedTransfers: Prisma.$TransferOrderPayload<ExtArgs>[]
      sentTransfers: Prisma.$TransferOrderPayload<ExtArgs>[]
      usedPartLogs: Prisma.$UsedPartLogPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      warehouseMachines: Prisma.$WarehouseMachinePayload<ExtArgs>[]
      warehouseSims: Prisma.$WarehouseSimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      address: string | null
      type: string
      isActive: boolean
      parentBranchId: string | null
      maintenanceCenterId: string | null
      createdAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceCenter<T extends Branch$maintenanceCenterArgs<ExtArgs> = {}>(args?: Subset<T, Branch$maintenanceCenterArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    servicedBranches<T extends Branch$servicedBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$servicedBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    parentBranch<T extends Branch$parentBranchArgs<ExtArgs> = {}>(args?: Subset<T, Branch$parentBranchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childBranches<T extends Branch$childBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$childBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Branch$customersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    installments<T extends Branch$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Branch$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Branch$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    machineMovements<T extends Branch$machineMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$machineMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Branch$salesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends Branch$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    requests<T extends Branch$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Branch$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Branch$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    posMachines<T extends Branch$posMachinesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$posMachinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findMany"> | Null>
    vouchers<T extends Branch$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    simCards<T extends Branch$simCardsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$simCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findMany"> | Null>
    simMovements<T extends Branch$simMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$simMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Branch$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    systemLogs<T extends Branch$systemLogsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$systemLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany"> | Null>
    receivedTransfers<T extends Branch$receivedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receivedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany"> | Null>
    sentTransfers<T extends Branch$sentTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$sentTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany"> | Null>
    usedPartLogs<T extends Branch$usedPartLogsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usedPartLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    warehouseMachines<T extends Branch$warehouseMachinesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$warehouseMachinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findMany"> | Null>
    warehouseSims<T extends Branch$warehouseSimsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$warehouseSimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly type: FieldRef<"Branch", 'String'>
    readonly isActive: FieldRef<"Branch", 'Boolean'>
    readonly parentBranchId: FieldRef<"Branch", 'String'>
    readonly maintenanceCenterId: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.maintenanceCenter
   */
  export type Branch$maintenanceCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Branch.servicedBranches
   */
  export type Branch$servicedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch.parentBranch
   */
  export type Branch$parentBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Branch.childBranches
   */
  export type Branch$childBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch.customers
   */
  export type Branch$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Branch.installments
   */
  export type Branch$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Branch.inventory
   */
  export type Branch$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Branch.machineMovements
   */
  export type Branch$machineMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    where?: MachineMovementLogWhereInput
    orderBy?: MachineMovementLogOrderByWithRelationInput | MachineMovementLogOrderByWithRelationInput[]
    cursor?: MachineMovementLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineMovementLogScalarFieldEnum | MachineMovementLogScalarFieldEnum[]
  }

  /**
   * Branch.sales
   */
  export type Branch$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    where?: MachineSaleWhereInput
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    cursor?: MachineSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineSaleScalarFieldEnum | MachineSaleScalarFieldEnum[]
  }

  /**
   * Branch.approvals
   */
  export type Branch$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    where?: MaintenanceApprovalWhereInput
    orderBy?: MaintenanceApprovalOrderByWithRelationInput | MaintenanceApprovalOrderByWithRelationInput[]
    cursor?: MaintenanceApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceApprovalScalarFieldEnum | MaintenanceApprovalScalarFieldEnum[]
  }

  /**
   * Branch.requests
   */
  export type Branch$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Branch.notifications
   */
  export type Branch$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Branch.payments
   */
  export type Branch$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Branch.posMachines
   */
  export type Branch$posMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    where?: PosMachineWhereInput
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    cursor?: PosMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosMachineScalarFieldEnum | PosMachineScalarFieldEnum[]
  }

  /**
   * Branch.vouchers
   */
  export type Branch$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    where?: RepairVoucherWhereInput
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    cursor?: RepairVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairVoucherScalarFieldEnum | RepairVoucherScalarFieldEnum[]
  }

  /**
   * Branch.simCards
   */
  export type Branch$simCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    where?: SimCardWhereInput
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    cursor?: SimCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimCardScalarFieldEnum | SimCardScalarFieldEnum[]
  }

  /**
   * Branch.simMovements
   */
  export type Branch$simMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    where?: SimMovementLogWhereInput
    orderBy?: SimMovementLogOrderByWithRelationInput | SimMovementLogOrderByWithRelationInput[]
    cursor?: SimMovementLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimMovementLogScalarFieldEnum | SimMovementLogScalarFieldEnum[]
  }

  /**
   * Branch.stockMovements
   */
  export type Branch$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Branch.systemLogs
   */
  export type Branch$systemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    cursor?: SystemLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * Branch.receivedTransfers
   */
  export type Branch$receivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    cursor?: TransferOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * Branch.sentTransfers
   */
  export type Branch$sentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    cursor?: TransferOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * Branch.usedPartLogs
   */
  export type Branch$usedPartLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    where?: UsedPartLogWhereInput
    orderBy?: UsedPartLogOrderByWithRelationInput | UsedPartLogOrderByWithRelationInput[]
    cursor?: UsedPartLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsedPartLogScalarFieldEnum | UsedPartLogScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.warehouseMachines
   */
  export type Branch$warehouseMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    where?: WarehouseMachineWhereInput
    orderBy?: WarehouseMachineOrderByWithRelationInput | WarehouseMachineOrderByWithRelationInput[]
    cursor?: WarehouseMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseMachineScalarFieldEnum | WarehouseMachineScalarFieldEnum[]
  }

  /**
   * Branch.warehouseSims
   */
  export type Branch$warehouseSimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    where?: WarehouseSimWhereInput
    orderBy?: WarehouseSimOrderByWithRelationInput | WarehouseSimOrderByWithRelationInput[]
    cursor?: WarehouseSimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseSimScalarFieldEnum | WarehouseSimScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    bkcode: string | null
    client_name: string | null
    supply_office: string | null
    operating_date: Date | null
    address: string | null
    contact_person: string | null
    scanned_id_path: string | null
    national_id: string | null
    dept: string | null
    telephone_1: string | null
    telephone_2: string | null
    has_gates: boolean | null
    bk_type: string | null
    notes: string | null
    papers_date: Date | null
    isSpecial: boolean | null
    clienttype: string | null
    branchId: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    bkcode: string | null
    client_name: string | null
    supply_office: string | null
    operating_date: Date | null
    address: string | null
    contact_person: string | null
    scanned_id_path: string | null
    national_id: string | null
    dept: string | null
    telephone_1: string | null
    telephone_2: string | null
    has_gates: boolean | null
    bk_type: string | null
    notes: string | null
    papers_date: Date | null
    isSpecial: boolean | null
    clienttype: string | null
    branchId: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    bkcode: number
    client_name: number
    supply_office: number
    operating_date: number
    address: number
    contact_person: number
    scanned_id_path: number
    national_id: number
    dept: number
    telephone_1: number
    telephone_2: number
    has_gates: number
    bk_type: number
    notes: number
    papers_date: number
    isSpecial: number
    clienttype: number
    branchId: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    bkcode?: true
    client_name?: true
    supply_office?: true
    operating_date?: true
    address?: true
    contact_person?: true
    scanned_id_path?: true
    national_id?: true
    dept?: true
    telephone_1?: true
    telephone_2?: true
    has_gates?: true
    bk_type?: true
    notes?: true
    papers_date?: true
    isSpecial?: true
    clienttype?: true
    branchId?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    bkcode?: true
    client_name?: true
    supply_office?: true
    operating_date?: true
    address?: true
    contact_person?: true
    scanned_id_path?: true
    national_id?: true
    dept?: true
    telephone_1?: true
    telephone_2?: true
    has_gates?: true
    bk_type?: true
    notes?: true
    papers_date?: true
    isSpecial?: true
    clienttype?: true
    branchId?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    bkcode?: true
    client_name?: true
    supply_office?: true
    operating_date?: true
    address?: true
    contact_person?: true
    scanned_id_path?: true
    national_id?: true
    dept?: true
    telephone_1?: true
    telephone_2?: true
    has_gates?: true
    bk_type?: true
    notes?: true
    papers_date?: true
    isSpecial?: true
    clienttype?: true
    branchId?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    bkcode: string
    client_name: string
    supply_office: string | null
    operating_date: Date | null
    address: string | null
    contact_person: string | null
    scanned_id_path: string | null
    national_id: string | null
    dept: string | null
    telephone_1: string | null
    telephone_2: string | null
    has_gates: boolean | null
    bk_type: string | null
    notes: string | null
    papers_date: Date | null
    isSpecial: boolean | null
    clienttype: string | null
    branchId: string | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bkcode?: boolean
    client_name?: boolean
    supply_office?: boolean
    operating_date?: boolean
    address?: boolean
    contact_person?: boolean
    scanned_id_path?: boolean
    national_id?: boolean
    dept?: boolean
    telephone_1?: boolean
    telephone_2?: boolean
    has_gates?: boolean
    bk_type?: boolean
    notes?: boolean
    papers_date?: boolean
    isSpecial?: boolean
    clienttype?: boolean
    branchId?: boolean
    branch?: boolean | Customer$branchArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    requests?: boolean | Customer$requestsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    machines?: boolean | Customer$machinesArgs<ExtArgs>
    simCards?: boolean | Customer$simCardsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bkcode?: boolean
    client_name?: boolean
    supply_office?: boolean
    operating_date?: boolean
    address?: boolean
    contact_person?: boolean
    scanned_id_path?: boolean
    national_id?: boolean
    dept?: boolean
    telephone_1?: boolean
    telephone_2?: boolean
    has_gates?: boolean
    bk_type?: boolean
    notes?: boolean
    papers_date?: boolean
    isSpecial?: boolean
    clienttype?: boolean
    branchId?: boolean
    branch?: boolean | Customer$branchArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    bkcode?: boolean
    client_name?: boolean
    supply_office?: boolean
    operating_date?: boolean
    address?: boolean
    contact_person?: boolean
    scanned_id_path?: boolean
    national_id?: boolean
    dept?: boolean
    telephone_1?: boolean
    telephone_2?: boolean
    has_gates?: boolean
    bk_type?: boolean
    notes?: boolean
    papers_date?: boolean
    isSpecial?: boolean
    clienttype?: boolean
    branchId?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Customer$branchArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    requests?: boolean | Customer$requestsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    machines?: boolean | Customer$machinesArgs<ExtArgs>
    simCards?: boolean | Customer$simCardsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Customer$branchArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      sales: Prisma.$MachineSalePayload<ExtArgs>[]
      requests: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      machines: Prisma.$PosMachinePayload<ExtArgs>[]
      simCards: Prisma.$SimCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bkcode: string
      client_name: string
      supply_office: string | null
      operating_date: Date | null
      address: string | null
      contact_person: string | null
      scanned_id_path: string | null
      national_id: string | null
      dept: string | null
      telephone_1: string | null
      telephone_2: string | null
      has_gates: boolean | null
      bk_type: string | null
      notes: string | null
      papers_date: Date | null
      isSpecial: boolean | null
      clienttype: string | null
      branchId: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Customer$branchArgs<ExtArgs> = {}>(args?: Subset<T, Customer$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findMany"> | Null>
    requests<T extends Customer$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    machines<T extends Customer$machinesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$machinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findMany"> | Null>
    simCards<T extends Customer$simCardsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$simCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly bkcode: FieldRef<"Customer", 'String'>
    readonly client_name: FieldRef<"Customer", 'String'>
    readonly supply_office: FieldRef<"Customer", 'String'>
    readonly operating_date: FieldRef<"Customer", 'DateTime'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly contact_person: FieldRef<"Customer", 'String'>
    readonly scanned_id_path: FieldRef<"Customer", 'String'>
    readonly national_id: FieldRef<"Customer", 'String'>
    readonly dept: FieldRef<"Customer", 'String'>
    readonly telephone_1: FieldRef<"Customer", 'String'>
    readonly telephone_2: FieldRef<"Customer", 'String'>
    readonly has_gates: FieldRef<"Customer", 'Boolean'>
    readonly bk_type: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly papers_date: FieldRef<"Customer", 'DateTime'>
    readonly isSpecial: FieldRef<"Customer", 'Boolean'>
    readonly clienttype: FieldRef<"Customer", 'String'>
    readonly branchId: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.branch
   */
  export type Customer$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    where?: MachineSaleWhereInput
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    cursor?: MachineSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineSaleScalarFieldEnum | MachineSaleScalarFieldEnum[]
  }

  /**
   * Customer.requests
   */
  export type Customer$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer.machines
   */
  export type Customer$machinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    where?: PosMachineWhereInput
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    cursor?: PosMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosMachineScalarFieldEnum | PosMachineScalarFieldEnum[]
  }

  /**
   * Customer.simCards
   */
  export type Customer$simCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    where?: SimCardWhereInput
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    cursor?: SimCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimCardScalarFieldEnum | SimCardScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model MachineParameter
   */

  export type AggregateMachineParameter = {
    _count: MachineParameterCountAggregateOutputType | null
    _min: MachineParameterMinAggregateOutputType | null
    _max: MachineParameterMaxAggregateOutputType | null
  }

  export type MachineParameterMinAggregateOutputType = {
    id: string | null
    prefix: string | null
    model: string | null
    manufacturer: string | null
  }

  export type MachineParameterMaxAggregateOutputType = {
    id: string | null
    prefix: string | null
    model: string | null
    manufacturer: string | null
  }

  export type MachineParameterCountAggregateOutputType = {
    id: number
    prefix: number
    model: number
    manufacturer: number
    _all: number
  }


  export type MachineParameterMinAggregateInputType = {
    id?: true
    prefix?: true
    model?: true
    manufacturer?: true
  }

  export type MachineParameterMaxAggregateInputType = {
    id?: true
    prefix?: true
    model?: true
    manufacturer?: true
  }

  export type MachineParameterCountAggregateInputType = {
    id?: true
    prefix?: true
    model?: true
    manufacturer?: true
    _all?: true
  }

  export type MachineParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineParameter to aggregate.
     */
    where?: MachineParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineParameters to fetch.
     */
    orderBy?: MachineParameterOrderByWithRelationInput | MachineParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineParameters
    **/
    _count?: true | MachineParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineParameterMaxAggregateInputType
  }

  export type GetMachineParameterAggregateType<T extends MachineParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineParameter[P]>
      : GetScalarType<T[P], AggregateMachineParameter[P]>
  }




  export type MachineParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineParameterWhereInput
    orderBy?: MachineParameterOrderByWithAggregationInput | MachineParameterOrderByWithAggregationInput[]
    by: MachineParameterScalarFieldEnum[] | MachineParameterScalarFieldEnum
    having?: MachineParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineParameterCountAggregateInputType | true
    _min?: MachineParameterMinAggregateInputType
    _max?: MachineParameterMaxAggregateInputType
  }

  export type MachineParameterGroupByOutputType = {
    id: string
    prefix: string
    model: string
    manufacturer: string
    _count: MachineParameterCountAggregateOutputType | null
    _min: MachineParameterMinAggregateOutputType | null
    _max: MachineParameterMaxAggregateOutputType | null
  }

  type GetMachineParameterGroupByPayload<T extends MachineParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineParameterGroupByOutputType[P]>
            : GetScalarType<T[P], MachineParameterGroupByOutputType[P]>
        }
      >
    >


  export type MachineParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prefix?: boolean
    model?: boolean
    manufacturer?: boolean
  }, ExtArgs["result"]["machineParameter"]>

  export type MachineParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prefix?: boolean
    model?: boolean
    manufacturer?: boolean
  }, ExtArgs["result"]["machineParameter"]>

  export type MachineParameterSelectScalar = {
    id?: boolean
    prefix?: boolean
    model?: boolean
    manufacturer?: boolean
  }


  export type $MachineParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineParameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prefix: string
      model: string
      manufacturer: string
    }, ExtArgs["result"]["machineParameter"]>
    composites: {}
  }

  type MachineParameterGetPayload<S extends boolean | null | undefined | MachineParameterDefaultArgs> = $Result.GetResult<Prisma.$MachineParameterPayload, S>

  type MachineParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MachineParameterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MachineParameterCountAggregateInputType | true
    }

  export interface MachineParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineParameter'], meta: { name: 'MachineParameter' } }
    /**
     * Find zero or one MachineParameter that matches the filter.
     * @param {MachineParameterFindUniqueArgs} args - Arguments to find a MachineParameter
     * @example
     * // Get one MachineParameter
     * const machineParameter = await prisma.machineParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineParameterFindUniqueArgs>(args: SelectSubset<T, MachineParameterFindUniqueArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MachineParameter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MachineParameterFindUniqueOrThrowArgs} args - Arguments to find a MachineParameter
     * @example
     * // Get one MachineParameter
     * const machineParameter = await prisma.machineParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MachineParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterFindFirstArgs} args - Arguments to find a MachineParameter
     * @example
     * // Get one MachineParameter
     * const machineParameter = await prisma.machineParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineParameterFindFirstArgs>(args?: SelectSubset<T, MachineParameterFindFirstArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MachineParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterFindFirstOrThrowArgs} args - Arguments to find a MachineParameter
     * @example
     * // Get one MachineParameter
     * const machineParameter = await prisma.machineParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MachineParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineParameters
     * const machineParameters = await prisma.machineParameter.findMany()
     * 
     * // Get first 10 MachineParameters
     * const machineParameters = await prisma.machineParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineParameterWithIdOnly = await prisma.machineParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineParameterFindManyArgs>(args?: SelectSubset<T, MachineParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MachineParameter.
     * @param {MachineParameterCreateArgs} args - Arguments to create a MachineParameter.
     * @example
     * // Create one MachineParameter
     * const MachineParameter = await prisma.machineParameter.create({
     *   data: {
     *     // ... data to create a MachineParameter
     *   }
     * })
     * 
     */
    create<T extends MachineParameterCreateArgs>(args: SelectSubset<T, MachineParameterCreateArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MachineParameters.
     * @param {MachineParameterCreateManyArgs} args - Arguments to create many MachineParameters.
     * @example
     * // Create many MachineParameters
     * const machineParameter = await prisma.machineParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineParameterCreateManyArgs>(args?: SelectSubset<T, MachineParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineParameters and returns the data saved in the database.
     * @param {MachineParameterCreateManyAndReturnArgs} args - Arguments to create many MachineParameters.
     * @example
     * // Create many MachineParameters
     * const machineParameter = await prisma.machineParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineParameters and only return the `id`
     * const machineParameterWithIdOnly = await prisma.machineParameter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MachineParameter.
     * @param {MachineParameterDeleteArgs} args - Arguments to delete one MachineParameter.
     * @example
     * // Delete one MachineParameter
     * const MachineParameter = await prisma.machineParameter.delete({
     *   where: {
     *     // ... filter to delete one MachineParameter
     *   }
     * })
     * 
     */
    delete<T extends MachineParameterDeleteArgs>(args: SelectSubset<T, MachineParameterDeleteArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MachineParameter.
     * @param {MachineParameterUpdateArgs} args - Arguments to update one MachineParameter.
     * @example
     * // Update one MachineParameter
     * const machineParameter = await prisma.machineParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineParameterUpdateArgs>(args: SelectSubset<T, MachineParameterUpdateArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MachineParameters.
     * @param {MachineParameterDeleteManyArgs} args - Arguments to filter MachineParameters to delete.
     * @example
     * // Delete a few MachineParameters
     * const { count } = await prisma.machineParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineParameterDeleteManyArgs>(args?: SelectSubset<T, MachineParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineParameters
     * const machineParameter = await prisma.machineParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineParameterUpdateManyArgs>(args: SelectSubset<T, MachineParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MachineParameter.
     * @param {MachineParameterUpsertArgs} args - Arguments to update or create a MachineParameter.
     * @example
     * // Update or create a MachineParameter
     * const machineParameter = await prisma.machineParameter.upsert({
     *   create: {
     *     // ... data to create a MachineParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineParameter we want to update
     *   }
     * })
     */
    upsert<T extends MachineParameterUpsertArgs>(args: SelectSubset<T, MachineParameterUpsertArgs<ExtArgs>>): Prisma__MachineParameterClient<$Result.GetResult<Prisma.$MachineParameterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MachineParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterCountArgs} args - Arguments to filter MachineParameters to count.
     * @example
     * // Count the number of MachineParameters
     * const count = await prisma.machineParameter.count({
     *   where: {
     *     // ... the filter for the MachineParameters we want to count
     *   }
     * })
    **/
    count<T extends MachineParameterCountArgs>(
      args?: Subset<T, MachineParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineParameterAggregateArgs>(args: Subset<T, MachineParameterAggregateArgs>): Prisma.PrismaPromise<GetMachineParameterAggregateType<T>>

    /**
     * Group by MachineParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineParameterGroupByArgs['orderBy'] }
        : { orderBy?: MachineParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineParameter model
   */
  readonly fields: MachineParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineParameter model
   */ 
  interface MachineParameterFieldRefs {
    readonly id: FieldRef<"MachineParameter", 'String'>
    readonly prefix: FieldRef<"MachineParameter", 'String'>
    readonly model: FieldRef<"MachineParameter", 'String'>
    readonly manufacturer: FieldRef<"MachineParameter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MachineParameter findUnique
   */
  export type MachineParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter, which MachineParameter to fetch.
     */
    where: MachineParameterWhereUniqueInput
  }

  /**
   * MachineParameter findUniqueOrThrow
   */
  export type MachineParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter, which MachineParameter to fetch.
     */
    where: MachineParameterWhereUniqueInput
  }

  /**
   * MachineParameter findFirst
   */
  export type MachineParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter, which MachineParameter to fetch.
     */
    where?: MachineParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineParameters to fetch.
     */
    orderBy?: MachineParameterOrderByWithRelationInput | MachineParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineParameters.
     */
    cursor?: MachineParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineParameters.
     */
    distinct?: MachineParameterScalarFieldEnum | MachineParameterScalarFieldEnum[]
  }

  /**
   * MachineParameter findFirstOrThrow
   */
  export type MachineParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter, which MachineParameter to fetch.
     */
    where?: MachineParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineParameters to fetch.
     */
    orderBy?: MachineParameterOrderByWithRelationInput | MachineParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineParameters.
     */
    cursor?: MachineParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineParameters.
     */
    distinct?: MachineParameterScalarFieldEnum | MachineParameterScalarFieldEnum[]
  }

  /**
   * MachineParameter findMany
   */
  export type MachineParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter, which MachineParameters to fetch.
     */
    where?: MachineParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineParameters to fetch.
     */
    orderBy?: MachineParameterOrderByWithRelationInput | MachineParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineParameters.
     */
    cursor?: MachineParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineParameters.
     */
    skip?: number
    distinct?: MachineParameterScalarFieldEnum | MachineParameterScalarFieldEnum[]
  }

  /**
   * MachineParameter create
   */
  export type MachineParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * The data needed to create a MachineParameter.
     */
    data: XOR<MachineParameterCreateInput, MachineParameterUncheckedCreateInput>
  }

  /**
   * MachineParameter createMany
   */
  export type MachineParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineParameters.
     */
    data: MachineParameterCreateManyInput | MachineParameterCreateManyInput[]
  }

  /**
   * MachineParameter createManyAndReturn
   */
  export type MachineParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MachineParameters.
     */
    data: MachineParameterCreateManyInput | MachineParameterCreateManyInput[]
  }

  /**
   * MachineParameter update
   */
  export type MachineParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * The data needed to update a MachineParameter.
     */
    data: XOR<MachineParameterUpdateInput, MachineParameterUncheckedUpdateInput>
    /**
     * Choose, which MachineParameter to update.
     */
    where: MachineParameterWhereUniqueInput
  }

  /**
   * MachineParameter updateMany
   */
  export type MachineParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineParameters.
     */
    data: XOR<MachineParameterUpdateManyMutationInput, MachineParameterUncheckedUpdateManyInput>
    /**
     * Filter which MachineParameters to update
     */
    where?: MachineParameterWhereInput
  }

  /**
   * MachineParameter upsert
   */
  export type MachineParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * The filter to search for the MachineParameter to update in case it exists.
     */
    where: MachineParameterWhereUniqueInput
    /**
     * In case the MachineParameter found by the `where` argument doesn't exist, create a new MachineParameter with this data.
     */
    create: XOR<MachineParameterCreateInput, MachineParameterUncheckedCreateInput>
    /**
     * In case the MachineParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineParameterUpdateInput, MachineParameterUncheckedUpdateInput>
  }

  /**
   * MachineParameter delete
   */
  export type MachineParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
    /**
     * Filter which MachineParameter to delete.
     */
    where: MachineParameterWhereUniqueInput
  }

  /**
   * MachineParameter deleteMany
   */
  export type MachineParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineParameters to delete
     */
    where?: MachineParameterWhereInput
  }

  /**
   * MachineParameter without action
   */
  export type MachineParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineParameter
     */
    select?: MachineParameterSelect<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    role: string | null
    permissionType: string | null
    permissionKey: string | null
    isAllowed: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    role: string | null
    permissionType: string | null
    permissionKey: string | null
    isAllowed: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    role: number
    permissionType: number
    permissionKey: number
    isAllowed: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    role?: true
    permissionType?: true
    permissionKey?: true
    isAllowed?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    role?: true
    permissionType?: true
    permissionKey?: true
    isAllowed?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    role?: true
    permissionType?: true
    permissionKey?: true
    isAllowed?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    role: string
    permissionType: string
    permissionKey: string
    isAllowed: boolean
    updatedAt: Date
    updatedBy: string | null
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionType?: boolean
    permissionKey?: boolean
    isAllowed?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionType?: boolean
    permissionKey?: boolean
    isAllowed?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    role?: boolean
    permissionType?: boolean
    permissionKey?: boolean
    isAllowed?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      permissionType: string
      permissionKey: string
      isAllowed: boolean
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly role: FieldRef<"RolePermission", 'String'>
    readonly permissionType: FieldRef<"RolePermission", 'String'>
    readonly permissionKey: FieldRef<"RolePermission", 'String'>
    readonly isAllowed: FieldRef<"RolePermission", 'Boolean'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedBy: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
  }


  /**
   * Model SparePart
   */

  export type AggregateSparePart = {
    _count: SparePartCountAggregateOutputType | null
    _avg: SparePartAvgAggregateOutputType | null
    _sum: SparePartSumAggregateOutputType | null
    _min: SparePartMinAggregateOutputType | null
    _max: SparePartMaxAggregateOutputType | null
  }

  export type SparePartAvgAggregateOutputType = {
    defaultCost: number | null
  }

  export type SparePartSumAggregateOutputType = {
    defaultCost: number | null
  }

  export type SparePartMinAggregateOutputType = {
    id: string | null
    partNumber: string | null
    name: string | null
    description: string | null
    compatibleModels: string | null
    defaultCost: number | null
    isConsumable: boolean | null
    allowsMultiple: boolean | null
  }

  export type SparePartMaxAggregateOutputType = {
    id: string | null
    partNumber: string | null
    name: string | null
    description: string | null
    compatibleModels: string | null
    defaultCost: number | null
    isConsumable: boolean | null
    allowsMultiple: boolean | null
  }

  export type SparePartCountAggregateOutputType = {
    id: number
    partNumber: number
    name: number
    description: number
    compatibleModels: number
    defaultCost: number
    isConsumable: number
    allowsMultiple: number
    _all: number
  }


  export type SparePartAvgAggregateInputType = {
    defaultCost?: true
  }

  export type SparePartSumAggregateInputType = {
    defaultCost?: true
  }

  export type SparePartMinAggregateInputType = {
    id?: true
    partNumber?: true
    name?: true
    description?: true
    compatibleModels?: true
    defaultCost?: true
    isConsumable?: true
    allowsMultiple?: true
  }

  export type SparePartMaxAggregateInputType = {
    id?: true
    partNumber?: true
    name?: true
    description?: true
    compatibleModels?: true
    defaultCost?: true
    isConsumable?: true
    allowsMultiple?: true
  }

  export type SparePartCountAggregateInputType = {
    id?: true
    partNumber?: true
    name?: true
    description?: true
    compatibleModels?: true
    defaultCost?: true
    isConsumable?: true
    allowsMultiple?: true
    _all?: true
  }

  export type SparePartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SparePart to aggregate.
     */
    where?: SparePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpareParts to fetch.
     */
    orderBy?: SparePartOrderByWithRelationInput | SparePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SparePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpareParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpareParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpareParts
    **/
    _count?: true | SparePartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SparePartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SparePartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SparePartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SparePartMaxAggregateInputType
  }

  export type GetSparePartAggregateType<T extends SparePartAggregateArgs> = {
        [P in keyof T & keyof AggregateSparePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSparePart[P]>
      : GetScalarType<T[P], AggregateSparePart[P]>
  }




  export type SparePartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SparePartWhereInput
    orderBy?: SparePartOrderByWithAggregationInput | SparePartOrderByWithAggregationInput[]
    by: SparePartScalarFieldEnum[] | SparePartScalarFieldEnum
    having?: SparePartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SparePartCountAggregateInputType | true
    _avg?: SparePartAvgAggregateInputType
    _sum?: SparePartSumAggregateInputType
    _min?: SparePartMinAggregateInputType
    _max?: SparePartMaxAggregateInputType
  }

  export type SparePartGroupByOutputType = {
    id: string
    partNumber: string | null
    name: string
    description: string | null
    compatibleModels: string | null
    defaultCost: number
    isConsumable: boolean | null
    allowsMultiple: boolean | null
    _count: SparePartCountAggregateOutputType | null
    _avg: SparePartAvgAggregateOutputType | null
    _sum: SparePartSumAggregateOutputType | null
    _min: SparePartMinAggregateOutputType | null
    _max: SparePartMaxAggregateOutputType | null
  }

  type GetSparePartGroupByPayload<T extends SparePartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SparePartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SparePartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SparePartGroupByOutputType[P]>
            : GetScalarType<T[P], SparePartGroupByOutputType[P]>
        }
      >
    >


  export type SparePartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partNumber?: boolean
    name?: boolean
    description?: boolean
    compatibleModels?: boolean
    defaultCost?: boolean
    isConsumable?: boolean
    allowsMultiple?: boolean
    inventoryItems?: boolean | SparePart$inventoryItemsArgs<ExtArgs>
    _count?: boolean | SparePartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sparePart"]>

  export type SparePartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partNumber?: boolean
    name?: boolean
    description?: boolean
    compatibleModels?: boolean
    defaultCost?: boolean
    isConsumable?: boolean
    allowsMultiple?: boolean
  }, ExtArgs["result"]["sparePart"]>

  export type SparePartSelectScalar = {
    id?: boolean
    partNumber?: boolean
    name?: boolean
    description?: boolean
    compatibleModels?: boolean
    defaultCost?: boolean
    isConsumable?: boolean
    allowsMultiple?: boolean
  }

  export type SparePartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | SparePart$inventoryItemsArgs<ExtArgs>
    _count?: boolean | SparePartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SparePartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SparePartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SparePart"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partNumber: string | null
      name: string
      description: string | null
      compatibleModels: string | null
      defaultCost: number
      isConsumable: boolean | null
      allowsMultiple: boolean | null
    }, ExtArgs["result"]["sparePart"]>
    composites: {}
  }

  type SparePartGetPayload<S extends boolean | null | undefined | SparePartDefaultArgs> = $Result.GetResult<Prisma.$SparePartPayload, S>

  type SparePartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SparePartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SparePartCountAggregateInputType | true
    }

  export interface SparePartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SparePart'], meta: { name: 'SparePart' } }
    /**
     * Find zero or one SparePart that matches the filter.
     * @param {SparePartFindUniqueArgs} args - Arguments to find a SparePart
     * @example
     * // Get one SparePart
     * const sparePart = await prisma.sparePart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SparePartFindUniqueArgs>(args: SelectSubset<T, SparePartFindUniqueArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SparePart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SparePartFindUniqueOrThrowArgs} args - Arguments to find a SparePart
     * @example
     * // Get one SparePart
     * const sparePart = await prisma.sparePart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SparePartFindUniqueOrThrowArgs>(args: SelectSubset<T, SparePartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SparePart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartFindFirstArgs} args - Arguments to find a SparePart
     * @example
     * // Get one SparePart
     * const sparePart = await prisma.sparePart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SparePartFindFirstArgs>(args?: SelectSubset<T, SparePartFindFirstArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SparePart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartFindFirstOrThrowArgs} args - Arguments to find a SparePart
     * @example
     * // Get one SparePart
     * const sparePart = await prisma.sparePart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SparePartFindFirstOrThrowArgs>(args?: SelectSubset<T, SparePartFindFirstOrThrowArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpareParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpareParts
     * const spareParts = await prisma.sparePart.findMany()
     * 
     * // Get first 10 SpareParts
     * const spareParts = await prisma.sparePart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sparePartWithIdOnly = await prisma.sparePart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SparePartFindManyArgs>(args?: SelectSubset<T, SparePartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SparePart.
     * @param {SparePartCreateArgs} args - Arguments to create a SparePart.
     * @example
     * // Create one SparePart
     * const SparePart = await prisma.sparePart.create({
     *   data: {
     *     // ... data to create a SparePart
     *   }
     * })
     * 
     */
    create<T extends SparePartCreateArgs>(args: SelectSubset<T, SparePartCreateArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpareParts.
     * @param {SparePartCreateManyArgs} args - Arguments to create many SpareParts.
     * @example
     * // Create many SpareParts
     * const sparePart = await prisma.sparePart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SparePartCreateManyArgs>(args?: SelectSubset<T, SparePartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpareParts and returns the data saved in the database.
     * @param {SparePartCreateManyAndReturnArgs} args - Arguments to create many SpareParts.
     * @example
     * // Create many SpareParts
     * const sparePart = await prisma.sparePart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpareParts and only return the `id`
     * const sparePartWithIdOnly = await prisma.sparePart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SparePartCreateManyAndReturnArgs>(args?: SelectSubset<T, SparePartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SparePart.
     * @param {SparePartDeleteArgs} args - Arguments to delete one SparePart.
     * @example
     * // Delete one SparePart
     * const SparePart = await prisma.sparePart.delete({
     *   where: {
     *     // ... filter to delete one SparePart
     *   }
     * })
     * 
     */
    delete<T extends SparePartDeleteArgs>(args: SelectSubset<T, SparePartDeleteArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SparePart.
     * @param {SparePartUpdateArgs} args - Arguments to update one SparePart.
     * @example
     * // Update one SparePart
     * const sparePart = await prisma.sparePart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SparePartUpdateArgs>(args: SelectSubset<T, SparePartUpdateArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpareParts.
     * @param {SparePartDeleteManyArgs} args - Arguments to filter SpareParts to delete.
     * @example
     * // Delete a few SpareParts
     * const { count } = await prisma.sparePart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SparePartDeleteManyArgs>(args?: SelectSubset<T, SparePartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpareParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpareParts
     * const sparePart = await prisma.sparePart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SparePartUpdateManyArgs>(args: SelectSubset<T, SparePartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SparePart.
     * @param {SparePartUpsertArgs} args - Arguments to update or create a SparePart.
     * @example
     * // Update or create a SparePart
     * const sparePart = await prisma.sparePart.upsert({
     *   create: {
     *     // ... data to create a SparePart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SparePart we want to update
     *   }
     * })
     */
    upsert<T extends SparePartUpsertArgs>(args: SelectSubset<T, SparePartUpsertArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpareParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartCountArgs} args - Arguments to filter SpareParts to count.
     * @example
     * // Count the number of SpareParts
     * const count = await prisma.sparePart.count({
     *   where: {
     *     // ... the filter for the SpareParts we want to count
     *   }
     * })
    **/
    count<T extends SparePartCountArgs>(
      args?: Subset<T, SparePartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SparePartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SparePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SparePartAggregateArgs>(args: Subset<T, SparePartAggregateArgs>): Prisma.PrismaPromise<GetSparePartAggregateType<T>>

    /**
     * Group by SparePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SparePartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SparePartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SparePartGroupByArgs['orderBy'] }
        : { orderBy?: SparePartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SparePartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSparePartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SparePart model
   */
  readonly fields: SparePartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SparePart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SparePartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends SparePart$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, SparePart$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SparePart model
   */ 
  interface SparePartFieldRefs {
    readonly id: FieldRef<"SparePart", 'String'>
    readonly partNumber: FieldRef<"SparePart", 'String'>
    readonly name: FieldRef<"SparePart", 'String'>
    readonly description: FieldRef<"SparePart", 'String'>
    readonly compatibleModels: FieldRef<"SparePart", 'String'>
    readonly defaultCost: FieldRef<"SparePart", 'Float'>
    readonly isConsumable: FieldRef<"SparePart", 'Boolean'>
    readonly allowsMultiple: FieldRef<"SparePart", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SparePart findUnique
   */
  export type SparePartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter, which SparePart to fetch.
     */
    where: SparePartWhereUniqueInput
  }

  /**
   * SparePart findUniqueOrThrow
   */
  export type SparePartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter, which SparePart to fetch.
     */
    where: SparePartWhereUniqueInput
  }

  /**
   * SparePart findFirst
   */
  export type SparePartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter, which SparePart to fetch.
     */
    where?: SparePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpareParts to fetch.
     */
    orderBy?: SparePartOrderByWithRelationInput | SparePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpareParts.
     */
    cursor?: SparePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpareParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpareParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpareParts.
     */
    distinct?: SparePartScalarFieldEnum | SparePartScalarFieldEnum[]
  }

  /**
   * SparePart findFirstOrThrow
   */
  export type SparePartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter, which SparePart to fetch.
     */
    where?: SparePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpareParts to fetch.
     */
    orderBy?: SparePartOrderByWithRelationInput | SparePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpareParts.
     */
    cursor?: SparePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpareParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpareParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpareParts.
     */
    distinct?: SparePartScalarFieldEnum | SparePartScalarFieldEnum[]
  }

  /**
   * SparePart findMany
   */
  export type SparePartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter, which SpareParts to fetch.
     */
    where?: SparePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpareParts to fetch.
     */
    orderBy?: SparePartOrderByWithRelationInput | SparePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpareParts.
     */
    cursor?: SparePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpareParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpareParts.
     */
    skip?: number
    distinct?: SparePartScalarFieldEnum | SparePartScalarFieldEnum[]
  }

  /**
   * SparePart create
   */
  export type SparePartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * The data needed to create a SparePart.
     */
    data: XOR<SparePartCreateInput, SparePartUncheckedCreateInput>
  }

  /**
   * SparePart createMany
   */
  export type SparePartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpareParts.
     */
    data: SparePartCreateManyInput | SparePartCreateManyInput[]
  }

  /**
   * SparePart createManyAndReturn
   */
  export type SparePartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpareParts.
     */
    data: SparePartCreateManyInput | SparePartCreateManyInput[]
  }

  /**
   * SparePart update
   */
  export type SparePartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * The data needed to update a SparePart.
     */
    data: XOR<SparePartUpdateInput, SparePartUncheckedUpdateInput>
    /**
     * Choose, which SparePart to update.
     */
    where: SparePartWhereUniqueInput
  }

  /**
   * SparePart updateMany
   */
  export type SparePartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpareParts.
     */
    data: XOR<SparePartUpdateManyMutationInput, SparePartUncheckedUpdateManyInput>
    /**
     * Filter which SpareParts to update
     */
    where?: SparePartWhereInput
  }

  /**
   * SparePart upsert
   */
  export type SparePartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * The filter to search for the SparePart to update in case it exists.
     */
    where: SparePartWhereUniqueInput
    /**
     * In case the SparePart found by the `where` argument doesn't exist, create a new SparePart with this data.
     */
    create: XOR<SparePartCreateInput, SparePartUncheckedCreateInput>
    /**
     * In case the SparePart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SparePartUpdateInput, SparePartUncheckedUpdateInput>
  }

  /**
   * SparePart delete
   */
  export type SparePartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
    /**
     * Filter which SparePart to delete.
     */
    where: SparePartWhereUniqueInput
  }

  /**
   * SparePart deleteMany
   */
  export type SparePartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpareParts to delete
     */
    where?: SparePartWhereInput
  }

  /**
   * SparePart.inventoryItems
   */
  export type SparePart$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * SparePart without action
   */
  export type SparePartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SparePart
     */
    select?: SparePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SparePartInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
    minLevel: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
    minLevel: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    partId: string | null
    quantity: number | null
    minLevel: number | null
    location: string | null
    branchId: string | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    partId: string | null
    quantity: number | null
    minLevel: number | null
    location: string | null
    branchId: string | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    partId: number
    quantity: number
    minLevel: number
    location: number
    branchId: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
    minLevel?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
    minLevel?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    partId?: true
    quantity?: true
    minLevel?: true
    location?: true
    branchId?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    partId?: true
    quantity?: true
    minLevel?: true
    location?: true
    branchId?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    partId?: true
    quantity?: true
    minLevel?: true
    location?: true
    branchId?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    partId: string
    quantity: number
    minLevel: number
    location: string | null
    branchId: string | null
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    quantity?: boolean
    minLevel?: boolean
    location?: boolean
    branchId?: boolean
    part?: boolean | SparePartDefaultArgs<ExtArgs>
    branch?: boolean | InventoryItem$branchArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    quantity?: boolean
    minLevel?: boolean
    location?: boolean
    branchId?: boolean
    part?: boolean | SparePartDefaultArgs<ExtArgs>
    branch?: boolean | InventoryItem$branchArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    partId?: boolean
    quantity?: boolean
    minLevel?: boolean
    location?: boolean
    branchId?: boolean
  }

  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | SparePartDefaultArgs<ExtArgs>
    branch?: boolean | InventoryItem$branchArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | SparePartDefaultArgs<ExtArgs>
    branch?: boolean | InventoryItem$branchArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      part: Prisma.$SparePartPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partId: string
      quantity: number
      minLevel: number
      location: string | null
      branchId: string | null
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends SparePartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SparePartDefaultArgs<ExtArgs>>): Prisma__SparePartClient<$Result.GetResult<Prisma.$SparePartPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends InventoryItem$branchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */ 
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly partId: FieldRef<"InventoryItem", 'String'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly minLevel: FieldRef<"InventoryItem", 'Int'>
    readonly location: FieldRef<"InventoryItem", 'String'>
    readonly branchId: FieldRef<"InventoryItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem.branch
   */
  export type InventoryItem$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRequest
   */

  export type AggregateMaintenanceRequest = {
    _count: MaintenanceRequestCountAggregateOutputType | null
    _avg: MaintenanceRequestAvgAggregateOutputType | null
    _sum: MaintenanceRequestSumAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  export type MaintenanceRequestAvgAggregateOutputType = {
    totalCost: number | null
  }

  export type MaintenanceRequestSumAggregateOutputType = {
    totalCost: number | null
  }

  export type MaintenanceRequestMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    posMachineId: string | null
    customerName: string | null
    machineModel: string | null
    machineManufacturer: string | null
    serialNumber: string | null
    status: string | null
    branchId: string | null
    servicedByBranchId: string | null
    technician: string | null
    notes: string | null
    complaint: string | null
    actionTaken: string | null
    createdAt: Date | null
    closingUserId: string | null
    closingUserName: string | null
    closingTimestamp: Date | null
    usedParts: string | null
    receiptNumber: string | null
    totalCost: number | null
  }

  export type MaintenanceRequestMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    posMachineId: string | null
    customerName: string | null
    machineModel: string | null
    machineManufacturer: string | null
    serialNumber: string | null
    status: string | null
    branchId: string | null
    servicedByBranchId: string | null
    technician: string | null
    notes: string | null
    complaint: string | null
    actionTaken: string | null
    createdAt: Date | null
    closingUserId: string | null
    closingUserName: string | null
    closingTimestamp: Date | null
    usedParts: string | null
    receiptNumber: string | null
    totalCost: number | null
  }

  export type MaintenanceRequestCountAggregateOutputType = {
    id: number
    customerId: number
    posMachineId: number
    customerName: number
    machineModel: number
    machineManufacturer: number
    serialNumber: number
    status: number
    branchId: number
    servicedByBranchId: number
    technician: number
    notes: number
    complaint: number
    actionTaken: number
    createdAt: number
    closingUserId: number
    closingUserName: number
    closingTimestamp: number
    usedParts: number
    receiptNumber: number
    totalCost: number
    _all: number
  }


  export type MaintenanceRequestAvgAggregateInputType = {
    totalCost?: true
  }

  export type MaintenanceRequestSumAggregateInputType = {
    totalCost?: true
  }

  export type MaintenanceRequestMinAggregateInputType = {
    id?: true
    customerId?: true
    posMachineId?: true
    customerName?: true
    machineModel?: true
    machineManufacturer?: true
    serialNumber?: true
    status?: true
    branchId?: true
    servicedByBranchId?: true
    technician?: true
    notes?: true
    complaint?: true
    actionTaken?: true
    createdAt?: true
    closingUserId?: true
    closingUserName?: true
    closingTimestamp?: true
    usedParts?: true
    receiptNumber?: true
    totalCost?: true
  }

  export type MaintenanceRequestMaxAggregateInputType = {
    id?: true
    customerId?: true
    posMachineId?: true
    customerName?: true
    machineModel?: true
    machineManufacturer?: true
    serialNumber?: true
    status?: true
    branchId?: true
    servicedByBranchId?: true
    technician?: true
    notes?: true
    complaint?: true
    actionTaken?: true
    createdAt?: true
    closingUserId?: true
    closingUserName?: true
    closingTimestamp?: true
    usedParts?: true
    receiptNumber?: true
    totalCost?: true
  }

  export type MaintenanceRequestCountAggregateInputType = {
    id?: true
    customerId?: true
    posMachineId?: true
    customerName?: true
    machineModel?: true
    machineManufacturer?: true
    serialNumber?: true
    status?: true
    branchId?: true
    servicedByBranchId?: true
    technician?: true
    notes?: true
    complaint?: true
    actionTaken?: true
    createdAt?: true
    closingUserId?: true
    closingUserName?: true
    closingTimestamp?: true
    usedParts?: true
    receiptNumber?: true
    totalCost?: true
    _all?: true
  }

  export type MaintenanceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequest to aggregate.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRequests
    **/
    _count?: true | MaintenanceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type GetMaintenanceRequestAggregateType<T extends MaintenanceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
  }




  export type MaintenanceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithAggregationInput | MaintenanceRequestOrderByWithAggregationInput[]
    by: MaintenanceRequestScalarFieldEnum[] | MaintenanceRequestScalarFieldEnum
    having?: MaintenanceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRequestCountAggregateInputType | true
    _avg?: MaintenanceRequestAvgAggregateInputType
    _sum?: MaintenanceRequestSumAggregateInputType
    _min?: MaintenanceRequestMinAggregateInputType
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type MaintenanceRequestGroupByOutputType = {
    id: string
    customerId: string
    posMachineId: string | null
    customerName: string | null
    machineModel: string | null
    machineManufacturer: string | null
    serialNumber: string | null
    status: string
    branchId: string | null
    servicedByBranchId: string | null
    technician: string | null
    notes: string | null
    complaint: string | null
    actionTaken: string | null
    createdAt: Date
    closingUserId: string | null
    closingUserName: string | null
    closingTimestamp: Date | null
    usedParts: string | null
    receiptNumber: string | null
    totalCost: number | null
    _count: MaintenanceRequestCountAggregateOutputType | null
    _avg: MaintenanceRequestAvgAggregateOutputType | null
    _sum: MaintenanceRequestSumAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceRequestGroupByPayload<T extends MaintenanceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    posMachineId?: boolean
    customerName?: boolean
    machineModel?: boolean
    machineManufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    branchId?: boolean
    servicedByBranchId?: boolean
    technician?: boolean
    notes?: boolean
    complaint?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    closingUserId?: boolean
    closingUserName?: boolean
    closingTimestamp?: boolean
    usedParts?: boolean
    receiptNumber?: boolean
    totalCost?: boolean
    approval?: boolean | MaintenanceRequest$approvalArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posMachine?: boolean | MaintenanceRequest$posMachineArgs<ExtArgs>
    branch?: boolean | MaintenanceRequest$branchArgs<ExtArgs>
    vouchers?: boolean | MaintenanceRequest$vouchersArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    posMachineId?: boolean
    customerName?: boolean
    machineModel?: boolean
    machineManufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    branchId?: boolean
    servicedByBranchId?: boolean
    technician?: boolean
    notes?: boolean
    complaint?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    closingUserId?: boolean
    closingUserName?: boolean
    closingTimestamp?: boolean
    usedParts?: boolean
    receiptNumber?: boolean
    totalCost?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posMachine?: boolean | MaintenanceRequest$posMachineArgs<ExtArgs>
    branch?: boolean | MaintenanceRequest$branchArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectScalar = {
    id?: boolean
    customerId?: boolean
    posMachineId?: boolean
    customerName?: boolean
    machineModel?: boolean
    machineManufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    branchId?: boolean
    servicedByBranchId?: boolean
    technician?: boolean
    notes?: boolean
    complaint?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    closingUserId?: boolean
    closingUserName?: boolean
    closingTimestamp?: boolean
    usedParts?: boolean
    receiptNumber?: boolean
    totalCost?: boolean
  }

  export type MaintenanceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | MaintenanceRequest$approvalArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posMachine?: boolean | MaintenanceRequest$posMachineArgs<ExtArgs>
    branch?: boolean | MaintenanceRequest$branchArgs<ExtArgs>
    vouchers?: boolean | MaintenanceRequest$vouchersArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posMachine?: boolean | MaintenanceRequest$posMachineArgs<ExtArgs>
    branch?: boolean | MaintenanceRequest$branchArgs<ExtArgs>
  }

  export type $MaintenanceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRequest"
    objects: {
      approval: Prisma.$MaintenanceApprovalPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
      posMachine: Prisma.$PosMachinePayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      vouchers: Prisma.$RepairVoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      posMachineId: string | null
      customerName: string | null
      machineModel: string | null
      machineManufacturer: string | null
      serialNumber: string | null
      status: string
      branchId: string | null
      servicedByBranchId: string | null
      technician: string | null
      notes: string | null
      complaint: string | null
      actionTaken: string | null
      createdAt: Date
      closingUserId: string | null
      closingUserName: string | null
      closingTimestamp: Date | null
      usedParts: string | null
      receiptNumber: string | null
      totalCost: number | null
    }, ExtArgs["result"]["maintenanceRequest"]>
    composites: {}
  }

  type MaintenanceRequestGetPayload<S extends boolean | null | undefined | MaintenanceRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRequestPayload, S>

  type MaintenanceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceRequestCountAggregateInputType | true
    }

  export interface MaintenanceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRequest'], meta: { name: 'MaintenanceRequest' } }
    /**
     * Find zero or one MaintenanceRequest that matches the filter.
     * @param {MaintenanceRequestFindUniqueArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
     * 
     * // Get first 10 MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceRequest.
     * @param {MaintenanceRequestCreateArgs} args - Arguments to create a MaintenanceRequest.
     * @example
     * // Create one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRequestCreateArgs>(args: SelectSubset<T, MaintenanceRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceRequests.
     * @param {MaintenanceRequestCreateManyArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRequests and returns the data saved in the database.
     * @param {MaintenanceRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceRequest.
     * @param {MaintenanceRequestDeleteArgs} args - Arguments to delete one MaintenanceRequest.
     * @example
     * // Delete one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRequestDeleteArgs>(args: SelectSubset<T, MaintenanceRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceRequest.
     * @param {MaintenanceRequestUpdateArgs} args - Arguments to update one MaintenanceRequest.
     * @example
     * // Update one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRequestUpdateArgs>(args: SelectSubset<T, MaintenanceRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceRequests.
     * @param {MaintenanceRequestDeleteManyArgs} args - Arguments to filter MaintenanceRequests to delete.
     * @example
     * // Delete a few MaintenanceRequests
     * const { count } = await prisma.maintenanceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceRequest.
     * @param {MaintenanceRequestUpsertArgs} args - Arguments to update or create a MaintenanceRequest.
     * @example
     * // Update or create a MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRequestUpsertArgs>(args: SelectSubset<T, MaintenanceRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestCountArgs} args - Arguments to filter MaintenanceRequests to count.
     * @example
     * // Count the number of MaintenanceRequests
     * const count = await prisma.maintenanceRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRequestCountArgs>(
      args?: Subset<T, MaintenanceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRequestAggregateArgs>(args: Subset<T, MaintenanceRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRequestAggregateType<T>>

    /**
     * Group by MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRequest model
   */
  readonly fields: MaintenanceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approval<T extends MaintenanceRequest$approvalArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$approvalArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posMachine<T extends MaintenanceRequest$posMachineArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$posMachineArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends MaintenanceRequest$branchArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vouchers<T extends MaintenanceRequest$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRequest model
   */ 
  interface MaintenanceRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceRequest", 'String'>
    readonly customerId: FieldRef<"MaintenanceRequest", 'String'>
    readonly posMachineId: FieldRef<"MaintenanceRequest", 'String'>
    readonly customerName: FieldRef<"MaintenanceRequest", 'String'>
    readonly machineModel: FieldRef<"MaintenanceRequest", 'String'>
    readonly machineManufacturer: FieldRef<"MaintenanceRequest", 'String'>
    readonly serialNumber: FieldRef<"MaintenanceRequest", 'String'>
    readonly status: FieldRef<"MaintenanceRequest", 'String'>
    readonly branchId: FieldRef<"MaintenanceRequest", 'String'>
    readonly servicedByBranchId: FieldRef<"MaintenanceRequest", 'String'>
    readonly technician: FieldRef<"MaintenanceRequest", 'String'>
    readonly notes: FieldRef<"MaintenanceRequest", 'String'>
    readonly complaint: FieldRef<"MaintenanceRequest", 'String'>
    readonly actionTaken: FieldRef<"MaintenanceRequest", 'String'>
    readonly createdAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly closingUserId: FieldRef<"MaintenanceRequest", 'String'>
    readonly closingUserName: FieldRef<"MaintenanceRequest", 'String'>
    readonly closingTimestamp: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly usedParts: FieldRef<"MaintenanceRequest", 'String'>
    readonly receiptNumber: FieldRef<"MaintenanceRequest", 'String'>
    readonly totalCost: FieldRef<"MaintenanceRequest", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRequest findUnique
   */
  export type MaintenanceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findUniqueOrThrow
   */
  export type MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findFirst
   */
  export type MaintenanceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findFirstOrThrow
   */
  export type MaintenanceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findMany
   */
  export type MaintenanceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequests to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest create
   */
  export type MaintenanceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceRequest createMany
   */
  export type MaintenanceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
  }

  /**
   * MaintenanceRequest createManyAndReturn
   */
  export type MaintenanceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest update
   */
  export type MaintenanceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRequest to update.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest updateMany
   */
  export type MaintenanceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
  }

  /**
   * MaintenanceRequest upsert
   */
  export type MaintenanceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRequest to update in case it exists.
     */
    where: MaintenanceRequestWhereUniqueInput
    /**
     * In case the MaintenanceRequest found by the `where` argument doesn't exist, create a new MaintenanceRequest with this data.
     */
    create: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceRequest delete
   */
  export type MaintenanceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRequest to delete.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest deleteMany
   */
  export type MaintenanceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequests to delete
     */
    where?: MaintenanceRequestWhereInput
  }

  /**
   * MaintenanceRequest.approval
   */
  export type MaintenanceRequest$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    where?: MaintenanceApprovalWhereInput
  }

  /**
   * MaintenanceRequest.posMachine
   */
  export type MaintenanceRequest$posMachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    where?: PosMachineWhereInput
  }

  /**
   * MaintenanceRequest.branch
   */
  export type MaintenanceRequest$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MaintenanceRequest.vouchers
   */
  export type MaintenanceRequest$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    where?: RepairVoucherWhereInput
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    cursor?: RepairVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairVoucherScalarFieldEnum | RepairVoucherScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest without action
   */
  export type MaintenanceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
  }


  /**
   * Model PriceChangeLog
   */

  export type AggregatePriceChangeLog = {
    _count: PriceChangeLogCountAggregateOutputType | null
    _avg: PriceChangeLogAvgAggregateOutputType | null
    _sum: PriceChangeLogSumAggregateOutputType | null
    _min: PriceChangeLogMinAggregateOutputType | null
    _max: PriceChangeLogMaxAggregateOutputType | null
  }

  export type PriceChangeLogAvgAggregateOutputType = {
    oldCost: number | null
    newCost: number | null
  }

  export type PriceChangeLogSumAggregateOutputType = {
    oldCost: number | null
    newCost: number | null
  }

  export type PriceChangeLogMinAggregateOutputType = {
    id: string | null
    partId: string | null
    oldCost: number | null
    newCost: number | null
    changedAt: Date | null
    userId: string | null
  }

  export type PriceChangeLogMaxAggregateOutputType = {
    id: string | null
    partId: string | null
    oldCost: number | null
    newCost: number | null
    changedAt: Date | null
    userId: string | null
  }

  export type PriceChangeLogCountAggregateOutputType = {
    id: number
    partId: number
    oldCost: number
    newCost: number
    changedAt: number
    userId: number
    _all: number
  }


  export type PriceChangeLogAvgAggregateInputType = {
    oldCost?: true
    newCost?: true
  }

  export type PriceChangeLogSumAggregateInputType = {
    oldCost?: true
    newCost?: true
  }

  export type PriceChangeLogMinAggregateInputType = {
    id?: true
    partId?: true
    oldCost?: true
    newCost?: true
    changedAt?: true
    userId?: true
  }

  export type PriceChangeLogMaxAggregateInputType = {
    id?: true
    partId?: true
    oldCost?: true
    newCost?: true
    changedAt?: true
    userId?: true
  }

  export type PriceChangeLogCountAggregateInputType = {
    id?: true
    partId?: true
    oldCost?: true
    newCost?: true
    changedAt?: true
    userId?: true
    _all?: true
  }

  export type PriceChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceChangeLog to aggregate.
     */
    where?: PriceChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceChangeLogs to fetch.
     */
    orderBy?: PriceChangeLogOrderByWithRelationInput | PriceChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceChangeLogs
    **/
    _count?: true | PriceChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceChangeLogMaxAggregateInputType
  }

  export type GetPriceChangeLogAggregateType<T extends PriceChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceChangeLog[P]>
      : GetScalarType<T[P], AggregatePriceChangeLog[P]>
  }




  export type PriceChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceChangeLogWhereInput
    orderBy?: PriceChangeLogOrderByWithAggregationInput | PriceChangeLogOrderByWithAggregationInput[]
    by: PriceChangeLogScalarFieldEnum[] | PriceChangeLogScalarFieldEnum
    having?: PriceChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceChangeLogCountAggregateInputType | true
    _avg?: PriceChangeLogAvgAggregateInputType
    _sum?: PriceChangeLogSumAggregateInputType
    _min?: PriceChangeLogMinAggregateInputType
    _max?: PriceChangeLogMaxAggregateInputType
  }

  export type PriceChangeLogGroupByOutputType = {
    id: string
    partId: string
    oldCost: number
    newCost: number
    changedAt: Date
    userId: string | null
    _count: PriceChangeLogCountAggregateOutputType | null
    _avg: PriceChangeLogAvgAggregateOutputType | null
    _sum: PriceChangeLogSumAggregateOutputType | null
    _min: PriceChangeLogMinAggregateOutputType | null
    _max: PriceChangeLogMaxAggregateOutputType | null
  }

  type GetPriceChangeLogGroupByPayload<T extends PriceChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], PriceChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type PriceChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    oldCost?: boolean
    newCost?: boolean
    changedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["priceChangeLog"]>

  export type PriceChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    oldCost?: boolean
    newCost?: boolean
    changedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["priceChangeLog"]>

  export type PriceChangeLogSelectScalar = {
    id?: boolean
    partId?: boolean
    oldCost?: boolean
    newCost?: boolean
    changedAt?: boolean
    userId?: boolean
  }


  export type $PriceChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceChangeLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partId: string
      oldCost: number
      newCost: number
      changedAt: Date
      userId: string | null
    }, ExtArgs["result"]["priceChangeLog"]>
    composites: {}
  }

  type PriceChangeLogGetPayload<S extends boolean | null | undefined | PriceChangeLogDefaultArgs> = $Result.GetResult<Prisma.$PriceChangeLogPayload, S>

  type PriceChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceChangeLogCountAggregateInputType | true
    }

  export interface PriceChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceChangeLog'], meta: { name: 'PriceChangeLog' } }
    /**
     * Find zero or one PriceChangeLog that matches the filter.
     * @param {PriceChangeLogFindUniqueArgs} args - Arguments to find a PriceChangeLog
     * @example
     * // Get one PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceChangeLogFindUniqueArgs>(args: SelectSubset<T, PriceChangeLogFindUniqueArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceChangeLogFindUniqueOrThrowArgs} args - Arguments to find a PriceChangeLog
     * @example
     * // Get one PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogFindFirstArgs} args - Arguments to find a PriceChangeLog
     * @example
     * // Get one PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceChangeLogFindFirstArgs>(args?: SelectSubset<T, PriceChangeLogFindFirstArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogFindFirstOrThrowArgs} args - Arguments to find a PriceChangeLog
     * @example
     * // Get one PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceChangeLogs
     * const priceChangeLogs = await prisma.priceChangeLog.findMany()
     * 
     * // Get first 10 PriceChangeLogs
     * const priceChangeLogs = await prisma.priceChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceChangeLogWithIdOnly = await prisma.priceChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceChangeLogFindManyArgs>(args?: SelectSubset<T, PriceChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceChangeLog.
     * @param {PriceChangeLogCreateArgs} args - Arguments to create a PriceChangeLog.
     * @example
     * // Create one PriceChangeLog
     * const PriceChangeLog = await prisma.priceChangeLog.create({
     *   data: {
     *     // ... data to create a PriceChangeLog
     *   }
     * })
     * 
     */
    create<T extends PriceChangeLogCreateArgs>(args: SelectSubset<T, PriceChangeLogCreateArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceChangeLogs.
     * @param {PriceChangeLogCreateManyArgs} args - Arguments to create many PriceChangeLogs.
     * @example
     * // Create many PriceChangeLogs
     * const priceChangeLog = await prisma.priceChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceChangeLogCreateManyArgs>(args?: SelectSubset<T, PriceChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceChangeLogs and returns the data saved in the database.
     * @param {PriceChangeLogCreateManyAndReturnArgs} args - Arguments to create many PriceChangeLogs.
     * @example
     * // Create many PriceChangeLogs
     * const priceChangeLog = await prisma.priceChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceChangeLogs and only return the `id`
     * const priceChangeLogWithIdOnly = await prisma.priceChangeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceChangeLog.
     * @param {PriceChangeLogDeleteArgs} args - Arguments to delete one PriceChangeLog.
     * @example
     * // Delete one PriceChangeLog
     * const PriceChangeLog = await prisma.priceChangeLog.delete({
     *   where: {
     *     // ... filter to delete one PriceChangeLog
     *   }
     * })
     * 
     */
    delete<T extends PriceChangeLogDeleteArgs>(args: SelectSubset<T, PriceChangeLogDeleteArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceChangeLog.
     * @param {PriceChangeLogUpdateArgs} args - Arguments to update one PriceChangeLog.
     * @example
     * // Update one PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceChangeLogUpdateArgs>(args: SelectSubset<T, PriceChangeLogUpdateArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceChangeLogs.
     * @param {PriceChangeLogDeleteManyArgs} args - Arguments to filter PriceChangeLogs to delete.
     * @example
     * // Delete a few PriceChangeLogs
     * const { count } = await prisma.priceChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceChangeLogDeleteManyArgs>(args?: SelectSubset<T, PriceChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceChangeLogs
     * const priceChangeLog = await prisma.priceChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceChangeLogUpdateManyArgs>(args: SelectSubset<T, PriceChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceChangeLog.
     * @param {PriceChangeLogUpsertArgs} args - Arguments to update or create a PriceChangeLog.
     * @example
     * // Update or create a PriceChangeLog
     * const priceChangeLog = await prisma.priceChangeLog.upsert({
     *   create: {
     *     // ... data to create a PriceChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends PriceChangeLogUpsertArgs>(args: SelectSubset<T, PriceChangeLogUpsertArgs<ExtArgs>>): Prisma__PriceChangeLogClient<$Result.GetResult<Prisma.$PriceChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogCountArgs} args - Arguments to filter PriceChangeLogs to count.
     * @example
     * // Count the number of PriceChangeLogs
     * const count = await prisma.priceChangeLog.count({
     *   where: {
     *     // ... the filter for the PriceChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends PriceChangeLogCountArgs>(
      args?: Subset<T, PriceChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceChangeLogAggregateArgs>(args: Subset<T, PriceChangeLogAggregateArgs>): Prisma.PrismaPromise<GetPriceChangeLogAggregateType<T>>

    /**
     * Group by PriceChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: PriceChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceChangeLog model
   */
  readonly fields: PriceChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceChangeLog model
   */ 
  interface PriceChangeLogFieldRefs {
    readonly id: FieldRef<"PriceChangeLog", 'String'>
    readonly partId: FieldRef<"PriceChangeLog", 'String'>
    readonly oldCost: FieldRef<"PriceChangeLog", 'Float'>
    readonly newCost: FieldRef<"PriceChangeLog", 'Float'>
    readonly changedAt: FieldRef<"PriceChangeLog", 'DateTime'>
    readonly userId: FieldRef<"PriceChangeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PriceChangeLog findUnique
   */
  export type PriceChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which PriceChangeLog to fetch.
     */
    where: PriceChangeLogWhereUniqueInput
  }

  /**
   * PriceChangeLog findUniqueOrThrow
   */
  export type PriceChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which PriceChangeLog to fetch.
     */
    where: PriceChangeLogWhereUniqueInput
  }

  /**
   * PriceChangeLog findFirst
   */
  export type PriceChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which PriceChangeLog to fetch.
     */
    where?: PriceChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceChangeLogs to fetch.
     */
    orderBy?: PriceChangeLogOrderByWithRelationInput | PriceChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceChangeLogs.
     */
    cursor?: PriceChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceChangeLogs.
     */
    distinct?: PriceChangeLogScalarFieldEnum | PriceChangeLogScalarFieldEnum[]
  }

  /**
   * PriceChangeLog findFirstOrThrow
   */
  export type PriceChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which PriceChangeLog to fetch.
     */
    where?: PriceChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceChangeLogs to fetch.
     */
    orderBy?: PriceChangeLogOrderByWithRelationInput | PriceChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceChangeLogs.
     */
    cursor?: PriceChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceChangeLogs.
     */
    distinct?: PriceChangeLogScalarFieldEnum | PriceChangeLogScalarFieldEnum[]
  }

  /**
   * PriceChangeLog findMany
   */
  export type PriceChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which PriceChangeLogs to fetch.
     */
    where?: PriceChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceChangeLogs to fetch.
     */
    orderBy?: PriceChangeLogOrderByWithRelationInput | PriceChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceChangeLogs.
     */
    cursor?: PriceChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceChangeLogs.
     */
    skip?: number
    distinct?: PriceChangeLogScalarFieldEnum | PriceChangeLogScalarFieldEnum[]
  }

  /**
   * PriceChangeLog create
   */
  export type PriceChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to create a PriceChangeLog.
     */
    data: XOR<PriceChangeLogCreateInput, PriceChangeLogUncheckedCreateInput>
  }

  /**
   * PriceChangeLog createMany
   */
  export type PriceChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceChangeLogs.
     */
    data: PriceChangeLogCreateManyInput | PriceChangeLogCreateManyInput[]
  }

  /**
   * PriceChangeLog createManyAndReturn
   */
  export type PriceChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceChangeLogs.
     */
    data: PriceChangeLogCreateManyInput | PriceChangeLogCreateManyInput[]
  }

  /**
   * PriceChangeLog update
   */
  export type PriceChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to update a PriceChangeLog.
     */
    data: XOR<PriceChangeLogUpdateInput, PriceChangeLogUncheckedUpdateInput>
    /**
     * Choose, which PriceChangeLog to update.
     */
    where: PriceChangeLogWhereUniqueInput
  }

  /**
   * PriceChangeLog updateMany
   */
  export type PriceChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceChangeLogs.
     */
    data: XOR<PriceChangeLogUpdateManyMutationInput, PriceChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which PriceChangeLogs to update
     */
    where?: PriceChangeLogWhereInput
  }

  /**
   * PriceChangeLog upsert
   */
  export type PriceChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * The filter to search for the PriceChangeLog to update in case it exists.
     */
    where: PriceChangeLogWhereUniqueInput
    /**
     * In case the PriceChangeLog found by the `where` argument doesn't exist, create a new PriceChangeLog with this data.
     */
    create: XOR<PriceChangeLogCreateInput, PriceChangeLogUncheckedCreateInput>
    /**
     * In case the PriceChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceChangeLogUpdateInput, PriceChangeLogUncheckedUpdateInput>
  }

  /**
   * PriceChangeLog delete
   */
  export type PriceChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
    /**
     * Filter which PriceChangeLog to delete.
     */
    where: PriceChangeLogWhereUniqueInput
  }

  /**
   * PriceChangeLog deleteMany
   */
  export type PriceChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceChangeLogs to delete
     */
    where?: PriceChangeLogWhereInput
  }

  /**
   * PriceChangeLog without action
   */
  export type PriceChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceChangeLog
     */
    select?: PriceChangeLogSelect<ExtArgs> | null
  }


  /**
   * Model UsedPartLog
   */

  export type AggregateUsedPartLog = {
    _count: UsedPartLogCountAggregateOutputType | null
    _min: UsedPartLogMinAggregateOutputType | null
    _max: UsedPartLogMaxAggregateOutputType | null
  }

  export type UsedPartLogMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    customerId: string | null
    customerName: string | null
    posMachineId: string | null
    technician: string | null
    closedByUserId: string | null
    closedAt: Date | null
    parts: string | null
    receiptNumber: string | null
    branchId: string | null
  }

  export type UsedPartLogMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    customerId: string | null
    customerName: string | null
    posMachineId: string | null
    technician: string | null
    closedByUserId: string | null
    closedAt: Date | null
    parts: string | null
    receiptNumber: string | null
    branchId: string | null
  }

  export type UsedPartLogCountAggregateOutputType = {
    id: number
    requestId: number
    customerId: number
    customerName: number
    posMachineId: number
    technician: number
    closedByUserId: number
    closedAt: number
    parts: number
    receiptNumber: number
    branchId: number
    _all: number
  }


  export type UsedPartLogMinAggregateInputType = {
    id?: true
    requestId?: true
    customerId?: true
    customerName?: true
    posMachineId?: true
    technician?: true
    closedByUserId?: true
    closedAt?: true
    parts?: true
    receiptNumber?: true
    branchId?: true
  }

  export type UsedPartLogMaxAggregateInputType = {
    id?: true
    requestId?: true
    customerId?: true
    customerName?: true
    posMachineId?: true
    technician?: true
    closedByUserId?: true
    closedAt?: true
    parts?: true
    receiptNumber?: true
    branchId?: true
  }

  export type UsedPartLogCountAggregateInputType = {
    id?: true
    requestId?: true
    customerId?: true
    customerName?: true
    posMachineId?: true
    technician?: true
    closedByUserId?: true
    closedAt?: true
    parts?: true
    receiptNumber?: true
    branchId?: true
    _all?: true
  }

  export type UsedPartLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsedPartLog to aggregate.
     */
    where?: UsedPartLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsedPartLogs to fetch.
     */
    orderBy?: UsedPartLogOrderByWithRelationInput | UsedPartLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsedPartLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsedPartLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsedPartLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsedPartLogs
    **/
    _count?: true | UsedPartLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsedPartLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsedPartLogMaxAggregateInputType
  }

  export type GetUsedPartLogAggregateType<T extends UsedPartLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUsedPartLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsedPartLog[P]>
      : GetScalarType<T[P], AggregateUsedPartLog[P]>
  }




  export type UsedPartLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsedPartLogWhereInput
    orderBy?: UsedPartLogOrderByWithAggregationInput | UsedPartLogOrderByWithAggregationInput[]
    by: UsedPartLogScalarFieldEnum[] | UsedPartLogScalarFieldEnum
    having?: UsedPartLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsedPartLogCountAggregateInputType | true
    _min?: UsedPartLogMinAggregateInputType
    _max?: UsedPartLogMaxAggregateInputType
  }

  export type UsedPartLogGroupByOutputType = {
    id: string
    requestId: string
    customerId: string
    customerName: string | null
    posMachineId: string | null
    technician: string | null
    closedByUserId: string | null
    closedAt: Date
    parts: string
    receiptNumber: string | null
    branchId: string | null
    _count: UsedPartLogCountAggregateOutputType | null
    _min: UsedPartLogMinAggregateOutputType | null
    _max: UsedPartLogMaxAggregateOutputType | null
  }

  type GetUsedPartLogGroupByPayload<T extends UsedPartLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsedPartLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsedPartLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsedPartLogGroupByOutputType[P]>
            : GetScalarType<T[P], UsedPartLogGroupByOutputType[P]>
        }
      >
    >


  export type UsedPartLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    posMachineId?: boolean
    technician?: boolean
    closedByUserId?: boolean
    closedAt?: boolean
    parts?: boolean
    receiptNumber?: boolean
    branchId?: boolean
    branch?: boolean | UsedPartLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["usedPartLog"]>

  export type UsedPartLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    posMachineId?: boolean
    technician?: boolean
    closedByUserId?: boolean
    closedAt?: boolean
    parts?: boolean
    receiptNumber?: boolean
    branchId?: boolean
    branch?: boolean | UsedPartLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["usedPartLog"]>

  export type UsedPartLogSelectScalar = {
    id?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    posMachineId?: boolean
    technician?: boolean
    closedByUserId?: boolean
    closedAt?: boolean
    parts?: boolean
    receiptNumber?: boolean
    branchId?: boolean
  }

  export type UsedPartLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | UsedPartLog$branchArgs<ExtArgs>
  }
  export type UsedPartLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | UsedPartLog$branchArgs<ExtArgs>
  }

  export type $UsedPartLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsedPartLog"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      customerId: string
      customerName: string | null
      posMachineId: string | null
      technician: string | null
      closedByUserId: string | null
      closedAt: Date
      parts: string
      receiptNumber: string | null
      branchId: string | null
    }, ExtArgs["result"]["usedPartLog"]>
    composites: {}
  }

  type UsedPartLogGetPayload<S extends boolean | null | undefined | UsedPartLogDefaultArgs> = $Result.GetResult<Prisma.$UsedPartLogPayload, S>

  type UsedPartLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsedPartLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsedPartLogCountAggregateInputType | true
    }

  export interface UsedPartLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsedPartLog'], meta: { name: 'UsedPartLog' } }
    /**
     * Find zero or one UsedPartLog that matches the filter.
     * @param {UsedPartLogFindUniqueArgs} args - Arguments to find a UsedPartLog
     * @example
     * // Get one UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsedPartLogFindUniqueArgs>(args: SelectSubset<T, UsedPartLogFindUniqueArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsedPartLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsedPartLogFindUniqueOrThrowArgs} args - Arguments to find a UsedPartLog
     * @example
     * // Get one UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsedPartLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UsedPartLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsedPartLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogFindFirstArgs} args - Arguments to find a UsedPartLog
     * @example
     * // Get one UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsedPartLogFindFirstArgs>(args?: SelectSubset<T, UsedPartLogFindFirstArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsedPartLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogFindFirstOrThrowArgs} args - Arguments to find a UsedPartLog
     * @example
     * // Get one UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsedPartLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UsedPartLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsedPartLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsedPartLogs
     * const usedPartLogs = await prisma.usedPartLog.findMany()
     * 
     * // Get first 10 UsedPartLogs
     * const usedPartLogs = await prisma.usedPartLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usedPartLogWithIdOnly = await prisma.usedPartLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsedPartLogFindManyArgs>(args?: SelectSubset<T, UsedPartLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsedPartLog.
     * @param {UsedPartLogCreateArgs} args - Arguments to create a UsedPartLog.
     * @example
     * // Create one UsedPartLog
     * const UsedPartLog = await prisma.usedPartLog.create({
     *   data: {
     *     // ... data to create a UsedPartLog
     *   }
     * })
     * 
     */
    create<T extends UsedPartLogCreateArgs>(args: SelectSubset<T, UsedPartLogCreateArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsedPartLogs.
     * @param {UsedPartLogCreateManyArgs} args - Arguments to create many UsedPartLogs.
     * @example
     * // Create many UsedPartLogs
     * const usedPartLog = await prisma.usedPartLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsedPartLogCreateManyArgs>(args?: SelectSubset<T, UsedPartLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsedPartLogs and returns the data saved in the database.
     * @param {UsedPartLogCreateManyAndReturnArgs} args - Arguments to create many UsedPartLogs.
     * @example
     * // Create many UsedPartLogs
     * const usedPartLog = await prisma.usedPartLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsedPartLogs and only return the `id`
     * const usedPartLogWithIdOnly = await prisma.usedPartLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsedPartLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UsedPartLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsedPartLog.
     * @param {UsedPartLogDeleteArgs} args - Arguments to delete one UsedPartLog.
     * @example
     * // Delete one UsedPartLog
     * const UsedPartLog = await prisma.usedPartLog.delete({
     *   where: {
     *     // ... filter to delete one UsedPartLog
     *   }
     * })
     * 
     */
    delete<T extends UsedPartLogDeleteArgs>(args: SelectSubset<T, UsedPartLogDeleteArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsedPartLog.
     * @param {UsedPartLogUpdateArgs} args - Arguments to update one UsedPartLog.
     * @example
     * // Update one UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsedPartLogUpdateArgs>(args: SelectSubset<T, UsedPartLogUpdateArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsedPartLogs.
     * @param {UsedPartLogDeleteManyArgs} args - Arguments to filter UsedPartLogs to delete.
     * @example
     * // Delete a few UsedPartLogs
     * const { count } = await prisma.usedPartLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsedPartLogDeleteManyArgs>(args?: SelectSubset<T, UsedPartLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsedPartLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsedPartLogs
     * const usedPartLog = await prisma.usedPartLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsedPartLogUpdateManyArgs>(args: SelectSubset<T, UsedPartLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsedPartLog.
     * @param {UsedPartLogUpsertArgs} args - Arguments to update or create a UsedPartLog.
     * @example
     * // Update or create a UsedPartLog
     * const usedPartLog = await prisma.usedPartLog.upsert({
     *   create: {
     *     // ... data to create a UsedPartLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsedPartLog we want to update
     *   }
     * })
     */
    upsert<T extends UsedPartLogUpsertArgs>(args: SelectSubset<T, UsedPartLogUpsertArgs<ExtArgs>>): Prisma__UsedPartLogClient<$Result.GetResult<Prisma.$UsedPartLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsedPartLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogCountArgs} args - Arguments to filter UsedPartLogs to count.
     * @example
     * // Count the number of UsedPartLogs
     * const count = await prisma.usedPartLog.count({
     *   where: {
     *     // ... the filter for the UsedPartLogs we want to count
     *   }
     * })
    **/
    count<T extends UsedPartLogCountArgs>(
      args?: Subset<T, UsedPartLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsedPartLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsedPartLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsedPartLogAggregateArgs>(args: Subset<T, UsedPartLogAggregateArgs>): Prisma.PrismaPromise<GetUsedPartLogAggregateType<T>>

    /**
     * Group by UsedPartLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsedPartLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsedPartLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsedPartLogGroupByArgs['orderBy'] }
        : { orderBy?: UsedPartLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsedPartLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsedPartLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsedPartLog model
   */
  readonly fields: UsedPartLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsedPartLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsedPartLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends UsedPartLog$branchArgs<ExtArgs> = {}>(args?: Subset<T, UsedPartLog$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsedPartLog model
   */ 
  interface UsedPartLogFieldRefs {
    readonly id: FieldRef<"UsedPartLog", 'String'>
    readonly requestId: FieldRef<"UsedPartLog", 'String'>
    readonly customerId: FieldRef<"UsedPartLog", 'String'>
    readonly customerName: FieldRef<"UsedPartLog", 'String'>
    readonly posMachineId: FieldRef<"UsedPartLog", 'String'>
    readonly technician: FieldRef<"UsedPartLog", 'String'>
    readonly closedByUserId: FieldRef<"UsedPartLog", 'String'>
    readonly closedAt: FieldRef<"UsedPartLog", 'DateTime'>
    readonly parts: FieldRef<"UsedPartLog", 'String'>
    readonly receiptNumber: FieldRef<"UsedPartLog", 'String'>
    readonly branchId: FieldRef<"UsedPartLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsedPartLog findUnique
   */
  export type UsedPartLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter, which UsedPartLog to fetch.
     */
    where: UsedPartLogWhereUniqueInput
  }

  /**
   * UsedPartLog findUniqueOrThrow
   */
  export type UsedPartLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter, which UsedPartLog to fetch.
     */
    where: UsedPartLogWhereUniqueInput
  }

  /**
   * UsedPartLog findFirst
   */
  export type UsedPartLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter, which UsedPartLog to fetch.
     */
    where?: UsedPartLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsedPartLogs to fetch.
     */
    orderBy?: UsedPartLogOrderByWithRelationInput | UsedPartLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsedPartLogs.
     */
    cursor?: UsedPartLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsedPartLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsedPartLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsedPartLogs.
     */
    distinct?: UsedPartLogScalarFieldEnum | UsedPartLogScalarFieldEnum[]
  }

  /**
   * UsedPartLog findFirstOrThrow
   */
  export type UsedPartLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter, which UsedPartLog to fetch.
     */
    where?: UsedPartLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsedPartLogs to fetch.
     */
    orderBy?: UsedPartLogOrderByWithRelationInput | UsedPartLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsedPartLogs.
     */
    cursor?: UsedPartLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsedPartLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsedPartLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsedPartLogs.
     */
    distinct?: UsedPartLogScalarFieldEnum | UsedPartLogScalarFieldEnum[]
  }

  /**
   * UsedPartLog findMany
   */
  export type UsedPartLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter, which UsedPartLogs to fetch.
     */
    where?: UsedPartLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsedPartLogs to fetch.
     */
    orderBy?: UsedPartLogOrderByWithRelationInput | UsedPartLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsedPartLogs.
     */
    cursor?: UsedPartLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsedPartLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsedPartLogs.
     */
    skip?: number
    distinct?: UsedPartLogScalarFieldEnum | UsedPartLogScalarFieldEnum[]
  }

  /**
   * UsedPartLog create
   */
  export type UsedPartLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UsedPartLog.
     */
    data: XOR<UsedPartLogCreateInput, UsedPartLogUncheckedCreateInput>
  }

  /**
   * UsedPartLog createMany
   */
  export type UsedPartLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsedPartLogs.
     */
    data: UsedPartLogCreateManyInput | UsedPartLogCreateManyInput[]
  }

  /**
   * UsedPartLog createManyAndReturn
   */
  export type UsedPartLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsedPartLogs.
     */
    data: UsedPartLogCreateManyInput | UsedPartLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsedPartLog update
   */
  export type UsedPartLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UsedPartLog.
     */
    data: XOR<UsedPartLogUpdateInput, UsedPartLogUncheckedUpdateInput>
    /**
     * Choose, which UsedPartLog to update.
     */
    where: UsedPartLogWhereUniqueInput
  }

  /**
   * UsedPartLog updateMany
   */
  export type UsedPartLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsedPartLogs.
     */
    data: XOR<UsedPartLogUpdateManyMutationInput, UsedPartLogUncheckedUpdateManyInput>
    /**
     * Filter which UsedPartLogs to update
     */
    where?: UsedPartLogWhereInput
  }

  /**
   * UsedPartLog upsert
   */
  export type UsedPartLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UsedPartLog to update in case it exists.
     */
    where: UsedPartLogWhereUniqueInput
    /**
     * In case the UsedPartLog found by the `where` argument doesn't exist, create a new UsedPartLog with this data.
     */
    create: XOR<UsedPartLogCreateInput, UsedPartLogUncheckedCreateInput>
    /**
     * In case the UsedPartLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsedPartLogUpdateInput, UsedPartLogUncheckedUpdateInput>
  }

  /**
   * UsedPartLog delete
   */
  export type UsedPartLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
    /**
     * Filter which UsedPartLog to delete.
     */
    where: UsedPartLogWhereUniqueInput
  }

  /**
   * UsedPartLog deleteMany
   */
  export type UsedPartLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsedPartLogs to delete
     */
    where?: UsedPartLogWhereInput
  }

  /**
   * UsedPartLog.branch
   */
  export type UsedPartLog$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * UsedPartLog without action
   */
  export type UsedPartLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsedPartLog
     */
    select?: UsedPartLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsedPartLogInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    partId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    requestId: string | null
    userId: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    partId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    requestId: string | null
    userId: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    partId: number
    type: number
    quantity: number
    reason: number
    requestId: number
    userId: number
    performedBy: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    partId?: true
    type?: true
    quantity?: true
    reason?: true
    requestId?: true
    userId?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    partId?: true
    type?: true
    quantity?: true
    reason?: true
    requestId?: true
    userId?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    partId?: true
    type?: true
    quantity?: true
    reason?: true
    requestId?: true
    userId?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    partId: string
    type: string
    quantity: number
    reason: string | null
    requestId: string | null
    userId: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    requestId?: boolean
    userId?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | StockMovement$branchArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    requestId?: boolean
    userId?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | StockMovement$branchArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    partId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    requestId?: boolean
    userId?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | StockMovement$branchArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | StockMovement$branchArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partId: string
      type: string
      quantity: number
      reason: string | null
      requestId: string | null
      userId: string | null
      performedBy: string | null
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends StockMovement$branchArgs<ExtArgs> = {}>(args?: Subset<T, StockMovement$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly partId: FieldRef<"StockMovement", 'String'>
    readonly type: FieldRef<"StockMovement", 'String'>
    readonly quantity: FieldRef<"StockMovement", 'Int'>
    readonly reason: FieldRef<"StockMovement", 'String'>
    readonly requestId: FieldRef<"StockMovement", 'String'>
    readonly userId: FieldRef<"StockMovement", 'String'>
    readonly performedBy: FieldRef<"StockMovement", 'String'>
    readonly branchId: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement.branch
   */
  export type StockMovement$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    customerName: string | null
    requestId: string | null
    amount: number | null
    type: string | null
    reason: string | null
    paymentPlace: string | null
    paymentMethod: string | null
    receiptNumber: string | null
    notes: string | null
    userId: string | null
    userName: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    customerName: string | null
    requestId: string | null
    amount: number | null
    type: string | null
    reason: string | null
    paymentPlace: string | null
    paymentMethod: string | null
    receiptNumber: string | null
    notes: string | null
    userId: string | null
    userName: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    customerId: number
    customerName: number
    requestId: number
    amount: number
    type: number
    reason: number
    paymentPlace: number
    paymentMethod: number
    receiptNumber: number
    notes: number
    userId: number
    userName: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    customerId?: true
    customerName?: true
    requestId?: true
    amount?: true
    type?: true
    reason?: true
    paymentPlace?: true
    paymentMethod?: true
    receiptNumber?: true
    notes?: true
    userId?: true
    userName?: true
    branchId?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    customerId?: true
    customerName?: true
    requestId?: true
    amount?: true
    type?: true
    reason?: true
    paymentPlace?: true
    paymentMethod?: true
    receiptNumber?: true
    notes?: true
    userId?: true
    userName?: true
    branchId?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    customerId?: true
    customerName?: true
    requestId?: true
    amount?: true
    type?: true
    reason?: true
    paymentPlace?: true
    paymentMethod?: true
    receiptNumber?: true
    notes?: true
    userId?: true
    userName?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    customerId: string | null
    customerName: string | null
    requestId: string | null
    amount: number
    type: string | null
    reason: string | null
    paymentPlace: string | null
    paymentMethod: string | null
    receiptNumber: string | null
    notes: string | null
    userId: string | null
    userName: string | null
    branchId: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    amount?: boolean
    type?: boolean
    reason?: boolean
    paymentPlace?: boolean
    paymentMethod?: boolean
    receiptNumber?: boolean
    notes?: boolean
    userId?: boolean
    userName?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | Payment$branchArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    amount?: boolean
    type?: boolean
    reason?: boolean
    paymentPlace?: boolean
    paymentMethod?: boolean
    receiptNumber?: boolean
    notes?: boolean
    userId?: boolean
    userName?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | Payment$branchArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    amount?: boolean
    type?: boolean
    reason?: boolean
    paymentPlace?: boolean
    paymentMethod?: boolean
    receiptNumber?: boolean
    notes?: boolean
    userId?: boolean
    userName?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Payment$branchArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Payment$branchArgs<ExtArgs>
    customer?: boolean | Payment$customerArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string | null
      customerName: string | null
      requestId: string | null
      amount: number
      type: string | null
      reason: string | null
      paymentPlace: string | null
      paymentMethod: string | null
      receiptNumber: string | null
      notes: string | null
      userId: string | null
      userName: string | null
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Payment$branchArgs<ExtArgs> = {}>(args?: Subset<T, Payment$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends Payment$customerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly customerName: FieldRef<"Payment", 'String'>
    readonly requestId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly type: FieldRef<"Payment", 'String'>
    readonly reason: FieldRef<"Payment", 'String'>
    readonly paymentPlace: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly receiptNumber: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly userName: FieldRef<"Payment", 'String'>
    readonly branchId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.branch
   */
  export type Payment$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Payment.customer
   */
  export type Payment$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model MachineMovementLog
   */

  export type AggregateMachineMovementLog = {
    _count: MachineMovementLogCountAggregateOutputType | null
    _min: MachineMovementLogMinAggregateOutputType | null
    _max: MachineMovementLogMaxAggregateOutputType | null
  }

  export type MachineMovementLogMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    serialNumber: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type MachineMovementLogMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    serialNumber: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type MachineMovementLogCountAggregateOutputType = {
    id: number
    machineId: number
    serialNumber: number
    action: number
    details: number
    performedBy: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type MachineMovementLogMinAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type MachineMovementLogMaxAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type MachineMovementLogCountAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type MachineMovementLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineMovementLog to aggregate.
     */
    where?: MachineMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMovementLogs to fetch.
     */
    orderBy?: MachineMovementLogOrderByWithRelationInput | MachineMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineMovementLogs
    **/
    _count?: true | MachineMovementLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMovementLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMovementLogMaxAggregateInputType
  }

  export type GetMachineMovementLogAggregateType<T extends MachineMovementLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineMovementLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineMovementLog[P]>
      : GetScalarType<T[P], AggregateMachineMovementLog[P]>
  }




  export type MachineMovementLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineMovementLogWhereInput
    orderBy?: MachineMovementLogOrderByWithAggregationInput | MachineMovementLogOrderByWithAggregationInput[]
    by: MachineMovementLogScalarFieldEnum[] | MachineMovementLogScalarFieldEnum
    having?: MachineMovementLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineMovementLogCountAggregateInputType | true
    _min?: MachineMovementLogMinAggregateInputType
    _max?: MachineMovementLogMaxAggregateInputType
  }

  export type MachineMovementLogGroupByOutputType = {
    id: string
    machineId: string | null
    serialNumber: string
    action: string
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date
    _count: MachineMovementLogCountAggregateOutputType | null
    _min: MachineMovementLogMinAggregateOutputType | null
    _max: MachineMovementLogMaxAggregateOutputType | null
  }

  type GetMachineMovementLogGroupByPayload<T extends MachineMovementLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineMovementLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineMovementLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineMovementLogGroupByOutputType[P]>
            : GetScalarType<T[P], MachineMovementLogGroupByOutputType[P]>
        }
      >
    >


  export type MachineMovementLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | MachineMovementLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["machineMovementLog"]>

  export type MachineMovementLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | MachineMovementLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["machineMovementLog"]>

  export type MachineMovementLogSelectScalar = {
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type MachineMovementLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | MachineMovementLog$branchArgs<ExtArgs>
  }
  export type MachineMovementLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | MachineMovementLog$branchArgs<ExtArgs>
  }

  export type $MachineMovementLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineMovementLog"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string | null
      serialNumber: string
      action: string
      details: string | null
      performedBy: string | null
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["machineMovementLog"]>
    composites: {}
  }

  type MachineMovementLogGetPayload<S extends boolean | null | undefined | MachineMovementLogDefaultArgs> = $Result.GetResult<Prisma.$MachineMovementLogPayload, S>

  type MachineMovementLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MachineMovementLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MachineMovementLogCountAggregateInputType | true
    }

  export interface MachineMovementLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineMovementLog'], meta: { name: 'MachineMovementLog' } }
    /**
     * Find zero or one MachineMovementLog that matches the filter.
     * @param {MachineMovementLogFindUniqueArgs} args - Arguments to find a MachineMovementLog
     * @example
     * // Get one MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineMovementLogFindUniqueArgs>(args: SelectSubset<T, MachineMovementLogFindUniqueArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MachineMovementLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MachineMovementLogFindUniqueOrThrowArgs} args - Arguments to find a MachineMovementLog
     * @example
     * // Get one MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineMovementLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineMovementLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MachineMovementLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogFindFirstArgs} args - Arguments to find a MachineMovementLog
     * @example
     * // Get one MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineMovementLogFindFirstArgs>(args?: SelectSubset<T, MachineMovementLogFindFirstArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MachineMovementLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogFindFirstOrThrowArgs} args - Arguments to find a MachineMovementLog
     * @example
     * // Get one MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineMovementLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineMovementLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MachineMovementLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineMovementLogs
     * const machineMovementLogs = await prisma.machineMovementLog.findMany()
     * 
     * // Get first 10 MachineMovementLogs
     * const machineMovementLogs = await prisma.machineMovementLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineMovementLogWithIdOnly = await prisma.machineMovementLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineMovementLogFindManyArgs>(args?: SelectSubset<T, MachineMovementLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MachineMovementLog.
     * @param {MachineMovementLogCreateArgs} args - Arguments to create a MachineMovementLog.
     * @example
     * // Create one MachineMovementLog
     * const MachineMovementLog = await prisma.machineMovementLog.create({
     *   data: {
     *     // ... data to create a MachineMovementLog
     *   }
     * })
     * 
     */
    create<T extends MachineMovementLogCreateArgs>(args: SelectSubset<T, MachineMovementLogCreateArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MachineMovementLogs.
     * @param {MachineMovementLogCreateManyArgs} args - Arguments to create many MachineMovementLogs.
     * @example
     * // Create many MachineMovementLogs
     * const machineMovementLog = await prisma.machineMovementLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineMovementLogCreateManyArgs>(args?: SelectSubset<T, MachineMovementLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineMovementLogs and returns the data saved in the database.
     * @param {MachineMovementLogCreateManyAndReturnArgs} args - Arguments to create many MachineMovementLogs.
     * @example
     * // Create many MachineMovementLogs
     * const machineMovementLog = await prisma.machineMovementLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineMovementLogs and only return the `id`
     * const machineMovementLogWithIdOnly = await prisma.machineMovementLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineMovementLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineMovementLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MachineMovementLog.
     * @param {MachineMovementLogDeleteArgs} args - Arguments to delete one MachineMovementLog.
     * @example
     * // Delete one MachineMovementLog
     * const MachineMovementLog = await prisma.machineMovementLog.delete({
     *   where: {
     *     // ... filter to delete one MachineMovementLog
     *   }
     * })
     * 
     */
    delete<T extends MachineMovementLogDeleteArgs>(args: SelectSubset<T, MachineMovementLogDeleteArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MachineMovementLog.
     * @param {MachineMovementLogUpdateArgs} args - Arguments to update one MachineMovementLog.
     * @example
     * // Update one MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineMovementLogUpdateArgs>(args: SelectSubset<T, MachineMovementLogUpdateArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MachineMovementLogs.
     * @param {MachineMovementLogDeleteManyArgs} args - Arguments to filter MachineMovementLogs to delete.
     * @example
     * // Delete a few MachineMovementLogs
     * const { count } = await prisma.machineMovementLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineMovementLogDeleteManyArgs>(args?: SelectSubset<T, MachineMovementLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineMovementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineMovementLogs
     * const machineMovementLog = await prisma.machineMovementLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineMovementLogUpdateManyArgs>(args: SelectSubset<T, MachineMovementLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MachineMovementLog.
     * @param {MachineMovementLogUpsertArgs} args - Arguments to update or create a MachineMovementLog.
     * @example
     * // Update or create a MachineMovementLog
     * const machineMovementLog = await prisma.machineMovementLog.upsert({
     *   create: {
     *     // ... data to create a MachineMovementLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineMovementLog we want to update
     *   }
     * })
     */
    upsert<T extends MachineMovementLogUpsertArgs>(args: SelectSubset<T, MachineMovementLogUpsertArgs<ExtArgs>>): Prisma__MachineMovementLogClient<$Result.GetResult<Prisma.$MachineMovementLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MachineMovementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogCountArgs} args - Arguments to filter MachineMovementLogs to count.
     * @example
     * // Count the number of MachineMovementLogs
     * const count = await prisma.machineMovementLog.count({
     *   where: {
     *     // ... the filter for the MachineMovementLogs we want to count
     *   }
     * })
    **/
    count<T extends MachineMovementLogCountArgs>(
      args?: Subset<T, MachineMovementLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineMovementLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineMovementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineMovementLogAggregateArgs>(args: Subset<T, MachineMovementLogAggregateArgs>): Prisma.PrismaPromise<GetMachineMovementLogAggregateType<T>>

    /**
     * Group by MachineMovementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMovementLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineMovementLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineMovementLogGroupByArgs['orderBy'] }
        : { orderBy?: MachineMovementLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineMovementLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineMovementLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineMovementLog model
   */
  readonly fields: MachineMovementLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineMovementLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineMovementLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends MachineMovementLog$branchArgs<ExtArgs> = {}>(args?: Subset<T, MachineMovementLog$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineMovementLog model
   */ 
  interface MachineMovementLogFieldRefs {
    readonly id: FieldRef<"MachineMovementLog", 'String'>
    readonly machineId: FieldRef<"MachineMovementLog", 'String'>
    readonly serialNumber: FieldRef<"MachineMovementLog", 'String'>
    readonly action: FieldRef<"MachineMovementLog", 'String'>
    readonly details: FieldRef<"MachineMovementLog", 'String'>
    readonly performedBy: FieldRef<"MachineMovementLog", 'String'>
    readonly branchId: FieldRef<"MachineMovementLog", 'String'>
    readonly createdAt: FieldRef<"MachineMovementLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MachineMovementLog findUnique
   */
  export type MachineMovementLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which MachineMovementLog to fetch.
     */
    where: MachineMovementLogWhereUniqueInput
  }

  /**
   * MachineMovementLog findUniqueOrThrow
   */
  export type MachineMovementLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which MachineMovementLog to fetch.
     */
    where: MachineMovementLogWhereUniqueInput
  }

  /**
   * MachineMovementLog findFirst
   */
  export type MachineMovementLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which MachineMovementLog to fetch.
     */
    where?: MachineMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMovementLogs to fetch.
     */
    orderBy?: MachineMovementLogOrderByWithRelationInput | MachineMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineMovementLogs.
     */
    cursor?: MachineMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineMovementLogs.
     */
    distinct?: MachineMovementLogScalarFieldEnum | MachineMovementLogScalarFieldEnum[]
  }

  /**
   * MachineMovementLog findFirstOrThrow
   */
  export type MachineMovementLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which MachineMovementLog to fetch.
     */
    where?: MachineMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMovementLogs to fetch.
     */
    orderBy?: MachineMovementLogOrderByWithRelationInput | MachineMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineMovementLogs.
     */
    cursor?: MachineMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineMovementLogs.
     */
    distinct?: MachineMovementLogScalarFieldEnum | MachineMovementLogScalarFieldEnum[]
  }

  /**
   * MachineMovementLog findMany
   */
  export type MachineMovementLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which MachineMovementLogs to fetch.
     */
    where?: MachineMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMovementLogs to fetch.
     */
    orderBy?: MachineMovementLogOrderByWithRelationInput | MachineMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineMovementLogs.
     */
    cursor?: MachineMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMovementLogs.
     */
    skip?: number
    distinct?: MachineMovementLogScalarFieldEnum | MachineMovementLogScalarFieldEnum[]
  }

  /**
   * MachineMovementLog create
   */
  export type MachineMovementLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MachineMovementLog.
     */
    data: XOR<MachineMovementLogCreateInput, MachineMovementLogUncheckedCreateInput>
  }

  /**
   * MachineMovementLog createMany
   */
  export type MachineMovementLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineMovementLogs.
     */
    data: MachineMovementLogCreateManyInput | MachineMovementLogCreateManyInput[]
  }

  /**
   * MachineMovementLog createManyAndReturn
   */
  export type MachineMovementLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MachineMovementLogs.
     */
    data: MachineMovementLogCreateManyInput | MachineMovementLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineMovementLog update
   */
  export type MachineMovementLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MachineMovementLog.
     */
    data: XOR<MachineMovementLogUpdateInput, MachineMovementLogUncheckedUpdateInput>
    /**
     * Choose, which MachineMovementLog to update.
     */
    where: MachineMovementLogWhereUniqueInput
  }

  /**
   * MachineMovementLog updateMany
   */
  export type MachineMovementLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineMovementLogs.
     */
    data: XOR<MachineMovementLogUpdateManyMutationInput, MachineMovementLogUncheckedUpdateManyInput>
    /**
     * Filter which MachineMovementLogs to update
     */
    where?: MachineMovementLogWhereInput
  }

  /**
   * MachineMovementLog upsert
   */
  export type MachineMovementLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MachineMovementLog to update in case it exists.
     */
    where: MachineMovementLogWhereUniqueInput
    /**
     * In case the MachineMovementLog found by the `where` argument doesn't exist, create a new MachineMovementLog with this data.
     */
    create: XOR<MachineMovementLogCreateInput, MachineMovementLogUncheckedCreateInput>
    /**
     * In case the MachineMovementLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineMovementLogUpdateInput, MachineMovementLogUncheckedUpdateInput>
  }

  /**
   * MachineMovementLog delete
   */
  export type MachineMovementLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
    /**
     * Filter which MachineMovementLog to delete.
     */
    where: MachineMovementLogWhereUniqueInput
  }

  /**
   * MachineMovementLog deleteMany
   */
  export type MachineMovementLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineMovementLogs to delete
     */
    where?: MachineMovementLogWhereInput
  }

  /**
   * MachineMovementLog.branch
   */
  export type MachineMovementLog$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MachineMovementLog without action
   */
  export type MachineMovementLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMovementLog
     */
    select?: MachineMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMovementLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    userId: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    userId: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    details: number
    performedBy: number
    userId: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type SystemLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    details?: true
    performedBy?: true
    userId?: true
    branchId?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    details?: true
    performedBy?: true
    userId?: true
    branchId?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    details?: true
    performedBy?: true
    userId?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: string
    details: string | null
    performedBy: string | null
    userId: string | null
    branchId: string | null
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | SystemLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | SystemLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    userId?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type SystemLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | SystemLog$branchArgs<ExtArgs>
  }
  export type SystemLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | SystemLog$branchArgs<ExtArgs>
  }

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: string
      details: string | null
      performedBy: string | null
      userId: string | null
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemLogs and returns the data saved in the database.
     * @param {SystemLogCreateManyAndReturnArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemLogs and only return the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends SystemLog$branchArgs<ExtArgs> = {}>(args?: Subset<T, SystemLog$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */ 
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly entityType: FieldRef<"SystemLog", 'String'>
    readonly entityId: FieldRef<"SystemLog", 'String'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly details: FieldRef<"SystemLog", 'String'>
    readonly performedBy: FieldRef<"SystemLog", 'String'>
    readonly userId: FieldRef<"SystemLog", 'String'>
    readonly branchId: FieldRef<"SystemLog", 'String'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
  }

  /**
   * SystemLog createManyAndReturn
   */
  export type SystemLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog.branch
   */
  export type SystemLog$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
  }


  /**
   * Model Installment
   */

  export type AggregateInstallment = {
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  export type InstallmentAvgAggregateOutputType = {
    amount: number | null
    paidAmount: number | null
  }

  export type InstallmentSumAggregateOutputType = {
    amount: number | null
    paidAmount: number | null
  }

  export type InstallmentMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    dueDate: Date | null
    amount: number | null
    isPaid: boolean | null
    paidAt: Date | null
    description: string | null
    paidAmount: number | null
    paymentPlace: string | null
    receiptNumber: string | null
    branchId: string | null
  }

  export type InstallmentMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    dueDate: Date | null
    amount: number | null
    isPaid: boolean | null
    paidAt: Date | null
    description: string | null
    paidAmount: number | null
    paymentPlace: string | null
    receiptNumber: string | null
    branchId: string | null
  }

  export type InstallmentCountAggregateOutputType = {
    id: number
    saleId: number
    dueDate: number
    amount: number
    isPaid: number
    paidAt: number
    description: number
    paidAmount: number
    paymentPlace: number
    receiptNumber: number
    branchId: number
    _all: number
  }


  export type InstallmentAvgAggregateInputType = {
    amount?: true
    paidAmount?: true
  }

  export type InstallmentSumAggregateInputType = {
    amount?: true
    paidAmount?: true
  }

  export type InstallmentMinAggregateInputType = {
    id?: true
    saleId?: true
    dueDate?: true
    amount?: true
    isPaid?: true
    paidAt?: true
    description?: true
    paidAmount?: true
    paymentPlace?: true
    receiptNumber?: true
    branchId?: true
  }

  export type InstallmentMaxAggregateInputType = {
    id?: true
    saleId?: true
    dueDate?: true
    amount?: true
    isPaid?: true
    paidAt?: true
    description?: true
    paidAmount?: true
    paymentPlace?: true
    receiptNumber?: true
    branchId?: true
  }

  export type InstallmentCountAggregateInputType = {
    id?: true
    saleId?: true
    dueDate?: true
    amount?: true
    isPaid?: true
    paidAt?: true
    description?: true
    paidAmount?: true
    paymentPlace?: true
    receiptNumber?: true
    branchId?: true
    _all?: true
  }

  export type InstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installment to aggregate.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installments
    **/
    _count?: true | InstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentMaxAggregateInputType
  }

  export type GetInstallmentAggregateType<T extends InstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallment[P]>
      : GetScalarType<T[P], AggregateInstallment[P]>
  }




  export type InstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithAggregationInput | InstallmentOrderByWithAggregationInput[]
    by: InstallmentScalarFieldEnum[] | InstallmentScalarFieldEnum
    having?: InstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentCountAggregateInputType | true
    _avg?: InstallmentAvgAggregateInputType
    _sum?: InstallmentSumAggregateInputType
    _min?: InstallmentMinAggregateInputType
    _max?: InstallmentMaxAggregateInputType
  }

  export type InstallmentGroupByOutputType = {
    id: string
    saleId: string
    dueDate: Date
    amount: number
    isPaid: boolean
    paidAt: Date | null
    description: string | null
    paidAmount: number | null
    paymentPlace: string | null
    receiptNumber: string | null
    branchId: string | null
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  type GetInstallmentGroupByPayload<T extends InstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    dueDate?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
    description?: boolean
    paidAmount?: boolean
    paymentPlace?: boolean
    receiptNumber?: boolean
    branchId?: boolean
    sale?: boolean | MachineSaleDefaultArgs<ExtArgs>
    branch?: boolean | Installment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    dueDate?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
    description?: boolean
    paidAmount?: boolean
    paymentPlace?: boolean
    receiptNumber?: boolean
    branchId?: boolean
    sale?: boolean | MachineSaleDefaultArgs<ExtArgs>
    branch?: boolean | Installment$branchArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectScalar = {
    id?: boolean
    saleId?: boolean
    dueDate?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
    description?: boolean
    paidAmount?: boolean
    paymentPlace?: boolean
    receiptNumber?: boolean
    branchId?: boolean
  }

  export type InstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | MachineSaleDefaultArgs<ExtArgs>
    branch?: boolean | Installment$branchArgs<ExtArgs>
  }
  export type InstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | MachineSaleDefaultArgs<ExtArgs>
    branch?: boolean | Installment$branchArgs<ExtArgs>
  }

  export type $InstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Installment"
    objects: {
      sale: Prisma.$MachineSalePayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      dueDate: Date
      amount: number
      isPaid: boolean
      paidAt: Date | null
      description: string | null
      paidAmount: number | null
      paymentPlace: string | null
      receiptNumber: string | null
      branchId: string | null
    }, ExtArgs["result"]["installment"]>
    composites: {}
  }

  type InstallmentGetPayload<S extends boolean | null | undefined | InstallmentDefaultArgs> = $Result.GetResult<Prisma.$InstallmentPayload, S>

  type InstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstallmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstallmentCountAggregateInputType | true
    }

  export interface InstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Installment'], meta: { name: 'Installment' } }
    /**
     * Find zero or one Installment that matches the filter.
     * @param {InstallmentFindUniqueArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallmentFindUniqueArgs>(args: SelectSubset<T, InstallmentFindUniqueArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Installment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstallmentFindUniqueOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Installment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallmentFindFirstArgs>(args?: SelectSubset<T, InstallmentFindFirstArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Installment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installments
     * const installments = await prisma.installment.findMany()
     * 
     * // Get first 10 Installments
     * const installments = await prisma.installment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentWithIdOnly = await prisma.installment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallmentFindManyArgs>(args?: SelectSubset<T, InstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Installment.
     * @param {InstallmentCreateArgs} args - Arguments to create a Installment.
     * @example
     * // Create one Installment
     * const Installment = await prisma.installment.create({
     *   data: {
     *     // ... data to create a Installment
     *   }
     * })
     * 
     */
    create<T extends InstallmentCreateArgs>(args: SelectSubset<T, InstallmentCreateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Installments.
     * @param {InstallmentCreateManyArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallmentCreateManyArgs>(args?: SelectSubset<T, InstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Installments and returns the data saved in the database.
     * @param {InstallmentCreateManyAndReturnArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Installment.
     * @param {InstallmentDeleteArgs} args - Arguments to delete one Installment.
     * @example
     * // Delete one Installment
     * const Installment = await prisma.installment.delete({
     *   where: {
     *     // ... filter to delete one Installment
     *   }
     * })
     * 
     */
    delete<T extends InstallmentDeleteArgs>(args: SelectSubset<T, InstallmentDeleteArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Installment.
     * @param {InstallmentUpdateArgs} args - Arguments to update one Installment.
     * @example
     * // Update one Installment
     * const installment = await prisma.installment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallmentUpdateArgs>(args: SelectSubset<T, InstallmentUpdateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Installments.
     * @param {InstallmentDeleteManyArgs} args - Arguments to filter Installments to delete.
     * @example
     * // Delete a few Installments
     * const { count } = await prisma.installment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallmentDeleteManyArgs>(args?: SelectSubset<T, InstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallmentUpdateManyArgs>(args: SelectSubset<T, InstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Installment.
     * @param {InstallmentUpsertArgs} args - Arguments to update or create a Installment.
     * @example
     * // Update or create a Installment
     * const installment = await prisma.installment.upsert({
     *   create: {
     *     // ... data to create a Installment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installment we want to update
     *   }
     * })
     */
    upsert<T extends InstallmentUpsertArgs>(args: SelectSubset<T, InstallmentUpsertArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentCountArgs} args - Arguments to filter Installments to count.
     * @example
     * // Count the number of Installments
     * const count = await prisma.installment.count({
     *   where: {
     *     // ... the filter for the Installments we want to count
     *   }
     * })
    **/
    count<T extends InstallmentCountArgs>(
      args?: Subset<T, InstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentAggregateArgs>(args: Subset<T, InstallmentAggregateArgs>): Prisma.PrismaPromise<GetInstallmentAggregateType<T>>

    /**
     * Group by Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Installment model
   */
  readonly fields: InstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends MachineSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineSaleDefaultArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends Installment$branchArgs<ExtArgs> = {}>(args?: Subset<T, Installment$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Installment model
   */ 
  interface InstallmentFieldRefs {
    readonly id: FieldRef<"Installment", 'String'>
    readonly saleId: FieldRef<"Installment", 'String'>
    readonly dueDate: FieldRef<"Installment", 'DateTime'>
    readonly amount: FieldRef<"Installment", 'Float'>
    readonly isPaid: FieldRef<"Installment", 'Boolean'>
    readonly paidAt: FieldRef<"Installment", 'DateTime'>
    readonly description: FieldRef<"Installment", 'String'>
    readonly paidAmount: FieldRef<"Installment", 'Float'>
    readonly paymentPlace: FieldRef<"Installment", 'String'>
    readonly receiptNumber: FieldRef<"Installment", 'String'>
    readonly branchId: FieldRef<"Installment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Installment findUnique
   */
  export type InstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findUniqueOrThrow
   */
  export type InstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findFirst
   */
  export type InstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findFirstOrThrow
   */
  export type InstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findMany
   */
  export type InstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installments to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment create
   */
  export type InstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Installment.
     */
    data: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
  }

  /**
   * Installment createMany
   */
  export type InstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
  }

  /**
   * Installment createManyAndReturn
   */
  export type InstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment update
   */
  export type InstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Installment.
     */
    data: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
    /**
     * Choose, which Installment to update.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment updateMany
   */
  export type InstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
  }

  /**
   * Installment upsert
   */
  export type InstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Installment to update in case it exists.
     */
    where: InstallmentWhereUniqueInput
    /**
     * In case the Installment found by the `where` argument doesn't exist, create a new Installment with this data.
     */
    create: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
    /**
     * In case the Installment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
  }

  /**
   * Installment delete
   */
  export type InstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter which Installment to delete.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment deleteMany
   */
  export type InstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installments to delete
     */
    where?: InstallmentWhereInput
  }

  /**
   * Installment.branch
   */
  export type Installment$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Installment without action
   */
  export type InstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
  }


  /**
   * Model MachineSale
   */

  export type AggregateMachineSale = {
    _count: MachineSaleCountAggregateOutputType | null
    _avg: MachineSaleAvgAggregateOutputType | null
    _sum: MachineSaleSumAggregateOutputType | null
    _min: MachineSaleMinAggregateOutputType | null
    _max: MachineSaleMaxAggregateOutputType | null
  }

  export type MachineSaleAvgAggregateOutputType = {
    totalPrice: number | null
    paidAmount: number | null
  }

  export type MachineSaleSumAggregateOutputType = {
    totalPrice: number | null
    paidAmount: number | null
  }

  export type MachineSaleMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    customerId: string | null
    saleDate: Date | null
    type: string | null
    totalPrice: number | null
    paidAmount: number | null
    status: string | null
    notes: string | null
    branchId: string | null
  }

  export type MachineSaleMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    customerId: string | null
    saleDate: Date | null
    type: string | null
    totalPrice: number | null
    paidAmount: number | null
    status: string | null
    notes: string | null
    branchId: string | null
  }

  export type MachineSaleCountAggregateOutputType = {
    id: number
    serialNumber: number
    customerId: number
    saleDate: number
    type: number
    totalPrice: number
    paidAmount: number
    status: number
    notes: number
    branchId: number
    _all: number
  }


  export type MachineSaleAvgAggregateInputType = {
    totalPrice?: true
    paidAmount?: true
  }

  export type MachineSaleSumAggregateInputType = {
    totalPrice?: true
    paidAmount?: true
  }

  export type MachineSaleMinAggregateInputType = {
    id?: true
    serialNumber?: true
    customerId?: true
    saleDate?: true
    type?: true
    totalPrice?: true
    paidAmount?: true
    status?: true
    notes?: true
    branchId?: true
  }

  export type MachineSaleMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    customerId?: true
    saleDate?: true
    type?: true
    totalPrice?: true
    paidAmount?: true
    status?: true
    notes?: true
    branchId?: true
  }

  export type MachineSaleCountAggregateInputType = {
    id?: true
    serialNumber?: true
    customerId?: true
    saleDate?: true
    type?: true
    totalPrice?: true
    paidAmount?: true
    status?: true
    notes?: true
    branchId?: true
    _all?: true
  }

  export type MachineSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineSale to aggregate.
     */
    where?: MachineSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSales to fetch.
     */
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineSales
    **/
    _count?: true | MachineSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineSaleMaxAggregateInputType
  }

  export type GetMachineSaleAggregateType<T extends MachineSaleAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineSale[P]>
      : GetScalarType<T[P], AggregateMachineSale[P]>
  }




  export type MachineSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineSaleWhereInput
    orderBy?: MachineSaleOrderByWithAggregationInput | MachineSaleOrderByWithAggregationInput[]
    by: MachineSaleScalarFieldEnum[] | MachineSaleScalarFieldEnum
    having?: MachineSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineSaleCountAggregateInputType | true
    _avg?: MachineSaleAvgAggregateInputType
    _sum?: MachineSaleSumAggregateInputType
    _min?: MachineSaleMinAggregateInputType
    _max?: MachineSaleMaxAggregateInputType
  }

  export type MachineSaleGroupByOutputType = {
    id: string
    serialNumber: string
    customerId: string
    saleDate: Date
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes: string | null
    branchId: string | null
    _count: MachineSaleCountAggregateOutputType | null
    _avg: MachineSaleAvgAggregateOutputType | null
    _sum: MachineSaleSumAggregateOutputType | null
    _min: MachineSaleMinAggregateOutputType | null
    _max: MachineSaleMaxAggregateOutputType | null
  }

  type GetMachineSaleGroupByPayload<T extends MachineSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineSaleGroupByOutputType[P]>
            : GetScalarType<T[P], MachineSaleGroupByOutputType[P]>
        }
      >
    >


  export type MachineSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    customerId?: boolean
    saleDate?: boolean
    type?: boolean
    totalPrice?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
    installments?: boolean | MachineSale$installmentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    branch?: boolean | MachineSale$branchArgs<ExtArgs>
    _count?: boolean | MachineSaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineSale"]>

  export type MachineSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    customerId?: boolean
    saleDate?: boolean
    type?: boolean
    totalPrice?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    branch?: boolean | MachineSale$branchArgs<ExtArgs>
  }, ExtArgs["result"]["machineSale"]>

  export type MachineSaleSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    customerId?: boolean
    saleDate?: boolean
    type?: boolean
    totalPrice?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
  }

  export type MachineSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | MachineSale$installmentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    branch?: boolean | MachineSale$branchArgs<ExtArgs>
    _count?: boolean | MachineSaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MachineSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    branch?: boolean | MachineSale$branchArgs<ExtArgs>
  }

  export type $MachineSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineSale"
    objects: {
      installments: Prisma.$InstallmentPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      customerId: string
      saleDate: Date
      type: string
      totalPrice: number
      paidAmount: number
      status: string
      notes: string | null
      branchId: string | null
    }, ExtArgs["result"]["machineSale"]>
    composites: {}
  }

  type MachineSaleGetPayload<S extends boolean | null | undefined | MachineSaleDefaultArgs> = $Result.GetResult<Prisma.$MachineSalePayload, S>

  type MachineSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MachineSaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MachineSaleCountAggregateInputType | true
    }

  export interface MachineSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineSale'], meta: { name: 'MachineSale' } }
    /**
     * Find zero or one MachineSale that matches the filter.
     * @param {MachineSaleFindUniqueArgs} args - Arguments to find a MachineSale
     * @example
     * // Get one MachineSale
     * const machineSale = await prisma.machineSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineSaleFindUniqueArgs>(args: SelectSubset<T, MachineSaleFindUniqueArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MachineSale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MachineSaleFindUniqueOrThrowArgs} args - Arguments to find a MachineSale
     * @example
     * // Get one MachineSale
     * const machineSale = await prisma.machineSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MachineSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleFindFirstArgs} args - Arguments to find a MachineSale
     * @example
     * // Get one MachineSale
     * const machineSale = await prisma.machineSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineSaleFindFirstArgs>(args?: SelectSubset<T, MachineSaleFindFirstArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MachineSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleFindFirstOrThrowArgs} args - Arguments to find a MachineSale
     * @example
     * // Get one MachineSale
     * const machineSale = await prisma.machineSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MachineSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineSales
     * const machineSales = await prisma.machineSale.findMany()
     * 
     * // Get first 10 MachineSales
     * const machineSales = await prisma.machineSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineSaleWithIdOnly = await prisma.machineSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineSaleFindManyArgs>(args?: SelectSubset<T, MachineSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MachineSale.
     * @param {MachineSaleCreateArgs} args - Arguments to create a MachineSale.
     * @example
     * // Create one MachineSale
     * const MachineSale = await prisma.machineSale.create({
     *   data: {
     *     // ... data to create a MachineSale
     *   }
     * })
     * 
     */
    create<T extends MachineSaleCreateArgs>(args: SelectSubset<T, MachineSaleCreateArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MachineSales.
     * @param {MachineSaleCreateManyArgs} args - Arguments to create many MachineSales.
     * @example
     * // Create many MachineSales
     * const machineSale = await prisma.machineSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineSaleCreateManyArgs>(args?: SelectSubset<T, MachineSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineSales and returns the data saved in the database.
     * @param {MachineSaleCreateManyAndReturnArgs} args - Arguments to create many MachineSales.
     * @example
     * // Create many MachineSales
     * const machineSale = await prisma.machineSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineSales and only return the `id`
     * const machineSaleWithIdOnly = await prisma.machineSale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MachineSale.
     * @param {MachineSaleDeleteArgs} args - Arguments to delete one MachineSale.
     * @example
     * // Delete one MachineSale
     * const MachineSale = await prisma.machineSale.delete({
     *   where: {
     *     // ... filter to delete one MachineSale
     *   }
     * })
     * 
     */
    delete<T extends MachineSaleDeleteArgs>(args: SelectSubset<T, MachineSaleDeleteArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MachineSale.
     * @param {MachineSaleUpdateArgs} args - Arguments to update one MachineSale.
     * @example
     * // Update one MachineSale
     * const machineSale = await prisma.machineSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineSaleUpdateArgs>(args: SelectSubset<T, MachineSaleUpdateArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MachineSales.
     * @param {MachineSaleDeleteManyArgs} args - Arguments to filter MachineSales to delete.
     * @example
     * // Delete a few MachineSales
     * const { count } = await prisma.machineSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineSaleDeleteManyArgs>(args?: SelectSubset<T, MachineSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineSales
     * const machineSale = await prisma.machineSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineSaleUpdateManyArgs>(args: SelectSubset<T, MachineSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MachineSale.
     * @param {MachineSaleUpsertArgs} args - Arguments to update or create a MachineSale.
     * @example
     * // Update or create a MachineSale
     * const machineSale = await prisma.machineSale.upsert({
     *   create: {
     *     // ... data to create a MachineSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineSale we want to update
     *   }
     * })
     */
    upsert<T extends MachineSaleUpsertArgs>(args: SelectSubset<T, MachineSaleUpsertArgs<ExtArgs>>): Prisma__MachineSaleClient<$Result.GetResult<Prisma.$MachineSalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MachineSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleCountArgs} args - Arguments to filter MachineSales to count.
     * @example
     * // Count the number of MachineSales
     * const count = await prisma.machineSale.count({
     *   where: {
     *     // ... the filter for the MachineSales we want to count
     *   }
     * })
    **/
    count<T extends MachineSaleCountArgs>(
      args?: Subset<T, MachineSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineSaleAggregateArgs>(args: Subset<T, MachineSaleAggregateArgs>): Prisma.PrismaPromise<GetMachineSaleAggregateType<T>>

    /**
     * Group by MachineSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineSaleGroupByArgs['orderBy'] }
        : { orderBy?: MachineSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineSale model
   */
  readonly fields: MachineSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    installments<T extends MachineSale$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, MachineSale$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends MachineSale$branchArgs<ExtArgs> = {}>(args?: Subset<T, MachineSale$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineSale model
   */ 
  interface MachineSaleFieldRefs {
    readonly id: FieldRef<"MachineSale", 'String'>
    readonly serialNumber: FieldRef<"MachineSale", 'String'>
    readonly customerId: FieldRef<"MachineSale", 'String'>
    readonly saleDate: FieldRef<"MachineSale", 'DateTime'>
    readonly type: FieldRef<"MachineSale", 'String'>
    readonly totalPrice: FieldRef<"MachineSale", 'Float'>
    readonly paidAmount: FieldRef<"MachineSale", 'Float'>
    readonly status: FieldRef<"MachineSale", 'String'>
    readonly notes: FieldRef<"MachineSale", 'String'>
    readonly branchId: FieldRef<"MachineSale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MachineSale findUnique
   */
  export type MachineSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter, which MachineSale to fetch.
     */
    where: MachineSaleWhereUniqueInput
  }

  /**
   * MachineSale findUniqueOrThrow
   */
  export type MachineSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter, which MachineSale to fetch.
     */
    where: MachineSaleWhereUniqueInput
  }

  /**
   * MachineSale findFirst
   */
  export type MachineSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter, which MachineSale to fetch.
     */
    where?: MachineSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSales to fetch.
     */
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineSales.
     */
    cursor?: MachineSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineSales.
     */
    distinct?: MachineSaleScalarFieldEnum | MachineSaleScalarFieldEnum[]
  }

  /**
   * MachineSale findFirstOrThrow
   */
  export type MachineSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter, which MachineSale to fetch.
     */
    where?: MachineSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSales to fetch.
     */
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineSales.
     */
    cursor?: MachineSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineSales.
     */
    distinct?: MachineSaleScalarFieldEnum | MachineSaleScalarFieldEnum[]
  }

  /**
   * MachineSale findMany
   */
  export type MachineSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter, which MachineSales to fetch.
     */
    where?: MachineSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSales to fetch.
     */
    orderBy?: MachineSaleOrderByWithRelationInput | MachineSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineSales.
     */
    cursor?: MachineSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSales.
     */
    skip?: number
    distinct?: MachineSaleScalarFieldEnum | MachineSaleScalarFieldEnum[]
  }

  /**
   * MachineSale create
   */
  export type MachineSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a MachineSale.
     */
    data: XOR<MachineSaleCreateInput, MachineSaleUncheckedCreateInput>
  }

  /**
   * MachineSale createMany
   */
  export type MachineSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineSales.
     */
    data: MachineSaleCreateManyInput | MachineSaleCreateManyInput[]
  }

  /**
   * MachineSale createManyAndReturn
   */
  export type MachineSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MachineSales.
     */
    data: MachineSaleCreateManyInput | MachineSaleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineSale update
   */
  export type MachineSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a MachineSale.
     */
    data: XOR<MachineSaleUpdateInput, MachineSaleUncheckedUpdateInput>
    /**
     * Choose, which MachineSale to update.
     */
    where: MachineSaleWhereUniqueInput
  }

  /**
   * MachineSale updateMany
   */
  export type MachineSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineSales.
     */
    data: XOR<MachineSaleUpdateManyMutationInput, MachineSaleUncheckedUpdateManyInput>
    /**
     * Filter which MachineSales to update
     */
    where?: MachineSaleWhereInput
  }

  /**
   * MachineSale upsert
   */
  export type MachineSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the MachineSale to update in case it exists.
     */
    where: MachineSaleWhereUniqueInput
    /**
     * In case the MachineSale found by the `where` argument doesn't exist, create a new MachineSale with this data.
     */
    create: XOR<MachineSaleCreateInput, MachineSaleUncheckedCreateInput>
    /**
     * In case the MachineSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineSaleUpdateInput, MachineSaleUncheckedUpdateInput>
  }

  /**
   * MachineSale delete
   */
  export type MachineSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
    /**
     * Filter which MachineSale to delete.
     */
    where: MachineSaleWhereUniqueInput
  }

  /**
   * MachineSale deleteMany
   */
  export type MachineSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineSales to delete
     */
    where?: MachineSaleWhereInput
  }

  /**
   * MachineSale.installments
   */
  export type MachineSale$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * MachineSale.branch
   */
  export type MachineSale$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MachineSale without action
   */
  export type MachineSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSale
     */
    select?: MachineSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSaleInclude<ExtArgs> | null
  }


  /**
   * Model PosMachine
   */

  export type AggregatePosMachine = {
    _count: PosMachineCountAggregateOutputType | null
    _min: PosMachineMinAggregateOutputType | null
    _max: PosMachineMaxAggregateOutputType | null
  }

  export type PosMachineMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    posId: string | null
    model: string | null
    manufacturer: string | null
    customerId: string | null
    isMain: boolean | null
    branchId: string | null
  }

  export type PosMachineMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    posId: string | null
    model: string | null
    manufacturer: string | null
    customerId: string | null
    isMain: boolean | null
    branchId: string | null
  }

  export type PosMachineCountAggregateOutputType = {
    id: number
    serialNumber: number
    posId: number
    model: number
    manufacturer: number
    customerId: number
    isMain: number
    branchId: number
    _all: number
  }


  export type PosMachineMinAggregateInputType = {
    id?: true
    serialNumber?: true
    posId?: true
    model?: true
    manufacturer?: true
    customerId?: true
    isMain?: true
    branchId?: true
  }

  export type PosMachineMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    posId?: true
    model?: true
    manufacturer?: true
    customerId?: true
    isMain?: true
    branchId?: true
  }

  export type PosMachineCountAggregateInputType = {
    id?: true
    serialNumber?: true
    posId?: true
    model?: true
    manufacturer?: true
    customerId?: true
    isMain?: true
    branchId?: true
    _all?: true
  }

  export type PosMachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosMachine to aggregate.
     */
    where?: PosMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosMachines to fetch.
     */
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosMachines
    **/
    _count?: true | PosMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosMachineMaxAggregateInputType
  }

  export type GetPosMachineAggregateType<T extends PosMachineAggregateArgs> = {
        [P in keyof T & keyof AggregatePosMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosMachine[P]>
      : GetScalarType<T[P], AggregatePosMachine[P]>
  }




  export type PosMachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosMachineWhereInput
    orderBy?: PosMachineOrderByWithAggregationInput | PosMachineOrderByWithAggregationInput[]
    by: PosMachineScalarFieldEnum[] | PosMachineScalarFieldEnum
    having?: PosMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosMachineCountAggregateInputType | true
    _min?: PosMachineMinAggregateInputType
    _max?: PosMachineMaxAggregateInputType
  }

  export type PosMachineGroupByOutputType = {
    id: string
    serialNumber: string
    posId: string | null
    model: string | null
    manufacturer: string | null
    customerId: string | null
    isMain: boolean | null
    branchId: string | null
    _count: PosMachineCountAggregateOutputType | null
    _min: PosMachineMinAggregateOutputType | null
    _max: PosMachineMaxAggregateOutputType | null
  }

  type GetPosMachineGroupByPayload<T extends PosMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosMachineGroupByOutputType[P]>
            : GetScalarType<T[P], PosMachineGroupByOutputType[P]>
        }
      >
    >


  export type PosMachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    posId?: boolean
    model?: boolean
    manufacturer?: boolean
    customerId?: boolean
    isMain?: boolean
    branchId?: boolean
    requests?: boolean | PosMachine$requestsArgs<ExtArgs>
    customer?: boolean | PosMachine$customerArgs<ExtArgs>
    branch?: boolean | PosMachine$branchArgs<ExtArgs>
    _count?: boolean | PosMachineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posMachine"]>

  export type PosMachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    posId?: boolean
    model?: boolean
    manufacturer?: boolean
    customerId?: boolean
    isMain?: boolean
    branchId?: boolean
    customer?: boolean | PosMachine$customerArgs<ExtArgs>
    branch?: boolean | PosMachine$branchArgs<ExtArgs>
  }, ExtArgs["result"]["posMachine"]>

  export type PosMachineSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    posId?: boolean
    model?: boolean
    manufacturer?: boolean
    customerId?: boolean
    isMain?: boolean
    branchId?: boolean
  }

  export type PosMachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | PosMachine$requestsArgs<ExtArgs>
    customer?: boolean | PosMachine$customerArgs<ExtArgs>
    branch?: boolean | PosMachine$branchArgs<ExtArgs>
    _count?: boolean | PosMachineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PosMachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PosMachine$customerArgs<ExtArgs>
    branch?: boolean | PosMachine$branchArgs<ExtArgs>
  }

  export type $PosMachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosMachine"
    objects: {
      requests: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      posId: string | null
      model: string | null
      manufacturer: string | null
      customerId: string | null
      isMain: boolean | null
      branchId: string | null
    }, ExtArgs["result"]["posMachine"]>
    composites: {}
  }

  type PosMachineGetPayload<S extends boolean | null | undefined | PosMachineDefaultArgs> = $Result.GetResult<Prisma.$PosMachinePayload, S>

  type PosMachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PosMachineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PosMachineCountAggregateInputType | true
    }

  export interface PosMachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosMachine'], meta: { name: 'PosMachine' } }
    /**
     * Find zero or one PosMachine that matches the filter.
     * @param {PosMachineFindUniqueArgs} args - Arguments to find a PosMachine
     * @example
     * // Get one PosMachine
     * const posMachine = await prisma.posMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosMachineFindUniqueArgs>(args: SelectSubset<T, PosMachineFindUniqueArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PosMachine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PosMachineFindUniqueOrThrowArgs} args - Arguments to find a PosMachine
     * @example
     * // Get one PosMachine
     * const posMachine = await prisma.posMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosMachineFindUniqueOrThrowArgs>(args: SelectSubset<T, PosMachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PosMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineFindFirstArgs} args - Arguments to find a PosMachine
     * @example
     * // Get one PosMachine
     * const posMachine = await prisma.posMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosMachineFindFirstArgs>(args?: SelectSubset<T, PosMachineFindFirstArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PosMachine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineFindFirstOrThrowArgs} args - Arguments to find a PosMachine
     * @example
     * // Get one PosMachine
     * const posMachine = await prisma.posMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosMachineFindFirstOrThrowArgs>(args?: SelectSubset<T, PosMachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PosMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosMachines
     * const posMachines = await prisma.posMachine.findMany()
     * 
     * // Get first 10 PosMachines
     * const posMachines = await prisma.posMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posMachineWithIdOnly = await prisma.posMachine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosMachineFindManyArgs>(args?: SelectSubset<T, PosMachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PosMachine.
     * @param {PosMachineCreateArgs} args - Arguments to create a PosMachine.
     * @example
     * // Create one PosMachine
     * const PosMachine = await prisma.posMachine.create({
     *   data: {
     *     // ... data to create a PosMachine
     *   }
     * })
     * 
     */
    create<T extends PosMachineCreateArgs>(args: SelectSubset<T, PosMachineCreateArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PosMachines.
     * @param {PosMachineCreateManyArgs} args - Arguments to create many PosMachines.
     * @example
     * // Create many PosMachines
     * const posMachine = await prisma.posMachine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosMachineCreateManyArgs>(args?: SelectSubset<T, PosMachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosMachines and returns the data saved in the database.
     * @param {PosMachineCreateManyAndReturnArgs} args - Arguments to create many PosMachines.
     * @example
     * // Create many PosMachines
     * const posMachine = await prisma.posMachine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosMachines and only return the `id`
     * const posMachineWithIdOnly = await prisma.posMachine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosMachineCreateManyAndReturnArgs>(args?: SelectSubset<T, PosMachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PosMachine.
     * @param {PosMachineDeleteArgs} args - Arguments to delete one PosMachine.
     * @example
     * // Delete one PosMachine
     * const PosMachine = await prisma.posMachine.delete({
     *   where: {
     *     // ... filter to delete one PosMachine
     *   }
     * })
     * 
     */
    delete<T extends PosMachineDeleteArgs>(args: SelectSubset<T, PosMachineDeleteArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PosMachine.
     * @param {PosMachineUpdateArgs} args - Arguments to update one PosMachine.
     * @example
     * // Update one PosMachine
     * const posMachine = await prisma.posMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosMachineUpdateArgs>(args: SelectSubset<T, PosMachineUpdateArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PosMachines.
     * @param {PosMachineDeleteManyArgs} args - Arguments to filter PosMachines to delete.
     * @example
     * // Delete a few PosMachines
     * const { count } = await prisma.posMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosMachineDeleteManyArgs>(args?: SelectSubset<T, PosMachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosMachines
     * const posMachine = await prisma.posMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosMachineUpdateManyArgs>(args: SelectSubset<T, PosMachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PosMachine.
     * @param {PosMachineUpsertArgs} args - Arguments to update or create a PosMachine.
     * @example
     * // Update or create a PosMachine
     * const posMachine = await prisma.posMachine.upsert({
     *   create: {
     *     // ... data to create a PosMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosMachine we want to update
     *   }
     * })
     */
    upsert<T extends PosMachineUpsertArgs>(args: SelectSubset<T, PosMachineUpsertArgs<ExtArgs>>): Prisma__PosMachineClient<$Result.GetResult<Prisma.$PosMachinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PosMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineCountArgs} args - Arguments to filter PosMachines to count.
     * @example
     * // Count the number of PosMachines
     * const count = await prisma.posMachine.count({
     *   where: {
     *     // ... the filter for the PosMachines we want to count
     *   }
     * })
    **/
    count<T extends PosMachineCountArgs>(
      args?: Subset<T, PosMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosMachineAggregateArgs>(args: Subset<T, PosMachineAggregateArgs>): Prisma.PrismaPromise<GetPosMachineAggregateType<T>>

    /**
     * Group by PosMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosMachineGroupByArgs['orderBy'] }
        : { orderBy?: PosMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosMachine model
   */
  readonly fields: PosMachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosMachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requests<T extends PosMachine$requestsArgs<ExtArgs> = {}>(args?: Subset<T, PosMachine$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends PosMachine$customerArgs<ExtArgs> = {}>(args?: Subset<T, PosMachine$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends PosMachine$branchArgs<ExtArgs> = {}>(args?: Subset<T, PosMachine$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosMachine model
   */ 
  interface PosMachineFieldRefs {
    readonly id: FieldRef<"PosMachine", 'String'>
    readonly serialNumber: FieldRef<"PosMachine", 'String'>
    readonly posId: FieldRef<"PosMachine", 'String'>
    readonly model: FieldRef<"PosMachine", 'String'>
    readonly manufacturer: FieldRef<"PosMachine", 'String'>
    readonly customerId: FieldRef<"PosMachine", 'String'>
    readonly isMain: FieldRef<"PosMachine", 'Boolean'>
    readonly branchId: FieldRef<"PosMachine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosMachine findUnique
   */
  export type PosMachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter, which PosMachine to fetch.
     */
    where: PosMachineWhereUniqueInput
  }

  /**
   * PosMachine findUniqueOrThrow
   */
  export type PosMachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter, which PosMachine to fetch.
     */
    where: PosMachineWhereUniqueInput
  }

  /**
   * PosMachine findFirst
   */
  export type PosMachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter, which PosMachine to fetch.
     */
    where?: PosMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosMachines to fetch.
     */
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosMachines.
     */
    cursor?: PosMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosMachines.
     */
    distinct?: PosMachineScalarFieldEnum | PosMachineScalarFieldEnum[]
  }

  /**
   * PosMachine findFirstOrThrow
   */
  export type PosMachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter, which PosMachine to fetch.
     */
    where?: PosMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosMachines to fetch.
     */
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosMachines.
     */
    cursor?: PosMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosMachines.
     */
    distinct?: PosMachineScalarFieldEnum | PosMachineScalarFieldEnum[]
  }

  /**
   * PosMachine findMany
   */
  export type PosMachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter, which PosMachines to fetch.
     */
    where?: PosMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosMachines to fetch.
     */
    orderBy?: PosMachineOrderByWithRelationInput | PosMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosMachines.
     */
    cursor?: PosMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosMachines.
     */
    skip?: number
    distinct?: PosMachineScalarFieldEnum | PosMachineScalarFieldEnum[]
  }

  /**
   * PosMachine create
   */
  export type PosMachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * The data needed to create a PosMachine.
     */
    data: XOR<PosMachineCreateInput, PosMachineUncheckedCreateInput>
  }

  /**
   * PosMachine createMany
   */
  export type PosMachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosMachines.
     */
    data: PosMachineCreateManyInput | PosMachineCreateManyInput[]
  }

  /**
   * PosMachine createManyAndReturn
   */
  export type PosMachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PosMachines.
     */
    data: PosMachineCreateManyInput | PosMachineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosMachine update
   */
  export type PosMachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * The data needed to update a PosMachine.
     */
    data: XOR<PosMachineUpdateInput, PosMachineUncheckedUpdateInput>
    /**
     * Choose, which PosMachine to update.
     */
    where: PosMachineWhereUniqueInput
  }

  /**
   * PosMachine updateMany
   */
  export type PosMachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosMachines.
     */
    data: XOR<PosMachineUpdateManyMutationInput, PosMachineUncheckedUpdateManyInput>
    /**
     * Filter which PosMachines to update
     */
    where?: PosMachineWhereInput
  }

  /**
   * PosMachine upsert
   */
  export type PosMachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * The filter to search for the PosMachine to update in case it exists.
     */
    where: PosMachineWhereUniqueInput
    /**
     * In case the PosMachine found by the `where` argument doesn't exist, create a new PosMachine with this data.
     */
    create: XOR<PosMachineCreateInput, PosMachineUncheckedCreateInput>
    /**
     * In case the PosMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosMachineUpdateInput, PosMachineUncheckedUpdateInput>
  }

  /**
   * PosMachine delete
   */
  export type PosMachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
    /**
     * Filter which PosMachine to delete.
     */
    where: PosMachineWhereUniqueInput
  }

  /**
   * PosMachine deleteMany
   */
  export type PosMachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosMachines to delete
     */
    where?: PosMachineWhereInput
  }

  /**
   * PosMachine.requests
   */
  export type PosMachine$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * PosMachine.customer
   */
  export type PosMachine$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * PosMachine.branch
   */
  export type PosMachine$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * PosMachine without action
   */
  export type PosMachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosMachine
     */
    select?: PosMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosMachineInclude<ExtArgs> | null
  }


  /**
   * Model SimCard
   */

  export type AggregateSimCard = {
    _count: SimCardCountAggregateOutputType | null
    _min: SimCardMinAggregateOutputType | null
    _max: SimCardMaxAggregateOutputType | null
  }

  export type SimCardMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    type: string | null
    customerId: string | null
    branchId: string | null
  }

  export type SimCardMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    type: string | null
    customerId: string | null
    branchId: string | null
  }

  export type SimCardCountAggregateOutputType = {
    id: number
    serialNumber: number
    type: number
    customerId: number
    branchId: number
    _all: number
  }


  export type SimCardMinAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    customerId?: true
    branchId?: true
  }

  export type SimCardMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    customerId?: true
    branchId?: true
  }

  export type SimCardCountAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    customerId?: true
    branchId?: true
    _all?: true
  }

  export type SimCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimCard to aggregate.
     */
    where?: SimCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimCards to fetch.
     */
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimCards
    **/
    _count?: true | SimCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimCardMaxAggregateInputType
  }

  export type GetSimCardAggregateType<T extends SimCardAggregateArgs> = {
        [P in keyof T & keyof AggregateSimCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimCard[P]>
      : GetScalarType<T[P], AggregateSimCard[P]>
  }




  export type SimCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimCardWhereInput
    orderBy?: SimCardOrderByWithAggregationInput | SimCardOrderByWithAggregationInput[]
    by: SimCardScalarFieldEnum[] | SimCardScalarFieldEnum
    having?: SimCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimCardCountAggregateInputType | true
    _min?: SimCardMinAggregateInputType
    _max?: SimCardMaxAggregateInputType
  }

  export type SimCardGroupByOutputType = {
    id: string
    serialNumber: string
    type: string | null
    customerId: string | null
    branchId: string | null
    _count: SimCardCountAggregateOutputType | null
    _min: SimCardMinAggregateOutputType | null
    _max: SimCardMaxAggregateOutputType | null
  }

  type GetSimCardGroupByPayload<T extends SimCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimCardGroupByOutputType[P]>
            : GetScalarType<T[P], SimCardGroupByOutputType[P]>
        }
      >
    >


  export type SimCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    customerId?: boolean
    branchId?: boolean
    customer?: boolean | SimCard$customerArgs<ExtArgs>
    branch?: boolean | SimCard$branchArgs<ExtArgs>
  }, ExtArgs["result"]["simCard"]>

  export type SimCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    customerId?: boolean
    branchId?: boolean
    customer?: boolean | SimCard$customerArgs<ExtArgs>
    branch?: boolean | SimCard$branchArgs<ExtArgs>
  }, ExtArgs["result"]["simCard"]>

  export type SimCardSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    customerId?: boolean
    branchId?: boolean
  }

  export type SimCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SimCard$customerArgs<ExtArgs>
    branch?: boolean | SimCard$branchArgs<ExtArgs>
  }
  export type SimCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SimCard$customerArgs<ExtArgs>
    branch?: boolean | SimCard$branchArgs<ExtArgs>
  }

  export type $SimCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimCard"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      type: string | null
      customerId: string | null
      branchId: string | null
    }, ExtArgs["result"]["simCard"]>
    composites: {}
  }

  type SimCardGetPayload<S extends boolean | null | undefined | SimCardDefaultArgs> = $Result.GetResult<Prisma.$SimCardPayload, S>

  type SimCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimCardCountAggregateInputType | true
    }

  export interface SimCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimCard'], meta: { name: 'SimCard' } }
    /**
     * Find zero or one SimCard that matches the filter.
     * @param {SimCardFindUniqueArgs} args - Arguments to find a SimCard
     * @example
     * // Get one SimCard
     * const simCard = await prisma.simCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimCardFindUniqueArgs>(args: SelectSubset<T, SimCardFindUniqueArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimCardFindUniqueOrThrowArgs} args - Arguments to find a SimCard
     * @example
     * // Get one SimCard
     * const simCard = await prisma.simCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimCardFindUniqueOrThrowArgs>(args: SelectSubset<T, SimCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardFindFirstArgs} args - Arguments to find a SimCard
     * @example
     * // Get one SimCard
     * const simCard = await prisma.simCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimCardFindFirstArgs>(args?: SelectSubset<T, SimCardFindFirstArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardFindFirstOrThrowArgs} args - Arguments to find a SimCard
     * @example
     * // Get one SimCard
     * const simCard = await prisma.simCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimCardFindFirstOrThrowArgs>(args?: SelectSubset<T, SimCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimCards
     * const simCards = await prisma.simCard.findMany()
     * 
     * // Get first 10 SimCards
     * const simCards = await prisma.simCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simCardWithIdOnly = await prisma.simCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimCardFindManyArgs>(args?: SelectSubset<T, SimCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimCard.
     * @param {SimCardCreateArgs} args - Arguments to create a SimCard.
     * @example
     * // Create one SimCard
     * const SimCard = await prisma.simCard.create({
     *   data: {
     *     // ... data to create a SimCard
     *   }
     * })
     * 
     */
    create<T extends SimCardCreateArgs>(args: SelectSubset<T, SimCardCreateArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimCards.
     * @param {SimCardCreateManyArgs} args - Arguments to create many SimCards.
     * @example
     * // Create many SimCards
     * const simCard = await prisma.simCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimCardCreateManyArgs>(args?: SelectSubset<T, SimCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimCards and returns the data saved in the database.
     * @param {SimCardCreateManyAndReturnArgs} args - Arguments to create many SimCards.
     * @example
     * // Create many SimCards
     * const simCard = await prisma.simCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimCards and only return the `id`
     * const simCardWithIdOnly = await prisma.simCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimCardCreateManyAndReturnArgs>(args?: SelectSubset<T, SimCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimCard.
     * @param {SimCardDeleteArgs} args - Arguments to delete one SimCard.
     * @example
     * // Delete one SimCard
     * const SimCard = await prisma.simCard.delete({
     *   where: {
     *     // ... filter to delete one SimCard
     *   }
     * })
     * 
     */
    delete<T extends SimCardDeleteArgs>(args: SelectSubset<T, SimCardDeleteArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimCard.
     * @param {SimCardUpdateArgs} args - Arguments to update one SimCard.
     * @example
     * // Update one SimCard
     * const simCard = await prisma.simCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimCardUpdateArgs>(args: SelectSubset<T, SimCardUpdateArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimCards.
     * @param {SimCardDeleteManyArgs} args - Arguments to filter SimCards to delete.
     * @example
     * // Delete a few SimCards
     * const { count } = await prisma.simCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimCardDeleteManyArgs>(args?: SelectSubset<T, SimCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimCards
     * const simCard = await prisma.simCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimCardUpdateManyArgs>(args: SelectSubset<T, SimCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimCard.
     * @param {SimCardUpsertArgs} args - Arguments to update or create a SimCard.
     * @example
     * // Update or create a SimCard
     * const simCard = await prisma.simCard.upsert({
     *   create: {
     *     // ... data to create a SimCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimCard we want to update
     *   }
     * })
     */
    upsert<T extends SimCardUpsertArgs>(args: SelectSubset<T, SimCardUpsertArgs<ExtArgs>>): Prisma__SimCardClient<$Result.GetResult<Prisma.$SimCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardCountArgs} args - Arguments to filter SimCards to count.
     * @example
     * // Count the number of SimCards
     * const count = await prisma.simCard.count({
     *   where: {
     *     // ... the filter for the SimCards we want to count
     *   }
     * })
    **/
    count<T extends SimCardCountArgs>(
      args?: Subset<T, SimCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimCardAggregateArgs>(args: Subset<T, SimCardAggregateArgs>): Prisma.PrismaPromise<GetSimCardAggregateType<T>>

    /**
     * Group by SimCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimCardGroupByArgs['orderBy'] }
        : { orderBy?: SimCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimCard model
   */
  readonly fields: SimCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SimCard$customerArgs<ExtArgs> = {}>(args?: Subset<T, SimCard$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends SimCard$branchArgs<ExtArgs> = {}>(args?: Subset<T, SimCard$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimCard model
   */ 
  interface SimCardFieldRefs {
    readonly id: FieldRef<"SimCard", 'String'>
    readonly serialNumber: FieldRef<"SimCard", 'String'>
    readonly type: FieldRef<"SimCard", 'String'>
    readonly customerId: FieldRef<"SimCard", 'String'>
    readonly branchId: FieldRef<"SimCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SimCard findUnique
   */
  export type SimCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter, which SimCard to fetch.
     */
    where: SimCardWhereUniqueInput
  }

  /**
   * SimCard findUniqueOrThrow
   */
  export type SimCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter, which SimCard to fetch.
     */
    where: SimCardWhereUniqueInput
  }

  /**
   * SimCard findFirst
   */
  export type SimCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter, which SimCard to fetch.
     */
    where?: SimCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimCards to fetch.
     */
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimCards.
     */
    cursor?: SimCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimCards.
     */
    distinct?: SimCardScalarFieldEnum | SimCardScalarFieldEnum[]
  }

  /**
   * SimCard findFirstOrThrow
   */
  export type SimCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter, which SimCard to fetch.
     */
    where?: SimCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimCards to fetch.
     */
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimCards.
     */
    cursor?: SimCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimCards.
     */
    distinct?: SimCardScalarFieldEnum | SimCardScalarFieldEnum[]
  }

  /**
   * SimCard findMany
   */
  export type SimCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter, which SimCards to fetch.
     */
    where?: SimCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimCards to fetch.
     */
    orderBy?: SimCardOrderByWithRelationInput | SimCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimCards.
     */
    cursor?: SimCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimCards.
     */
    skip?: number
    distinct?: SimCardScalarFieldEnum | SimCardScalarFieldEnum[]
  }

  /**
   * SimCard create
   */
  export type SimCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * The data needed to create a SimCard.
     */
    data: XOR<SimCardCreateInput, SimCardUncheckedCreateInput>
  }

  /**
   * SimCard createMany
   */
  export type SimCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimCards.
     */
    data: SimCardCreateManyInput | SimCardCreateManyInput[]
  }

  /**
   * SimCard createManyAndReturn
   */
  export type SimCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimCards.
     */
    data: SimCardCreateManyInput | SimCardCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimCard update
   */
  export type SimCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * The data needed to update a SimCard.
     */
    data: XOR<SimCardUpdateInput, SimCardUncheckedUpdateInput>
    /**
     * Choose, which SimCard to update.
     */
    where: SimCardWhereUniqueInput
  }

  /**
   * SimCard updateMany
   */
  export type SimCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimCards.
     */
    data: XOR<SimCardUpdateManyMutationInput, SimCardUncheckedUpdateManyInput>
    /**
     * Filter which SimCards to update
     */
    where?: SimCardWhereInput
  }

  /**
   * SimCard upsert
   */
  export type SimCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * The filter to search for the SimCard to update in case it exists.
     */
    where: SimCardWhereUniqueInput
    /**
     * In case the SimCard found by the `where` argument doesn't exist, create a new SimCard with this data.
     */
    create: XOR<SimCardCreateInput, SimCardUncheckedCreateInput>
    /**
     * In case the SimCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimCardUpdateInput, SimCardUncheckedUpdateInput>
  }

  /**
   * SimCard delete
   */
  export type SimCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
    /**
     * Filter which SimCard to delete.
     */
    where: SimCardWhereUniqueInput
  }

  /**
   * SimCard deleteMany
   */
  export type SimCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimCards to delete
     */
    where?: SimCardWhereInput
  }

  /**
   * SimCard.customer
   */
  export type SimCard$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SimCard.branch
   */
  export type SimCard$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * SimCard without action
   */
  export type SimCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimCard
     */
    select?: SimCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimCardInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseMachine
   */

  export type AggregateWarehouseMachine = {
    _count: WarehouseMachineCountAggregateOutputType | null
    _avg: WarehouseMachineAvgAggregateOutputType | null
    _sum: WarehouseMachineSumAggregateOutputType | null
    _min: WarehouseMachineMinAggregateOutputType | null
    _max: WarehouseMachineMaxAggregateOutputType | null
  }

  export type WarehouseMachineAvgAggregateOutputType = {
    proposedTotalCost: number | null
    totalCost: number | null
  }

  export type WarehouseMachineSumAggregateOutputType = {
    proposedTotalCost: number | null
    totalCost: number | null
  }

  export type WarehouseMachineMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    model: string | null
    manufacturer: string | null
    status: string | null
    resolution: string | null
    notes: string | null
    importDate: Date | null
    updatedAt: Date | null
    originalOwnerId: string | null
    branchId: string | null
    requestId: string | null
    customerId: string | null
    customerName: string | null
    readyForPickup: boolean | null
    currentAssignmentId: string | null
    currentTechnicianId: string | null
    currentTechnicianName: string | null
    originBranchId: string | null
    proposedParts: string | null
    proposedRepairNotes: string | null
    proposedTotalCost: number | null
    repairNotes: string | null
    totalCost: number | null
    usedParts: string | null
  }

  export type WarehouseMachineMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    model: string | null
    manufacturer: string | null
    status: string | null
    resolution: string | null
    notes: string | null
    importDate: Date | null
    updatedAt: Date | null
    originalOwnerId: string | null
    branchId: string | null
    requestId: string | null
    customerId: string | null
    customerName: string | null
    readyForPickup: boolean | null
    currentAssignmentId: string | null
    currentTechnicianId: string | null
    currentTechnicianName: string | null
    originBranchId: string | null
    proposedParts: string | null
    proposedRepairNotes: string | null
    proposedTotalCost: number | null
    repairNotes: string | null
    totalCost: number | null
    usedParts: string | null
  }

  export type WarehouseMachineCountAggregateOutputType = {
    id: number
    serialNumber: number
    model: number
    manufacturer: number
    status: number
    resolution: number
    notes: number
    importDate: number
    updatedAt: number
    originalOwnerId: number
    branchId: number
    requestId: number
    customerId: number
    customerName: number
    readyForPickup: number
    currentAssignmentId: number
    currentTechnicianId: number
    currentTechnicianName: number
    originBranchId: number
    proposedParts: number
    proposedRepairNotes: number
    proposedTotalCost: number
    repairNotes: number
    totalCost: number
    usedParts: number
    _all: number
  }


  export type WarehouseMachineAvgAggregateInputType = {
    proposedTotalCost?: true
    totalCost?: true
  }

  export type WarehouseMachineSumAggregateInputType = {
    proposedTotalCost?: true
    totalCost?: true
  }

  export type WarehouseMachineMinAggregateInputType = {
    id?: true
    serialNumber?: true
    model?: true
    manufacturer?: true
    status?: true
    resolution?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    originalOwnerId?: true
    branchId?: true
    requestId?: true
    customerId?: true
    customerName?: true
    readyForPickup?: true
    currentAssignmentId?: true
    currentTechnicianId?: true
    currentTechnicianName?: true
    originBranchId?: true
    proposedParts?: true
    proposedRepairNotes?: true
    proposedTotalCost?: true
    repairNotes?: true
    totalCost?: true
    usedParts?: true
  }

  export type WarehouseMachineMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    model?: true
    manufacturer?: true
    status?: true
    resolution?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    originalOwnerId?: true
    branchId?: true
    requestId?: true
    customerId?: true
    customerName?: true
    readyForPickup?: true
    currentAssignmentId?: true
    currentTechnicianId?: true
    currentTechnicianName?: true
    originBranchId?: true
    proposedParts?: true
    proposedRepairNotes?: true
    proposedTotalCost?: true
    repairNotes?: true
    totalCost?: true
    usedParts?: true
  }

  export type WarehouseMachineCountAggregateInputType = {
    id?: true
    serialNumber?: true
    model?: true
    manufacturer?: true
    status?: true
    resolution?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    originalOwnerId?: true
    branchId?: true
    requestId?: true
    customerId?: true
    customerName?: true
    readyForPickup?: true
    currentAssignmentId?: true
    currentTechnicianId?: true
    currentTechnicianName?: true
    originBranchId?: true
    proposedParts?: true
    proposedRepairNotes?: true
    proposedTotalCost?: true
    repairNotes?: true
    totalCost?: true
    usedParts?: true
    _all?: true
  }

  export type WarehouseMachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseMachine to aggregate.
     */
    where?: WarehouseMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseMachines to fetch.
     */
    orderBy?: WarehouseMachineOrderByWithRelationInput | WarehouseMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseMachines
    **/
    _count?: true | WarehouseMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMachineMaxAggregateInputType
  }

  export type GetWarehouseMachineAggregateType<T extends WarehouseMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseMachine[P]>
      : GetScalarType<T[P], AggregateWarehouseMachine[P]>
  }




  export type WarehouseMachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseMachineWhereInput
    orderBy?: WarehouseMachineOrderByWithAggregationInput | WarehouseMachineOrderByWithAggregationInput[]
    by: WarehouseMachineScalarFieldEnum[] | WarehouseMachineScalarFieldEnum
    having?: WarehouseMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseMachineCountAggregateInputType | true
    _avg?: WarehouseMachineAvgAggregateInputType
    _sum?: WarehouseMachineSumAggregateInputType
    _min?: WarehouseMachineMinAggregateInputType
    _max?: WarehouseMachineMaxAggregateInputType
  }

  export type WarehouseMachineGroupByOutputType = {
    id: string
    serialNumber: string
    model: string | null
    manufacturer: string | null
    status: string
    resolution: string | null
    notes: string | null
    importDate: Date
    updatedAt: Date
    originalOwnerId: string | null
    branchId: string | null
    requestId: string | null
    customerId: string | null
    customerName: string | null
    readyForPickup: boolean
    currentAssignmentId: string | null
    currentTechnicianId: string | null
    currentTechnicianName: string | null
    originBranchId: string | null
    proposedParts: string | null
    proposedRepairNotes: string | null
    proposedTotalCost: number | null
    repairNotes: string | null
    totalCost: number | null
    usedParts: string | null
    _count: WarehouseMachineCountAggregateOutputType | null
    _avg: WarehouseMachineAvgAggregateOutputType | null
    _sum: WarehouseMachineSumAggregateOutputType | null
    _min: WarehouseMachineMinAggregateOutputType | null
    _max: WarehouseMachineMaxAggregateOutputType | null
  }

  type GetWarehouseMachineGroupByPayload<T extends WarehouseMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseMachineGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseMachineGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseMachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    resolution?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    originalOwnerId?: boolean
    branchId?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    readyForPickup?: boolean
    currentAssignmentId?: boolean
    currentTechnicianId?: boolean
    currentTechnicianName?: boolean
    originBranchId?: boolean
    proposedParts?: boolean
    proposedRepairNotes?: boolean
    proposedTotalCost?: boolean
    repairNotes?: boolean
    totalCost?: boolean
    usedParts?: boolean
    serviceAssignments?: boolean | WarehouseMachine$serviceAssignmentsArgs<ExtArgs>
    branch?: boolean | WarehouseMachine$branchArgs<ExtArgs>
    _count?: boolean | WarehouseMachineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseMachine"]>

  export type WarehouseMachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    resolution?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    originalOwnerId?: boolean
    branchId?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    readyForPickup?: boolean
    currentAssignmentId?: boolean
    currentTechnicianId?: boolean
    currentTechnicianName?: boolean
    originBranchId?: boolean
    proposedParts?: boolean
    proposedRepairNotes?: boolean
    proposedTotalCost?: boolean
    repairNotes?: boolean
    totalCost?: boolean
    usedParts?: boolean
    branch?: boolean | WarehouseMachine$branchArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseMachine"]>

  export type WarehouseMachineSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    resolution?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    originalOwnerId?: boolean
    branchId?: boolean
    requestId?: boolean
    customerId?: boolean
    customerName?: boolean
    readyForPickup?: boolean
    currentAssignmentId?: boolean
    currentTechnicianId?: boolean
    currentTechnicianName?: boolean
    originBranchId?: boolean
    proposedParts?: boolean
    proposedRepairNotes?: boolean
    proposedTotalCost?: boolean
    repairNotes?: boolean
    totalCost?: boolean
    usedParts?: boolean
  }

  export type WarehouseMachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceAssignments?: boolean | WarehouseMachine$serviceAssignmentsArgs<ExtArgs>
    branch?: boolean | WarehouseMachine$branchArgs<ExtArgs>
    _count?: boolean | WarehouseMachineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseMachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | WarehouseMachine$branchArgs<ExtArgs>
  }

  export type $WarehouseMachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseMachine"
    objects: {
      serviceAssignments: Prisma.$ServiceAssignmentPayload<ExtArgs>[]
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      model: string | null
      manufacturer: string | null
      status: string
      resolution: string | null
      notes: string | null
      importDate: Date
      updatedAt: Date
      originalOwnerId: string | null
      branchId: string | null
      requestId: string | null
      customerId: string | null
      customerName: string | null
      readyForPickup: boolean
      currentAssignmentId: string | null
      currentTechnicianId: string | null
      currentTechnicianName: string | null
      originBranchId: string | null
      proposedParts: string | null
      proposedRepairNotes: string | null
      proposedTotalCost: number | null
      repairNotes: string | null
      totalCost: number | null
      usedParts: string | null
    }, ExtArgs["result"]["warehouseMachine"]>
    composites: {}
  }

  type WarehouseMachineGetPayload<S extends boolean | null | undefined | WarehouseMachineDefaultArgs> = $Result.GetResult<Prisma.$WarehouseMachinePayload, S>

  type WarehouseMachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseMachineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseMachineCountAggregateInputType | true
    }

  export interface WarehouseMachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseMachine'], meta: { name: 'WarehouseMachine' } }
    /**
     * Find zero or one WarehouseMachine that matches the filter.
     * @param {WarehouseMachineFindUniqueArgs} args - Arguments to find a WarehouseMachine
     * @example
     * // Get one WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseMachineFindUniqueArgs>(args: SelectSubset<T, WarehouseMachineFindUniqueArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WarehouseMachine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarehouseMachineFindUniqueOrThrowArgs} args - Arguments to find a WarehouseMachine
     * @example
     * // Get one WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseMachineFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseMachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WarehouseMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineFindFirstArgs} args - Arguments to find a WarehouseMachine
     * @example
     * // Get one WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseMachineFindFirstArgs>(args?: SelectSubset<T, WarehouseMachineFindFirstArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WarehouseMachine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineFindFirstOrThrowArgs} args - Arguments to find a WarehouseMachine
     * @example
     * // Get one WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseMachineFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseMachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WarehouseMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseMachines
     * const warehouseMachines = await prisma.warehouseMachine.findMany()
     * 
     * // Get first 10 WarehouseMachines
     * const warehouseMachines = await prisma.warehouseMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseMachineWithIdOnly = await prisma.warehouseMachine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseMachineFindManyArgs>(args?: SelectSubset<T, WarehouseMachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WarehouseMachine.
     * @param {WarehouseMachineCreateArgs} args - Arguments to create a WarehouseMachine.
     * @example
     * // Create one WarehouseMachine
     * const WarehouseMachine = await prisma.warehouseMachine.create({
     *   data: {
     *     // ... data to create a WarehouseMachine
     *   }
     * })
     * 
     */
    create<T extends WarehouseMachineCreateArgs>(args: SelectSubset<T, WarehouseMachineCreateArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WarehouseMachines.
     * @param {WarehouseMachineCreateManyArgs} args - Arguments to create many WarehouseMachines.
     * @example
     * // Create many WarehouseMachines
     * const warehouseMachine = await prisma.warehouseMachine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseMachineCreateManyArgs>(args?: SelectSubset<T, WarehouseMachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseMachines and returns the data saved in the database.
     * @param {WarehouseMachineCreateManyAndReturnArgs} args - Arguments to create many WarehouseMachines.
     * @example
     * // Create many WarehouseMachines
     * const warehouseMachine = await prisma.warehouseMachine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseMachines and only return the `id`
     * const warehouseMachineWithIdOnly = await prisma.warehouseMachine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseMachineCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseMachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WarehouseMachine.
     * @param {WarehouseMachineDeleteArgs} args - Arguments to delete one WarehouseMachine.
     * @example
     * // Delete one WarehouseMachine
     * const WarehouseMachine = await prisma.warehouseMachine.delete({
     *   where: {
     *     // ... filter to delete one WarehouseMachine
     *   }
     * })
     * 
     */
    delete<T extends WarehouseMachineDeleteArgs>(args: SelectSubset<T, WarehouseMachineDeleteArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WarehouseMachine.
     * @param {WarehouseMachineUpdateArgs} args - Arguments to update one WarehouseMachine.
     * @example
     * // Update one WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseMachineUpdateArgs>(args: SelectSubset<T, WarehouseMachineUpdateArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WarehouseMachines.
     * @param {WarehouseMachineDeleteManyArgs} args - Arguments to filter WarehouseMachines to delete.
     * @example
     * // Delete a few WarehouseMachines
     * const { count } = await prisma.warehouseMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseMachineDeleteManyArgs>(args?: SelectSubset<T, WarehouseMachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseMachines
     * const warehouseMachine = await prisma.warehouseMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseMachineUpdateManyArgs>(args: SelectSubset<T, WarehouseMachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarehouseMachine.
     * @param {WarehouseMachineUpsertArgs} args - Arguments to update or create a WarehouseMachine.
     * @example
     * // Update or create a WarehouseMachine
     * const warehouseMachine = await prisma.warehouseMachine.upsert({
     *   create: {
     *     // ... data to create a WarehouseMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseMachine we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseMachineUpsertArgs>(args: SelectSubset<T, WarehouseMachineUpsertArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WarehouseMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineCountArgs} args - Arguments to filter WarehouseMachines to count.
     * @example
     * // Count the number of WarehouseMachines
     * const count = await prisma.warehouseMachine.count({
     *   where: {
     *     // ... the filter for the WarehouseMachines we want to count
     *   }
     * })
    **/
    count<T extends WarehouseMachineCountArgs>(
      args?: Subset<T, WarehouseMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseMachineAggregateArgs>(args: Subset<T, WarehouseMachineAggregateArgs>): Prisma.PrismaPromise<GetWarehouseMachineAggregateType<T>>

    /**
     * Group by WarehouseMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseMachineGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseMachine model
   */
  readonly fields: WarehouseMachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseMachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceAssignments<T extends WarehouseMachine$serviceAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseMachine$serviceAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    branch<T extends WarehouseMachine$branchArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseMachine$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseMachine model
   */ 
  interface WarehouseMachineFieldRefs {
    readonly id: FieldRef<"WarehouseMachine", 'String'>
    readonly serialNumber: FieldRef<"WarehouseMachine", 'String'>
    readonly model: FieldRef<"WarehouseMachine", 'String'>
    readonly manufacturer: FieldRef<"WarehouseMachine", 'String'>
    readonly status: FieldRef<"WarehouseMachine", 'String'>
    readonly resolution: FieldRef<"WarehouseMachine", 'String'>
    readonly notes: FieldRef<"WarehouseMachine", 'String'>
    readonly importDate: FieldRef<"WarehouseMachine", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseMachine", 'DateTime'>
    readonly originalOwnerId: FieldRef<"WarehouseMachine", 'String'>
    readonly branchId: FieldRef<"WarehouseMachine", 'String'>
    readonly requestId: FieldRef<"WarehouseMachine", 'String'>
    readonly customerId: FieldRef<"WarehouseMachine", 'String'>
    readonly customerName: FieldRef<"WarehouseMachine", 'String'>
    readonly readyForPickup: FieldRef<"WarehouseMachine", 'Boolean'>
    readonly currentAssignmentId: FieldRef<"WarehouseMachine", 'String'>
    readonly currentTechnicianId: FieldRef<"WarehouseMachine", 'String'>
    readonly currentTechnicianName: FieldRef<"WarehouseMachine", 'String'>
    readonly originBranchId: FieldRef<"WarehouseMachine", 'String'>
    readonly proposedParts: FieldRef<"WarehouseMachine", 'String'>
    readonly proposedRepairNotes: FieldRef<"WarehouseMachine", 'String'>
    readonly proposedTotalCost: FieldRef<"WarehouseMachine", 'Float'>
    readonly repairNotes: FieldRef<"WarehouseMachine", 'String'>
    readonly totalCost: FieldRef<"WarehouseMachine", 'Float'>
    readonly usedParts: FieldRef<"WarehouseMachine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseMachine findUnique
   */
  export type WarehouseMachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseMachine to fetch.
     */
    where: WarehouseMachineWhereUniqueInput
  }

  /**
   * WarehouseMachine findUniqueOrThrow
   */
  export type WarehouseMachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseMachine to fetch.
     */
    where: WarehouseMachineWhereUniqueInput
  }

  /**
   * WarehouseMachine findFirst
   */
  export type WarehouseMachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseMachine to fetch.
     */
    where?: WarehouseMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseMachines to fetch.
     */
    orderBy?: WarehouseMachineOrderByWithRelationInput | WarehouseMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseMachines.
     */
    cursor?: WarehouseMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseMachines.
     */
    distinct?: WarehouseMachineScalarFieldEnum | WarehouseMachineScalarFieldEnum[]
  }

  /**
   * WarehouseMachine findFirstOrThrow
   */
  export type WarehouseMachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseMachine to fetch.
     */
    where?: WarehouseMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseMachines to fetch.
     */
    orderBy?: WarehouseMachineOrderByWithRelationInput | WarehouseMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseMachines.
     */
    cursor?: WarehouseMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseMachines.
     */
    distinct?: WarehouseMachineScalarFieldEnum | WarehouseMachineScalarFieldEnum[]
  }

  /**
   * WarehouseMachine findMany
   */
  export type WarehouseMachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseMachines to fetch.
     */
    where?: WarehouseMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseMachines to fetch.
     */
    orderBy?: WarehouseMachineOrderByWithRelationInput | WarehouseMachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseMachines.
     */
    cursor?: WarehouseMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseMachines.
     */
    skip?: number
    distinct?: WarehouseMachineScalarFieldEnum | WarehouseMachineScalarFieldEnum[]
  }

  /**
   * WarehouseMachine create
   */
  export type WarehouseMachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseMachine.
     */
    data: XOR<WarehouseMachineCreateInput, WarehouseMachineUncheckedCreateInput>
  }

  /**
   * WarehouseMachine createMany
   */
  export type WarehouseMachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseMachines.
     */
    data: WarehouseMachineCreateManyInput | WarehouseMachineCreateManyInput[]
  }

  /**
   * WarehouseMachine createManyAndReturn
   */
  export type WarehouseMachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WarehouseMachines.
     */
    data: WarehouseMachineCreateManyInput | WarehouseMachineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseMachine update
   */
  export type WarehouseMachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseMachine.
     */
    data: XOR<WarehouseMachineUpdateInput, WarehouseMachineUncheckedUpdateInput>
    /**
     * Choose, which WarehouseMachine to update.
     */
    where: WarehouseMachineWhereUniqueInput
  }

  /**
   * WarehouseMachine updateMany
   */
  export type WarehouseMachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseMachines.
     */
    data: XOR<WarehouseMachineUpdateManyMutationInput, WarehouseMachineUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseMachines to update
     */
    where?: WarehouseMachineWhereInput
  }

  /**
   * WarehouseMachine upsert
   */
  export type WarehouseMachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseMachine to update in case it exists.
     */
    where: WarehouseMachineWhereUniqueInput
    /**
     * In case the WarehouseMachine found by the `where` argument doesn't exist, create a new WarehouseMachine with this data.
     */
    create: XOR<WarehouseMachineCreateInput, WarehouseMachineUncheckedCreateInput>
    /**
     * In case the WarehouseMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseMachineUpdateInput, WarehouseMachineUncheckedUpdateInput>
  }

  /**
   * WarehouseMachine delete
   */
  export type WarehouseMachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
    /**
     * Filter which WarehouseMachine to delete.
     */
    where: WarehouseMachineWhereUniqueInput
  }

  /**
   * WarehouseMachine deleteMany
   */
  export type WarehouseMachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseMachines to delete
     */
    where?: WarehouseMachineWhereInput
  }

  /**
   * WarehouseMachine.serviceAssignments
   */
  export type WarehouseMachine$serviceAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    cursor?: ServiceAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * WarehouseMachine.branch
   */
  export type WarehouseMachine$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * WarehouseMachine without action
   */
  export type WarehouseMachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseMachine
     */
    select?: WarehouseMachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseMachineInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseSim
   */

  export type AggregateWarehouseSim = {
    _count: WarehouseSimCountAggregateOutputType | null
    _min: WarehouseSimMinAggregateOutputType | null
    _max: WarehouseSimMaxAggregateOutputType | null
  }

  export type WarehouseSimMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    type: string | null
    status: string | null
    notes: string | null
    importDate: Date | null
    updatedAt: Date | null
    branchId: string | null
  }

  export type WarehouseSimMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    type: string | null
    status: string | null
    notes: string | null
    importDate: Date | null
    updatedAt: Date | null
    branchId: string | null
  }

  export type WarehouseSimCountAggregateOutputType = {
    id: number
    serialNumber: number
    type: number
    status: number
    notes: number
    importDate: number
    updatedAt: number
    branchId: number
    _all: number
  }


  export type WarehouseSimMinAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    status?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    branchId?: true
  }

  export type WarehouseSimMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    status?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    branchId?: true
  }

  export type WarehouseSimCountAggregateInputType = {
    id?: true
    serialNumber?: true
    type?: true
    status?: true
    notes?: true
    importDate?: true
    updatedAt?: true
    branchId?: true
    _all?: true
  }

  export type WarehouseSimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseSim to aggregate.
     */
    where?: WarehouseSimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseSims to fetch.
     */
    orderBy?: WarehouseSimOrderByWithRelationInput | WarehouseSimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseSimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseSims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseSims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseSims
    **/
    _count?: true | WarehouseSimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseSimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseSimMaxAggregateInputType
  }

  export type GetWarehouseSimAggregateType<T extends WarehouseSimAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseSim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseSim[P]>
      : GetScalarType<T[P], AggregateWarehouseSim[P]>
  }




  export type WarehouseSimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseSimWhereInput
    orderBy?: WarehouseSimOrderByWithAggregationInput | WarehouseSimOrderByWithAggregationInput[]
    by: WarehouseSimScalarFieldEnum[] | WarehouseSimScalarFieldEnum
    having?: WarehouseSimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseSimCountAggregateInputType | true
    _min?: WarehouseSimMinAggregateInputType
    _max?: WarehouseSimMaxAggregateInputType
  }

  export type WarehouseSimGroupByOutputType = {
    id: string
    serialNumber: string
    type: string | null
    status: string
    notes: string | null
    importDate: Date
    updatedAt: Date
    branchId: string | null
    _count: WarehouseSimCountAggregateOutputType | null
    _min: WarehouseSimMinAggregateOutputType | null
    _max: WarehouseSimMaxAggregateOutputType | null
  }

  type GetWarehouseSimGroupByPayload<T extends WarehouseSimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseSimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseSimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseSimGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseSimGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | WarehouseSim$branchArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseSim"]>

  export type WarehouseSimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | WarehouseSim$branchArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseSim"]>

  export type WarehouseSimSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    importDate?: boolean
    updatedAt?: boolean
    branchId?: boolean
  }

  export type WarehouseSimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | WarehouseSim$branchArgs<ExtArgs>
  }
  export type WarehouseSimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | WarehouseSim$branchArgs<ExtArgs>
  }

  export type $WarehouseSimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseSim"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      type: string | null
      status: string
      notes: string | null
      importDate: Date
      updatedAt: Date
      branchId: string | null
    }, ExtArgs["result"]["warehouseSim"]>
    composites: {}
  }

  type WarehouseSimGetPayload<S extends boolean | null | undefined | WarehouseSimDefaultArgs> = $Result.GetResult<Prisma.$WarehouseSimPayload, S>

  type WarehouseSimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseSimFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseSimCountAggregateInputType | true
    }

  export interface WarehouseSimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseSim'], meta: { name: 'WarehouseSim' } }
    /**
     * Find zero or one WarehouseSim that matches the filter.
     * @param {WarehouseSimFindUniqueArgs} args - Arguments to find a WarehouseSim
     * @example
     * // Get one WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseSimFindUniqueArgs>(args: SelectSubset<T, WarehouseSimFindUniqueArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WarehouseSim that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarehouseSimFindUniqueOrThrowArgs} args - Arguments to find a WarehouseSim
     * @example
     * // Get one WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseSimFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseSimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WarehouseSim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimFindFirstArgs} args - Arguments to find a WarehouseSim
     * @example
     * // Get one WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseSimFindFirstArgs>(args?: SelectSubset<T, WarehouseSimFindFirstArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WarehouseSim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimFindFirstOrThrowArgs} args - Arguments to find a WarehouseSim
     * @example
     * // Get one WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseSimFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseSimFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WarehouseSims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseSims
     * const warehouseSims = await prisma.warehouseSim.findMany()
     * 
     * // Get first 10 WarehouseSims
     * const warehouseSims = await prisma.warehouseSim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseSimWithIdOnly = await prisma.warehouseSim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseSimFindManyArgs>(args?: SelectSubset<T, WarehouseSimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WarehouseSim.
     * @param {WarehouseSimCreateArgs} args - Arguments to create a WarehouseSim.
     * @example
     * // Create one WarehouseSim
     * const WarehouseSim = await prisma.warehouseSim.create({
     *   data: {
     *     // ... data to create a WarehouseSim
     *   }
     * })
     * 
     */
    create<T extends WarehouseSimCreateArgs>(args: SelectSubset<T, WarehouseSimCreateArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WarehouseSims.
     * @param {WarehouseSimCreateManyArgs} args - Arguments to create many WarehouseSims.
     * @example
     * // Create many WarehouseSims
     * const warehouseSim = await prisma.warehouseSim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseSimCreateManyArgs>(args?: SelectSubset<T, WarehouseSimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseSims and returns the data saved in the database.
     * @param {WarehouseSimCreateManyAndReturnArgs} args - Arguments to create many WarehouseSims.
     * @example
     * // Create many WarehouseSims
     * const warehouseSim = await prisma.warehouseSim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseSims and only return the `id`
     * const warehouseSimWithIdOnly = await prisma.warehouseSim.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseSimCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseSimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WarehouseSim.
     * @param {WarehouseSimDeleteArgs} args - Arguments to delete one WarehouseSim.
     * @example
     * // Delete one WarehouseSim
     * const WarehouseSim = await prisma.warehouseSim.delete({
     *   where: {
     *     // ... filter to delete one WarehouseSim
     *   }
     * })
     * 
     */
    delete<T extends WarehouseSimDeleteArgs>(args: SelectSubset<T, WarehouseSimDeleteArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WarehouseSim.
     * @param {WarehouseSimUpdateArgs} args - Arguments to update one WarehouseSim.
     * @example
     * // Update one WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseSimUpdateArgs>(args: SelectSubset<T, WarehouseSimUpdateArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WarehouseSims.
     * @param {WarehouseSimDeleteManyArgs} args - Arguments to filter WarehouseSims to delete.
     * @example
     * // Delete a few WarehouseSims
     * const { count } = await prisma.warehouseSim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseSimDeleteManyArgs>(args?: SelectSubset<T, WarehouseSimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseSims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseSims
     * const warehouseSim = await prisma.warehouseSim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseSimUpdateManyArgs>(args: SelectSubset<T, WarehouseSimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarehouseSim.
     * @param {WarehouseSimUpsertArgs} args - Arguments to update or create a WarehouseSim.
     * @example
     * // Update or create a WarehouseSim
     * const warehouseSim = await prisma.warehouseSim.upsert({
     *   create: {
     *     // ... data to create a WarehouseSim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseSim we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseSimUpsertArgs>(args: SelectSubset<T, WarehouseSimUpsertArgs<ExtArgs>>): Prisma__WarehouseSimClient<$Result.GetResult<Prisma.$WarehouseSimPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WarehouseSims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimCountArgs} args - Arguments to filter WarehouseSims to count.
     * @example
     * // Count the number of WarehouseSims
     * const count = await prisma.warehouseSim.count({
     *   where: {
     *     // ... the filter for the WarehouseSims we want to count
     *   }
     * })
    **/
    count<T extends WarehouseSimCountArgs>(
      args?: Subset<T, WarehouseSimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseSimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseSim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseSimAggregateArgs>(args: Subset<T, WarehouseSimAggregateArgs>): Prisma.PrismaPromise<GetWarehouseSimAggregateType<T>>

    /**
     * Group by WarehouseSim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseSimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseSimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseSimGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseSimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseSimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseSimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseSim model
   */
  readonly fields: WarehouseSimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseSim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseSimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends WarehouseSim$branchArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseSim$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseSim model
   */ 
  interface WarehouseSimFieldRefs {
    readonly id: FieldRef<"WarehouseSim", 'String'>
    readonly serialNumber: FieldRef<"WarehouseSim", 'String'>
    readonly type: FieldRef<"WarehouseSim", 'String'>
    readonly status: FieldRef<"WarehouseSim", 'String'>
    readonly notes: FieldRef<"WarehouseSim", 'String'>
    readonly importDate: FieldRef<"WarehouseSim", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseSim", 'DateTime'>
    readonly branchId: FieldRef<"WarehouseSim", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseSim findUnique
   */
  export type WarehouseSimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseSim to fetch.
     */
    where: WarehouseSimWhereUniqueInput
  }

  /**
   * WarehouseSim findUniqueOrThrow
   */
  export type WarehouseSimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseSim to fetch.
     */
    where: WarehouseSimWhereUniqueInput
  }

  /**
   * WarehouseSim findFirst
   */
  export type WarehouseSimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseSim to fetch.
     */
    where?: WarehouseSimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseSims to fetch.
     */
    orderBy?: WarehouseSimOrderByWithRelationInput | WarehouseSimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseSims.
     */
    cursor?: WarehouseSimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseSims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseSims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseSims.
     */
    distinct?: WarehouseSimScalarFieldEnum | WarehouseSimScalarFieldEnum[]
  }

  /**
   * WarehouseSim findFirstOrThrow
   */
  export type WarehouseSimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseSim to fetch.
     */
    where?: WarehouseSimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseSims to fetch.
     */
    orderBy?: WarehouseSimOrderByWithRelationInput | WarehouseSimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseSims.
     */
    cursor?: WarehouseSimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseSims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseSims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseSims.
     */
    distinct?: WarehouseSimScalarFieldEnum | WarehouseSimScalarFieldEnum[]
  }

  /**
   * WarehouseSim findMany
   */
  export type WarehouseSimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseSims to fetch.
     */
    where?: WarehouseSimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseSims to fetch.
     */
    orderBy?: WarehouseSimOrderByWithRelationInput | WarehouseSimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseSims.
     */
    cursor?: WarehouseSimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseSims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseSims.
     */
    skip?: number
    distinct?: WarehouseSimScalarFieldEnum | WarehouseSimScalarFieldEnum[]
  }

  /**
   * WarehouseSim create
   */
  export type WarehouseSimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseSim.
     */
    data: XOR<WarehouseSimCreateInput, WarehouseSimUncheckedCreateInput>
  }

  /**
   * WarehouseSim createMany
   */
  export type WarehouseSimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseSims.
     */
    data: WarehouseSimCreateManyInput | WarehouseSimCreateManyInput[]
  }

  /**
   * WarehouseSim createManyAndReturn
   */
  export type WarehouseSimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WarehouseSims.
     */
    data: WarehouseSimCreateManyInput | WarehouseSimCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseSim update
   */
  export type WarehouseSimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseSim.
     */
    data: XOR<WarehouseSimUpdateInput, WarehouseSimUncheckedUpdateInput>
    /**
     * Choose, which WarehouseSim to update.
     */
    where: WarehouseSimWhereUniqueInput
  }

  /**
   * WarehouseSim updateMany
   */
  export type WarehouseSimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseSims.
     */
    data: XOR<WarehouseSimUpdateManyMutationInput, WarehouseSimUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseSims to update
     */
    where?: WarehouseSimWhereInput
  }

  /**
   * WarehouseSim upsert
   */
  export type WarehouseSimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseSim to update in case it exists.
     */
    where: WarehouseSimWhereUniqueInput
    /**
     * In case the WarehouseSim found by the `where` argument doesn't exist, create a new WarehouseSim with this data.
     */
    create: XOR<WarehouseSimCreateInput, WarehouseSimUncheckedCreateInput>
    /**
     * In case the WarehouseSim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseSimUpdateInput, WarehouseSimUncheckedUpdateInput>
  }

  /**
   * WarehouseSim delete
   */
  export type WarehouseSimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
    /**
     * Filter which WarehouseSim to delete.
     */
    where: WarehouseSimWhereUniqueInput
  }

  /**
   * WarehouseSim deleteMany
   */
  export type WarehouseSimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseSims to delete
     */
    where?: WarehouseSimWhereInput
  }

  /**
   * WarehouseSim.branch
   */
  export type WarehouseSim$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * WarehouseSim without action
   */
  export type WarehouseSimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseSim
     */
    select?: WarehouseSimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseSimInclude<ExtArgs> | null
  }


  /**
   * Model SimMovementLog
   */

  export type AggregateSimMovementLog = {
    _count: SimMovementLogCountAggregateOutputType | null
    _min: SimMovementLogMinAggregateOutputType | null
    _max: SimMovementLogMaxAggregateOutputType | null
  }

  export type SimMovementLogMinAggregateOutputType = {
    id: string | null
    simId: string | null
    serialNumber: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type SimMovementLogMaxAggregateOutputType = {
    id: string | null
    simId: string | null
    serialNumber: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type SimMovementLogCountAggregateOutputType = {
    id: number
    simId: number
    serialNumber: number
    action: number
    details: number
    performedBy: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type SimMovementLogMinAggregateInputType = {
    id?: true
    simId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type SimMovementLogMaxAggregateInputType = {
    id?: true
    simId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
  }

  export type SimMovementLogCountAggregateInputType = {
    id?: true
    simId?: true
    serialNumber?: true
    action?: true
    details?: true
    performedBy?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type SimMovementLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimMovementLog to aggregate.
     */
    where?: SimMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimMovementLogs to fetch.
     */
    orderBy?: SimMovementLogOrderByWithRelationInput | SimMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimMovementLogs
    **/
    _count?: true | SimMovementLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimMovementLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimMovementLogMaxAggregateInputType
  }

  export type GetSimMovementLogAggregateType<T extends SimMovementLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSimMovementLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimMovementLog[P]>
      : GetScalarType<T[P], AggregateSimMovementLog[P]>
  }




  export type SimMovementLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimMovementLogWhereInput
    orderBy?: SimMovementLogOrderByWithAggregationInput | SimMovementLogOrderByWithAggregationInput[]
    by: SimMovementLogScalarFieldEnum[] | SimMovementLogScalarFieldEnum
    having?: SimMovementLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimMovementLogCountAggregateInputType | true
    _min?: SimMovementLogMinAggregateInputType
    _max?: SimMovementLogMaxAggregateInputType
  }

  export type SimMovementLogGroupByOutputType = {
    id: string
    simId: string
    serialNumber: string
    action: string
    details: string | null
    performedBy: string | null
    branchId: string | null
    createdAt: Date
    _count: SimMovementLogCountAggregateOutputType | null
    _min: SimMovementLogMinAggregateOutputType | null
    _max: SimMovementLogMaxAggregateOutputType | null
  }

  type GetSimMovementLogGroupByPayload<T extends SimMovementLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimMovementLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimMovementLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimMovementLogGroupByOutputType[P]>
            : GetScalarType<T[P], SimMovementLogGroupByOutputType[P]>
        }
      >
    >


  export type SimMovementLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | SimMovementLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["simMovementLog"]>

  export type SimMovementLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | SimMovementLog$branchArgs<ExtArgs>
  }, ExtArgs["result"]["simMovementLog"]>

  export type SimMovementLogSelectScalar = {
    id?: boolean
    simId?: boolean
    serialNumber?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type SimMovementLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | SimMovementLog$branchArgs<ExtArgs>
  }
  export type SimMovementLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | SimMovementLog$branchArgs<ExtArgs>
  }

  export type $SimMovementLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimMovementLog"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simId: string
      serialNumber: string
      action: string
      details: string | null
      performedBy: string | null
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["simMovementLog"]>
    composites: {}
  }

  type SimMovementLogGetPayload<S extends boolean | null | undefined | SimMovementLogDefaultArgs> = $Result.GetResult<Prisma.$SimMovementLogPayload, S>

  type SimMovementLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimMovementLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimMovementLogCountAggregateInputType | true
    }

  export interface SimMovementLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimMovementLog'], meta: { name: 'SimMovementLog' } }
    /**
     * Find zero or one SimMovementLog that matches the filter.
     * @param {SimMovementLogFindUniqueArgs} args - Arguments to find a SimMovementLog
     * @example
     * // Get one SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimMovementLogFindUniqueArgs>(args: SelectSubset<T, SimMovementLogFindUniqueArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimMovementLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimMovementLogFindUniqueOrThrowArgs} args - Arguments to find a SimMovementLog
     * @example
     * // Get one SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimMovementLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SimMovementLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimMovementLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogFindFirstArgs} args - Arguments to find a SimMovementLog
     * @example
     * // Get one SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimMovementLogFindFirstArgs>(args?: SelectSubset<T, SimMovementLogFindFirstArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimMovementLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogFindFirstOrThrowArgs} args - Arguments to find a SimMovementLog
     * @example
     * // Get one SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimMovementLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SimMovementLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimMovementLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimMovementLogs
     * const simMovementLogs = await prisma.simMovementLog.findMany()
     * 
     * // Get first 10 SimMovementLogs
     * const simMovementLogs = await prisma.simMovementLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simMovementLogWithIdOnly = await prisma.simMovementLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimMovementLogFindManyArgs>(args?: SelectSubset<T, SimMovementLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimMovementLog.
     * @param {SimMovementLogCreateArgs} args - Arguments to create a SimMovementLog.
     * @example
     * // Create one SimMovementLog
     * const SimMovementLog = await prisma.simMovementLog.create({
     *   data: {
     *     // ... data to create a SimMovementLog
     *   }
     * })
     * 
     */
    create<T extends SimMovementLogCreateArgs>(args: SelectSubset<T, SimMovementLogCreateArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimMovementLogs.
     * @param {SimMovementLogCreateManyArgs} args - Arguments to create many SimMovementLogs.
     * @example
     * // Create many SimMovementLogs
     * const simMovementLog = await prisma.simMovementLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimMovementLogCreateManyArgs>(args?: SelectSubset<T, SimMovementLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimMovementLogs and returns the data saved in the database.
     * @param {SimMovementLogCreateManyAndReturnArgs} args - Arguments to create many SimMovementLogs.
     * @example
     * // Create many SimMovementLogs
     * const simMovementLog = await prisma.simMovementLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimMovementLogs and only return the `id`
     * const simMovementLogWithIdOnly = await prisma.simMovementLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimMovementLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SimMovementLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimMovementLog.
     * @param {SimMovementLogDeleteArgs} args - Arguments to delete one SimMovementLog.
     * @example
     * // Delete one SimMovementLog
     * const SimMovementLog = await prisma.simMovementLog.delete({
     *   where: {
     *     // ... filter to delete one SimMovementLog
     *   }
     * })
     * 
     */
    delete<T extends SimMovementLogDeleteArgs>(args: SelectSubset<T, SimMovementLogDeleteArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimMovementLog.
     * @param {SimMovementLogUpdateArgs} args - Arguments to update one SimMovementLog.
     * @example
     * // Update one SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimMovementLogUpdateArgs>(args: SelectSubset<T, SimMovementLogUpdateArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimMovementLogs.
     * @param {SimMovementLogDeleteManyArgs} args - Arguments to filter SimMovementLogs to delete.
     * @example
     * // Delete a few SimMovementLogs
     * const { count } = await prisma.simMovementLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimMovementLogDeleteManyArgs>(args?: SelectSubset<T, SimMovementLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimMovementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimMovementLogs
     * const simMovementLog = await prisma.simMovementLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimMovementLogUpdateManyArgs>(args: SelectSubset<T, SimMovementLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimMovementLog.
     * @param {SimMovementLogUpsertArgs} args - Arguments to update or create a SimMovementLog.
     * @example
     * // Update or create a SimMovementLog
     * const simMovementLog = await prisma.simMovementLog.upsert({
     *   create: {
     *     // ... data to create a SimMovementLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimMovementLog we want to update
     *   }
     * })
     */
    upsert<T extends SimMovementLogUpsertArgs>(args: SelectSubset<T, SimMovementLogUpsertArgs<ExtArgs>>): Prisma__SimMovementLogClient<$Result.GetResult<Prisma.$SimMovementLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimMovementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogCountArgs} args - Arguments to filter SimMovementLogs to count.
     * @example
     * // Count the number of SimMovementLogs
     * const count = await prisma.simMovementLog.count({
     *   where: {
     *     // ... the filter for the SimMovementLogs we want to count
     *   }
     * })
    **/
    count<T extends SimMovementLogCountArgs>(
      args?: Subset<T, SimMovementLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimMovementLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimMovementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimMovementLogAggregateArgs>(args: Subset<T, SimMovementLogAggregateArgs>): Prisma.PrismaPromise<GetSimMovementLogAggregateType<T>>

    /**
     * Group by SimMovementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimMovementLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimMovementLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimMovementLogGroupByArgs['orderBy'] }
        : { orderBy?: SimMovementLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimMovementLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimMovementLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimMovementLog model
   */
  readonly fields: SimMovementLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimMovementLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimMovementLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends SimMovementLog$branchArgs<ExtArgs> = {}>(args?: Subset<T, SimMovementLog$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimMovementLog model
   */ 
  interface SimMovementLogFieldRefs {
    readonly id: FieldRef<"SimMovementLog", 'String'>
    readonly simId: FieldRef<"SimMovementLog", 'String'>
    readonly serialNumber: FieldRef<"SimMovementLog", 'String'>
    readonly action: FieldRef<"SimMovementLog", 'String'>
    readonly details: FieldRef<"SimMovementLog", 'String'>
    readonly performedBy: FieldRef<"SimMovementLog", 'String'>
    readonly branchId: FieldRef<"SimMovementLog", 'String'>
    readonly createdAt: FieldRef<"SimMovementLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimMovementLog findUnique
   */
  export type SimMovementLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which SimMovementLog to fetch.
     */
    where: SimMovementLogWhereUniqueInput
  }

  /**
   * SimMovementLog findUniqueOrThrow
   */
  export type SimMovementLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which SimMovementLog to fetch.
     */
    where: SimMovementLogWhereUniqueInput
  }

  /**
   * SimMovementLog findFirst
   */
  export type SimMovementLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which SimMovementLog to fetch.
     */
    where?: SimMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimMovementLogs to fetch.
     */
    orderBy?: SimMovementLogOrderByWithRelationInput | SimMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimMovementLogs.
     */
    cursor?: SimMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimMovementLogs.
     */
    distinct?: SimMovementLogScalarFieldEnum | SimMovementLogScalarFieldEnum[]
  }

  /**
   * SimMovementLog findFirstOrThrow
   */
  export type SimMovementLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which SimMovementLog to fetch.
     */
    where?: SimMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimMovementLogs to fetch.
     */
    orderBy?: SimMovementLogOrderByWithRelationInput | SimMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimMovementLogs.
     */
    cursor?: SimMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimMovementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimMovementLogs.
     */
    distinct?: SimMovementLogScalarFieldEnum | SimMovementLogScalarFieldEnum[]
  }

  /**
   * SimMovementLog findMany
   */
  export type SimMovementLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter, which SimMovementLogs to fetch.
     */
    where?: SimMovementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimMovementLogs to fetch.
     */
    orderBy?: SimMovementLogOrderByWithRelationInput | SimMovementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimMovementLogs.
     */
    cursor?: SimMovementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimMovementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimMovementLogs.
     */
    skip?: number
    distinct?: SimMovementLogScalarFieldEnum | SimMovementLogScalarFieldEnum[]
  }

  /**
   * SimMovementLog create
   */
  export type SimMovementLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SimMovementLog.
     */
    data: XOR<SimMovementLogCreateInput, SimMovementLogUncheckedCreateInput>
  }

  /**
   * SimMovementLog createMany
   */
  export type SimMovementLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimMovementLogs.
     */
    data: SimMovementLogCreateManyInput | SimMovementLogCreateManyInput[]
  }

  /**
   * SimMovementLog createManyAndReturn
   */
  export type SimMovementLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimMovementLogs.
     */
    data: SimMovementLogCreateManyInput | SimMovementLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimMovementLog update
   */
  export type SimMovementLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SimMovementLog.
     */
    data: XOR<SimMovementLogUpdateInput, SimMovementLogUncheckedUpdateInput>
    /**
     * Choose, which SimMovementLog to update.
     */
    where: SimMovementLogWhereUniqueInput
  }

  /**
   * SimMovementLog updateMany
   */
  export type SimMovementLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimMovementLogs.
     */
    data: XOR<SimMovementLogUpdateManyMutationInput, SimMovementLogUncheckedUpdateManyInput>
    /**
     * Filter which SimMovementLogs to update
     */
    where?: SimMovementLogWhereInput
  }

  /**
   * SimMovementLog upsert
   */
  export type SimMovementLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SimMovementLog to update in case it exists.
     */
    where: SimMovementLogWhereUniqueInput
    /**
     * In case the SimMovementLog found by the `where` argument doesn't exist, create a new SimMovementLog with this data.
     */
    create: XOR<SimMovementLogCreateInput, SimMovementLogUncheckedCreateInput>
    /**
     * In case the SimMovementLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimMovementLogUpdateInput, SimMovementLogUncheckedUpdateInput>
  }

  /**
   * SimMovementLog delete
   */
  export type SimMovementLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
    /**
     * Filter which SimMovementLog to delete.
     */
    where: SimMovementLogWhereUniqueInput
  }

  /**
   * SimMovementLog deleteMany
   */
  export type SimMovementLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimMovementLogs to delete
     */
    where?: SimMovementLogWhereInput
  }

  /**
   * SimMovementLog.branch
   */
  export type SimMovementLog$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * SimMovementLog without action
   */
  export type SimMovementLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimMovementLog
     */
    select?: SimMovementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimMovementLogInclude<ExtArgs> | null
  }


  /**
   * Model TransferOrder
   */

  export type AggregateTransferOrder = {
    _count: TransferOrderCountAggregateOutputType | null
    _min: TransferOrderMinAggregateOutputType | null
    _max: TransferOrderMaxAggregateOutputType | null
  }

  export type TransferOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    waybillNumber: string | null
    branchId: string | null
    fromBranchId: string | null
    toBranchId: string | null
    status: string | null
    type: string | null
    driverName: string | null
    driverPhone: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    createdByUserId: string | null
    receivedByUserId: string | null
    receivedAt: Date | null
    receivedBy: string | null
    receivedByName: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    waybillNumber: string | null
    branchId: string | null
    fromBranchId: string | null
    toBranchId: string | null
    status: string | null
    type: string | null
    driverName: string | null
    driverPhone: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    createdByUserId: string | null
    receivedByUserId: string | null
    receivedAt: Date | null
    receivedBy: string | null
    receivedByName: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    waybillNumber: number
    branchId: number
    fromBranchId: number
    toBranchId: number
    status: number
    type: number
    driverName: number
    driverPhone: number
    notes: number
    createdBy: number
    createdByName: number
    createdByUserId: number
    receivedByUserId: number
    receivedAt: number
    receivedBy: number
    receivedByName: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    waybillNumber?: true
    branchId?: true
    fromBranchId?: true
    toBranchId?: true
    status?: true
    type?: true
    driverName?: true
    driverPhone?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    createdByUserId?: true
    receivedByUserId?: true
    receivedAt?: true
    receivedBy?: true
    receivedByName?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    waybillNumber?: true
    branchId?: true
    fromBranchId?: true
    toBranchId?: true
    status?: true
    type?: true
    driverName?: true
    driverPhone?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    createdByUserId?: true
    receivedByUserId?: true
    receivedAt?: true
    receivedBy?: true
    receivedByName?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    waybillNumber?: true
    branchId?: true
    fromBranchId?: true
    toBranchId?: true
    status?: true
    type?: true
    driverName?: true
    driverPhone?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    createdByUserId?: true
    receivedByUserId?: true
    receivedAt?: true
    receivedBy?: true
    receivedByName?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrder to aggregate.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferOrders
    **/
    _count?: true | TransferOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferOrderMaxAggregateInputType
  }

  export type GetTransferOrderAggregateType<T extends TransferOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferOrder[P]>
      : GetScalarType<T[P], AggregateTransferOrder[P]>
  }




  export type TransferOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithAggregationInput | TransferOrderOrderByWithAggregationInput[]
    by: TransferOrderScalarFieldEnum[] | TransferOrderScalarFieldEnum
    having?: TransferOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferOrderCountAggregateInputType | true
    _min?: TransferOrderMinAggregateInputType
    _max?: TransferOrderMaxAggregateInputType
  }

  export type TransferOrderGroupByOutputType = {
    id: string
    orderNumber: string
    waybillNumber: string | null
    branchId: string | null
    fromBranchId: string
    toBranchId: string
    status: string
    type: string
    driverName: string | null
    driverPhone: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    createdByUserId: string | null
    receivedByUserId: string | null
    receivedAt: Date | null
    receivedBy: string | null
    receivedByName: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferOrderCountAggregateOutputType | null
    _min: TransferOrderMinAggregateOutputType | null
    _max: TransferOrderMaxAggregateOutputType | null
  }

  type GetTransferOrderGroupByPayload<T extends TransferOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferOrderGroupByOutputType[P]>
            : GetScalarType<T[P], TransferOrderGroupByOutputType[P]>
        }
      >
    >


  export type TransferOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    waybillNumber?: boolean
    branchId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    status?: boolean
    type?: boolean
    driverName?: boolean
    driverPhone?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    createdByUserId?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    receivedByName?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    items?: boolean | TransferOrder$itemsArgs<ExtArgs>
    _count?: boolean | TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrder"]>

  export type TransferOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    waybillNumber?: boolean
    branchId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    status?: boolean
    type?: boolean
    driverName?: boolean
    driverPhone?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    createdByUserId?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    receivedByName?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrder"]>

  export type TransferOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    waybillNumber?: boolean
    branchId?: boolean
    fromBranchId?: boolean
    toBranchId?: boolean
    status?: boolean
    type?: boolean
    driverName?: boolean
    driverPhone?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    createdByUserId?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    receivedByName?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
    items?: boolean | TransferOrder$itemsArgs<ExtArgs>
    _count?: boolean | TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toBranch?: boolean | BranchDefaultArgs<ExtArgs>
    fromBranch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $TransferOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferOrder"
    objects: {
      toBranch: Prisma.$BranchPayload<ExtArgs>
      fromBranch: Prisma.$BranchPayload<ExtArgs>
      items: Prisma.$TransferOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      waybillNumber: string | null
      branchId: string | null
      fromBranchId: string
      toBranchId: string
      status: string
      type: string
      driverName: string | null
      driverPhone: string | null
      notes: string | null
      createdBy: string | null
      createdByName: string | null
      createdByUserId: string | null
      receivedByUserId: string | null
      receivedAt: Date | null
      receivedBy: string | null
      receivedByName: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferOrder"]>
    composites: {}
  }

  type TransferOrderGetPayload<S extends boolean | null | undefined | TransferOrderDefaultArgs> = $Result.GetResult<Prisma.$TransferOrderPayload, S>

  type TransferOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferOrderCountAggregateInputType | true
    }

  export interface TransferOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferOrder'], meta: { name: 'TransferOrder' } }
    /**
     * Find zero or one TransferOrder that matches the filter.
     * @param {TransferOrderFindUniqueArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferOrderFindUniqueArgs>(args: SelectSubset<T, TransferOrderFindUniqueArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransferOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferOrderFindUniqueOrThrowArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransferOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindFirstArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferOrderFindFirstArgs>(args?: SelectSubset<T, TransferOrderFindFirstArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransferOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindFirstOrThrowArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransferOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferOrders
     * const transferOrders = await prisma.transferOrder.findMany()
     * 
     * // Get first 10 TransferOrders
     * const transferOrders = await prisma.transferOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferOrderWithIdOnly = await prisma.transferOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferOrderFindManyArgs>(args?: SelectSubset<T, TransferOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransferOrder.
     * @param {TransferOrderCreateArgs} args - Arguments to create a TransferOrder.
     * @example
     * // Create one TransferOrder
     * const TransferOrder = await prisma.transferOrder.create({
     *   data: {
     *     // ... data to create a TransferOrder
     *   }
     * })
     * 
     */
    create<T extends TransferOrderCreateArgs>(args: SelectSubset<T, TransferOrderCreateArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransferOrders.
     * @param {TransferOrderCreateManyArgs} args - Arguments to create many TransferOrders.
     * @example
     * // Create many TransferOrders
     * const transferOrder = await prisma.transferOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferOrderCreateManyArgs>(args?: SelectSubset<T, TransferOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferOrders and returns the data saved in the database.
     * @param {TransferOrderCreateManyAndReturnArgs} args - Arguments to create many TransferOrders.
     * @example
     * // Create many TransferOrders
     * const transferOrder = await prisma.transferOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferOrders and only return the `id`
     * const transferOrderWithIdOnly = await prisma.transferOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransferOrder.
     * @param {TransferOrderDeleteArgs} args - Arguments to delete one TransferOrder.
     * @example
     * // Delete one TransferOrder
     * const TransferOrder = await prisma.transferOrder.delete({
     *   where: {
     *     // ... filter to delete one TransferOrder
     *   }
     * })
     * 
     */
    delete<T extends TransferOrderDeleteArgs>(args: SelectSubset<T, TransferOrderDeleteArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransferOrder.
     * @param {TransferOrderUpdateArgs} args - Arguments to update one TransferOrder.
     * @example
     * // Update one TransferOrder
     * const transferOrder = await prisma.transferOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferOrderUpdateArgs>(args: SelectSubset<T, TransferOrderUpdateArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransferOrders.
     * @param {TransferOrderDeleteManyArgs} args - Arguments to filter TransferOrders to delete.
     * @example
     * // Delete a few TransferOrders
     * const { count } = await prisma.transferOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferOrderDeleteManyArgs>(args?: SelectSubset<T, TransferOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferOrders
     * const transferOrder = await prisma.transferOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferOrderUpdateManyArgs>(args: SelectSubset<T, TransferOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferOrder.
     * @param {TransferOrderUpsertArgs} args - Arguments to update or create a TransferOrder.
     * @example
     * // Update or create a TransferOrder
     * const transferOrder = await prisma.transferOrder.upsert({
     *   create: {
     *     // ... data to create a TransferOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferOrder we want to update
     *   }
     * })
     */
    upsert<T extends TransferOrderUpsertArgs>(args: SelectSubset<T, TransferOrderUpsertArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransferOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderCountArgs} args - Arguments to filter TransferOrders to count.
     * @example
     * // Count the number of TransferOrders
     * const count = await prisma.transferOrder.count({
     *   where: {
     *     // ... the filter for the TransferOrders we want to count
     *   }
     * })
    **/
    count<T extends TransferOrderCountArgs>(
      args?: Subset<T, TransferOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferOrderAggregateArgs>(args: Subset<T, TransferOrderAggregateArgs>): Prisma.PrismaPromise<GetTransferOrderAggregateType<T>>

    /**
     * Group by TransferOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferOrderGroupByArgs['orderBy'] }
        : { orderBy?: TransferOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferOrder model
   */
  readonly fields: TransferOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends TransferOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TransferOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferOrder model
   */ 
  interface TransferOrderFieldRefs {
    readonly id: FieldRef<"TransferOrder", 'String'>
    readonly orderNumber: FieldRef<"TransferOrder", 'String'>
    readonly waybillNumber: FieldRef<"TransferOrder", 'String'>
    readonly branchId: FieldRef<"TransferOrder", 'String'>
    readonly fromBranchId: FieldRef<"TransferOrder", 'String'>
    readonly toBranchId: FieldRef<"TransferOrder", 'String'>
    readonly status: FieldRef<"TransferOrder", 'String'>
    readonly type: FieldRef<"TransferOrder", 'String'>
    readonly driverName: FieldRef<"TransferOrder", 'String'>
    readonly driverPhone: FieldRef<"TransferOrder", 'String'>
    readonly notes: FieldRef<"TransferOrder", 'String'>
    readonly createdBy: FieldRef<"TransferOrder", 'String'>
    readonly createdByName: FieldRef<"TransferOrder", 'String'>
    readonly createdByUserId: FieldRef<"TransferOrder", 'String'>
    readonly receivedByUserId: FieldRef<"TransferOrder", 'String'>
    readonly receivedAt: FieldRef<"TransferOrder", 'DateTime'>
    readonly receivedBy: FieldRef<"TransferOrder", 'String'>
    readonly receivedByName: FieldRef<"TransferOrder", 'String'>
    readonly rejectionReason: FieldRef<"TransferOrder", 'String'>
    readonly createdAt: FieldRef<"TransferOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferOrder findUnique
   */
  export type TransferOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder findUniqueOrThrow
   */
  export type TransferOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder findFirst
   */
  export type TransferOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrders.
     */
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder findFirstOrThrow
   */
  export type TransferOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrders.
     */
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder findMany
   */
  export type TransferOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrders to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder create
   */
  export type TransferOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferOrder.
     */
    data: XOR<TransferOrderCreateInput, TransferOrderUncheckedCreateInput>
  }

  /**
   * TransferOrder createMany
   */
  export type TransferOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferOrders.
     */
    data: TransferOrderCreateManyInput | TransferOrderCreateManyInput[]
  }

  /**
   * TransferOrder createManyAndReturn
   */
  export type TransferOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransferOrders.
     */
    data: TransferOrderCreateManyInput | TransferOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferOrder update
   */
  export type TransferOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferOrder.
     */
    data: XOR<TransferOrderUpdateInput, TransferOrderUncheckedUpdateInput>
    /**
     * Choose, which TransferOrder to update.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder updateMany
   */
  export type TransferOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferOrders.
     */
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyInput>
    /**
     * Filter which TransferOrders to update
     */
    where?: TransferOrderWhereInput
  }

  /**
   * TransferOrder upsert
   */
  export type TransferOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferOrder to update in case it exists.
     */
    where: TransferOrderWhereUniqueInput
    /**
     * In case the TransferOrder found by the `where` argument doesn't exist, create a new TransferOrder with this data.
     */
    create: XOR<TransferOrderCreateInput, TransferOrderUncheckedCreateInput>
    /**
     * In case the TransferOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferOrderUpdateInput, TransferOrderUncheckedUpdateInput>
  }

  /**
   * TransferOrder delete
   */
  export type TransferOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter which TransferOrder to delete.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder deleteMany
   */
  export type TransferOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrders to delete
     */
    where?: TransferOrderWhereInput
  }

  /**
   * TransferOrder.items
   */
  export type TransferOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    where?: TransferOrderItemWhereInput
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    cursor?: TransferOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrder without action
   */
  export type TransferOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
  }


  /**
   * Model TransferOrderItem
   */

  export type AggregateTransferOrderItem = {
    _count: TransferOrderItemCountAggregateOutputType | null
    _min: TransferOrderItemMinAggregateOutputType | null
    _max: TransferOrderItemMaxAggregateOutputType | null
  }

  export type TransferOrderItemMinAggregateOutputType = {
    id: string | null
    transferOrderId: string | null
    serialNumber: string | null
    type: string | null
    model: string | null
    manufacturer: string | null
    isReceived: boolean | null
    receivedAt: Date | null
    notes: string | null
  }

  export type TransferOrderItemMaxAggregateOutputType = {
    id: string | null
    transferOrderId: string | null
    serialNumber: string | null
    type: string | null
    model: string | null
    manufacturer: string | null
    isReceived: boolean | null
    receivedAt: Date | null
    notes: string | null
  }

  export type TransferOrderItemCountAggregateOutputType = {
    id: number
    transferOrderId: number
    serialNumber: number
    type: number
    model: number
    manufacturer: number
    isReceived: number
    receivedAt: number
    notes: number
    _all: number
  }


  export type TransferOrderItemMinAggregateInputType = {
    id?: true
    transferOrderId?: true
    serialNumber?: true
    type?: true
    model?: true
    manufacturer?: true
    isReceived?: true
    receivedAt?: true
    notes?: true
  }

  export type TransferOrderItemMaxAggregateInputType = {
    id?: true
    transferOrderId?: true
    serialNumber?: true
    type?: true
    model?: true
    manufacturer?: true
    isReceived?: true
    receivedAt?: true
    notes?: true
  }

  export type TransferOrderItemCountAggregateInputType = {
    id?: true
    transferOrderId?: true
    serialNumber?: true
    type?: true
    model?: true
    manufacturer?: true
    isReceived?: true
    receivedAt?: true
    notes?: true
    _all?: true
  }

  export type TransferOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrderItem to aggregate.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferOrderItems
    **/
    _count?: true | TransferOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferOrderItemMaxAggregateInputType
  }

  export type GetTransferOrderItemAggregateType<T extends TransferOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferOrderItem[P]>
      : GetScalarType<T[P], AggregateTransferOrderItem[P]>
  }




  export type TransferOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderItemWhereInput
    orderBy?: TransferOrderItemOrderByWithAggregationInput | TransferOrderItemOrderByWithAggregationInput[]
    by: TransferOrderItemScalarFieldEnum[] | TransferOrderItemScalarFieldEnum
    having?: TransferOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferOrderItemCountAggregateInputType | true
    _min?: TransferOrderItemMinAggregateInputType
    _max?: TransferOrderItemMaxAggregateInputType
  }

  export type TransferOrderItemGroupByOutputType = {
    id: string
    transferOrderId: string
    serialNumber: string | null
    type: string | null
    model: string | null
    manufacturer: string | null
    isReceived: boolean
    receivedAt: Date | null
    notes: string | null
    _count: TransferOrderItemCountAggregateOutputType | null
    _min: TransferOrderItemMinAggregateOutputType | null
    _max: TransferOrderItemMaxAggregateOutputType | null
  }

  type GetTransferOrderItemGroupByPayload<T extends TransferOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransferOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type TransferOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferOrderId?: boolean
    serialNumber?: boolean
    type?: boolean
    model?: boolean
    manufacturer?: boolean
    isReceived?: boolean
    receivedAt?: boolean
    notes?: boolean
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrderItem"]>

  export type TransferOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferOrderId?: boolean
    serialNumber?: boolean
    type?: boolean
    model?: boolean
    manufacturer?: boolean
    isReceived?: boolean
    receivedAt?: boolean
    notes?: boolean
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrderItem"]>

  export type TransferOrderItemSelectScalar = {
    id?: boolean
    transferOrderId?: boolean
    serialNumber?: boolean
    type?: boolean
    model?: boolean
    manufacturer?: boolean
    isReceived?: boolean
    receivedAt?: boolean
    notes?: boolean
  }

  export type TransferOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
  }
  export type TransferOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
  }

  export type $TransferOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferOrderItem"
    objects: {
      transferOrder: Prisma.$TransferOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferOrderId: string
      serialNumber: string | null
      type: string | null
      model: string | null
      manufacturer: string | null
      isReceived: boolean
      receivedAt: Date | null
      notes: string | null
    }, ExtArgs["result"]["transferOrderItem"]>
    composites: {}
  }

  type TransferOrderItemGetPayload<S extends boolean | null | undefined | TransferOrderItemDefaultArgs> = $Result.GetResult<Prisma.$TransferOrderItemPayload, S>

  type TransferOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferOrderItemCountAggregateInputType | true
    }

  export interface TransferOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferOrderItem'], meta: { name: 'TransferOrderItem' } }
    /**
     * Find zero or one TransferOrderItem that matches the filter.
     * @param {TransferOrderItemFindUniqueArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferOrderItemFindUniqueArgs>(args: SelectSubset<T, TransferOrderItemFindUniqueArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransferOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferOrderItemFindUniqueOrThrowArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransferOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindFirstArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferOrderItemFindFirstArgs>(args?: SelectSubset<T, TransferOrderItemFindFirstArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransferOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindFirstOrThrowArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransferOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferOrderItems
     * const transferOrderItems = await prisma.transferOrderItem.findMany()
     * 
     * // Get first 10 TransferOrderItems
     * const transferOrderItems = await prisma.transferOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferOrderItemWithIdOnly = await prisma.transferOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferOrderItemFindManyArgs>(args?: SelectSubset<T, TransferOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransferOrderItem.
     * @param {TransferOrderItemCreateArgs} args - Arguments to create a TransferOrderItem.
     * @example
     * // Create one TransferOrderItem
     * const TransferOrderItem = await prisma.transferOrderItem.create({
     *   data: {
     *     // ... data to create a TransferOrderItem
     *   }
     * })
     * 
     */
    create<T extends TransferOrderItemCreateArgs>(args: SelectSubset<T, TransferOrderItemCreateArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransferOrderItems.
     * @param {TransferOrderItemCreateManyArgs} args - Arguments to create many TransferOrderItems.
     * @example
     * // Create many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferOrderItemCreateManyArgs>(args?: SelectSubset<T, TransferOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferOrderItems and returns the data saved in the database.
     * @param {TransferOrderItemCreateManyAndReturnArgs} args - Arguments to create many TransferOrderItems.
     * @example
     * // Create many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferOrderItems and only return the `id`
     * const transferOrderItemWithIdOnly = await prisma.transferOrderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransferOrderItem.
     * @param {TransferOrderItemDeleteArgs} args - Arguments to delete one TransferOrderItem.
     * @example
     * // Delete one TransferOrderItem
     * const TransferOrderItem = await prisma.transferOrderItem.delete({
     *   where: {
     *     // ... filter to delete one TransferOrderItem
     *   }
     * })
     * 
     */
    delete<T extends TransferOrderItemDeleteArgs>(args: SelectSubset<T, TransferOrderItemDeleteArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransferOrderItem.
     * @param {TransferOrderItemUpdateArgs} args - Arguments to update one TransferOrderItem.
     * @example
     * // Update one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferOrderItemUpdateArgs>(args: SelectSubset<T, TransferOrderItemUpdateArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransferOrderItems.
     * @param {TransferOrderItemDeleteManyArgs} args - Arguments to filter TransferOrderItems to delete.
     * @example
     * // Delete a few TransferOrderItems
     * const { count } = await prisma.transferOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferOrderItemDeleteManyArgs>(args?: SelectSubset<T, TransferOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferOrderItemUpdateManyArgs>(args: SelectSubset<T, TransferOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferOrderItem.
     * @param {TransferOrderItemUpsertArgs} args - Arguments to update or create a TransferOrderItem.
     * @example
     * // Update or create a TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.upsert({
     *   create: {
     *     // ... data to create a TransferOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends TransferOrderItemUpsertArgs>(args: SelectSubset<T, TransferOrderItemUpsertArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransferOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemCountArgs} args - Arguments to filter TransferOrderItems to count.
     * @example
     * // Count the number of TransferOrderItems
     * const count = await prisma.transferOrderItem.count({
     *   where: {
     *     // ... the filter for the TransferOrderItems we want to count
     *   }
     * })
    **/
    count<T extends TransferOrderItemCountArgs>(
      args?: Subset<T, TransferOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferOrderItemAggregateArgs>(args: Subset<T, TransferOrderItemAggregateArgs>): Prisma.PrismaPromise<GetTransferOrderItemAggregateType<T>>

    /**
     * Group by TransferOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: TransferOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferOrderItem model
   */
  readonly fields: TransferOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transferOrder<T extends TransferOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferOrderDefaultArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferOrderItem model
   */ 
  interface TransferOrderItemFieldRefs {
    readonly id: FieldRef<"TransferOrderItem", 'String'>
    readonly transferOrderId: FieldRef<"TransferOrderItem", 'String'>
    readonly serialNumber: FieldRef<"TransferOrderItem", 'String'>
    readonly type: FieldRef<"TransferOrderItem", 'String'>
    readonly model: FieldRef<"TransferOrderItem", 'String'>
    readonly manufacturer: FieldRef<"TransferOrderItem", 'String'>
    readonly isReceived: FieldRef<"TransferOrderItem", 'Boolean'>
    readonly receivedAt: FieldRef<"TransferOrderItem", 'DateTime'>
    readonly notes: FieldRef<"TransferOrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransferOrderItem findUnique
   */
  export type TransferOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem findUniqueOrThrow
   */
  export type TransferOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem findFirst
   */
  export type TransferOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrderItems.
     */
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem findFirstOrThrow
   */
  export type TransferOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrderItems.
     */
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem findMany
   */
  export type TransferOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItems to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem create
   */
  export type TransferOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferOrderItem.
     */
    data: XOR<TransferOrderItemCreateInput, TransferOrderItemUncheckedCreateInput>
  }

  /**
   * TransferOrderItem createMany
   */
  export type TransferOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferOrderItems.
     */
    data: TransferOrderItemCreateManyInput | TransferOrderItemCreateManyInput[]
  }

  /**
   * TransferOrderItem createManyAndReturn
   */
  export type TransferOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransferOrderItems.
     */
    data: TransferOrderItemCreateManyInput | TransferOrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferOrderItem update
   */
  export type TransferOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferOrderItem.
     */
    data: XOR<TransferOrderItemUpdateInput, TransferOrderItemUncheckedUpdateInput>
    /**
     * Choose, which TransferOrderItem to update.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem updateMany
   */
  export type TransferOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferOrderItems.
     */
    data: XOR<TransferOrderItemUpdateManyMutationInput, TransferOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferOrderItems to update
     */
    where?: TransferOrderItemWhereInput
  }

  /**
   * TransferOrderItem upsert
   */
  export type TransferOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferOrderItem to update in case it exists.
     */
    where: TransferOrderItemWhereUniqueInput
    /**
     * In case the TransferOrderItem found by the `where` argument doesn't exist, create a new TransferOrderItem with this data.
     */
    create: XOR<TransferOrderItemCreateInput, TransferOrderItemUncheckedCreateInput>
    /**
     * In case the TransferOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferOrderItemUpdateInput, TransferOrderItemUncheckedUpdateInput>
  }

  /**
   * TransferOrderItem delete
   */
  export type TransferOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter which TransferOrderItem to delete.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem deleteMany
   */
  export type TransferOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrderItems to delete
     */
    where?: TransferOrderItemWhereInput
  }

  /**
   * TransferOrderItem without action
   */
  export type TransferOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceApproval
   */

  export type AggregateMaintenanceApproval = {
    _count: MaintenanceApprovalCountAggregateOutputType | null
    _avg: MaintenanceApprovalAvgAggregateOutputType | null
    _sum: MaintenanceApprovalSumAggregateOutputType | null
    _min: MaintenanceApprovalMinAggregateOutputType | null
    _max: MaintenanceApprovalMaxAggregateOutputType | null
  }

  export type MaintenanceApprovalAvgAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceApprovalSumAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceApprovalMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    cost: number | null
    parts: string | null
    status: string | null
    notes: string | null
    branchId: string | null
    createdAt: Date | null
    respondedAt: Date | null
    respondedBy: string | null
  }

  export type MaintenanceApprovalMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    cost: number | null
    parts: string | null
    status: string | null
    notes: string | null
    branchId: string | null
    createdAt: Date | null
    respondedAt: Date | null
    respondedBy: string | null
  }

  export type MaintenanceApprovalCountAggregateOutputType = {
    id: number
    requestId: number
    cost: number
    parts: number
    status: number
    notes: number
    branchId: number
    createdAt: number
    respondedAt: number
    respondedBy: number
    _all: number
  }


  export type MaintenanceApprovalAvgAggregateInputType = {
    cost?: true
  }

  export type MaintenanceApprovalSumAggregateInputType = {
    cost?: true
  }

  export type MaintenanceApprovalMinAggregateInputType = {
    id?: true
    requestId?: true
    cost?: true
    parts?: true
    status?: true
    notes?: true
    branchId?: true
    createdAt?: true
    respondedAt?: true
    respondedBy?: true
  }

  export type MaintenanceApprovalMaxAggregateInputType = {
    id?: true
    requestId?: true
    cost?: true
    parts?: true
    status?: true
    notes?: true
    branchId?: true
    createdAt?: true
    respondedAt?: true
    respondedBy?: true
  }

  export type MaintenanceApprovalCountAggregateInputType = {
    id?: true
    requestId?: true
    cost?: true
    parts?: true
    status?: true
    notes?: true
    branchId?: true
    createdAt?: true
    respondedAt?: true
    respondedBy?: true
    _all?: true
  }

  export type MaintenanceApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceApproval to aggregate.
     */
    where?: MaintenanceApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovals to fetch.
     */
    orderBy?: MaintenanceApprovalOrderByWithRelationInput | MaintenanceApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceApprovals
    **/
    _count?: true | MaintenanceApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceApprovalMaxAggregateInputType
  }

  export type GetMaintenanceApprovalAggregateType<T extends MaintenanceApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceApproval[P]>
      : GetScalarType<T[P], AggregateMaintenanceApproval[P]>
  }




  export type MaintenanceApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceApprovalWhereInput
    orderBy?: MaintenanceApprovalOrderByWithAggregationInput | MaintenanceApprovalOrderByWithAggregationInput[]
    by: MaintenanceApprovalScalarFieldEnum[] | MaintenanceApprovalScalarFieldEnum
    having?: MaintenanceApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceApprovalCountAggregateInputType | true
    _avg?: MaintenanceApprovalAvgAggregateInputType
    _sum?: MaintenanceApprovalSumAggregateInputType
    _min?: MaintenanceApprovalMinAggregateInputType
    _max?: MaintenanceApprovalMaxAggregateInputType
  }

  export type MaintenanceApprovalGroupByOutputType = {
    id: string
    requestId: string
    cost: number
    parts: string
    status: string
    notes: string | null
    branchId: string | null
    createdAt: Date
    respondedAt: Date | null
    respondedBy: string | null
    _count: MaintenanceApprovalCountAggregateOutputType | null
    _avg: MaintenanceApprovalAvgAggregateOutputType | null
    _sum: MaintenanceApprovalSumAggregateOutputType | null
    _min: MaintenanceApprovalMinAggregateOutputType | null
    _max: MaintenanceApprovalMaxAggregateOutputType | null
  }

  type GetMaintenanceApprovalGroupByPayload<T extends MaintenanceApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceApprovalGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    cost?: boolean
    parts?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    branch?: boolean | MaintenanceApproval$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceApproval"]>

  export type MaintenanceApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    cost?: boolean
    parts?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    branch?: boolean | MaintenanceApproval$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceApproval"]>

  export type MaintenanceApprovalSelectScalar = {
    id?: boolean
    requestId?: boolean
    cost?: boolean
    parts?: boolean
    status?: boolean
    notes?: boolean
    branchId?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
  }

  export type MaintenanceApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | MaintenanceApproval$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }
  export type MaintenanceApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | MaintenanceApproval$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }

  export type $MaintenanceApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceApproval"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      request: Prisma.$MaintenanceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      cost: number
      parts: string
      status: string
      notes: string | null
      branchId: string | null
      createdAt: Date
      respondedAt: Date | null
      respondedBy: string | null
    }, ExtArgs["result"]["maintenanceApproval"]>
    composites: {}
  }

  type MaintenanceApprovalGetPayload<S extends boolean | null | undefined | MaintenanceApprovalDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceApprovalPayload, S>

  type MaintenanceApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceApprovalCountAggregateInputType | true
    }

  export interface MaintenanceApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceApproval'], meta: { name: 'MaintenanceApproval' } }
    /**
     * Find zero or one MaintenanceApproval that matches the filter.
     * @param {MaintenanceApprovalFindUniqueArgs} args - Arguments to find a MaintenanceApproval
     * @example
     * // Get one MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceApprovalFindUniqueArgs>(args: SelectSubset<T, MaintenanceApprovalFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceApprovalFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceApproval
     * @example
     * // Get one MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalFindFirstArgs} args - Arguments to find a MaintenanceApproval
     * @example
     * // Get one MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceApprovalFindFirstArgs>(args?: SelectSubset<T, MaintenanceApprovalFindFirstArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalFindFirstOrThrowArgs} args - Arguments to find a MaintenanceApproval
     * @example
     * // Get one MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceApprovals
     * const maintenanceApprovals = await prisma.maintenanceApproval.findMany()
     * 
     * // Get first 10 MaintenanceApprovals
     * const maintenanceApprovals = await prisma.maintenanceApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceApprovalWithIdOnly = await prisma.maintenanceApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceApprovalFindManyArgs>(args?: SelectSubset<T, MaintenanceApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceApproval.
     * @param {MaintenanceApprovalCreateArgs} args - Arguments to create a MaintenanceApproval.
     * @example
     * // Create one MaintenanceApproval
     * const MaintenanceApproval = await prisma.maintenanceApproval.create({
     *   data: {
     *     // ... data to create a MaintenanceApproval
     *   }
     * })
     * 
     */
    create<T extends MaintenanceApprovalCreateArgs>(args: SelectSubset<T, MaintenanceApprovalCreateArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceApprovals.
     * @param {MaintenanceApprovalCreateManyArgs} args - Arguments to create many MaintenanceApprovals.
     * @example
     * // Create many MaintenanceApprovals
     * const maintenanceApproval = await prisma.maintenanceApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceApprovalCreateManyArgs>(args?: SelectSubset<T, MaintenanceApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceApprovals and returns the data saved in the database.
     * @param {MaintenanceApprovalCreateManyAndReturnArgs} args - Arguments to create many MaintenanceApprovals.
     * @example
     * // Create many MaintenanceApprovals
     * const maintenanceApproval = await prisma.maintenanceApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceApprovals and only return the `id`
     * const maintenanceApprovalWithIdOnly = await prisma.maintenanceApproval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceApproval.
     * @param {MaintenanceApprovalDeleteArgs} args - Arguments to delete one MaintenanceApproval.
     * @example
     * // Delete one MaintenanceApproval
     * const MaintenanceApproval = await prisma.maintenanceApproval.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceApproval
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceApprovalDeleteArgs>(args: SelectSubset<T, MaintenanceApprovalDeleteArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceApproval.
     * @param {MaintenanceApprovalUpdateArgs} args - Arguments to update one MaintenanceApproval.
     * @example
     * // Update one MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceApprovalUpdateArgs>(args: SelectSubset<T, MaintenanceApprovalUpdateArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceApprovals.
     * @param {MaintenanceApprovalDeleteManyArgs} args - Arguments to filter MaintenanceApprovals to delete.
     * @example
     * // Delete a few MaintenanceApprovals
     * const { count } = await prisma.maintenanceApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceApprovalDeleteManyArgs>(args?: SelectSubset<T, MaintenanceApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceApprovals
     * const maintenanceApproval = await prisma.maintenanceApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceApprovalUpdateManyArgs>(args: SelectSubset<T, MaintenanceApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceApproval.
     * @param {MaintenanceApprovalUpsertArgs} args - Arguments to update or create a MaintenanceApproval.
     * @example
     * // Update or create a MaintenanceApproval
     * const maintenanceApproval = await prisma.maintenanceApproval.upsert({
     *   create: {
     *     // ... data to create a MaintenanceApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceApproval we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceApprovalUpsertArgs>(args: SelectSubset<T, MaintenanceApprovalUpsertArgs<ExtArgs>>): Prisma__MaintenanceApprovalClient<$Result.GetResult<Prisma.$MaintenanceApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalCountArgs} args - Arguments to filter MaintenanceApprovals to count.
     * @example
     * // Count the number of MaintenanceApprovals
     * const count = await prisma.maintenanceApproval.count({
     *   where: {
     *     // ... the filter for the MaintenanceApprovals we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceApprovalCountArgs>(
      args?: Subset<T, MaintenanceApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceApprovalAggregateArgs>(args: Subset<T, MaintenanceApprovalAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceApprovalAggregateType<T>>

    /**
     * Group by MaintenanceApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceApprovalGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceApproval model
   */
  readonly fields: MaintenanceApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends MaintenanceApproval$branchArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceApproval$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    request<T extends MaintenanceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequestDefaultArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceApproval model
   */ 
  interface MaintenanceApprovalFieldRefs {
    readonly id: FieldRef<"MaintenanceApproval", 'String'>
    readonly requestId: FieldRef<"MaintenanceApproval", 'String'>
    readonly cost: FieldRef<"MaintenanceApproval", 'Float'>
    readonly parts: FieldRef<"MaintenanceApproval", 'String'>
    readonly status: FieldRef<"MaintenanceApproval", 'String'>
    readonly notes: FieldRef<"MaintenanceApproval", 'String'>
    readonly branchId: FieldRef<"MaintenanceApproval", 'String'>
    readonly createdAt: FieldRef<"MaintenanceApproval", 'DateTime'>
    readonly respondedAt: FieldRef<"MaintenanceApproval", 'DateTime'>
    readonly respondedBy: FieldRef<"MaintenanceApproval", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceApproval findUnique
   */
  export type MaintenanceApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceApproval to fetch.
     */
    where: MaintenanceApprovalWhereUniqueInput
  }

  /**
   * MaintenanceApproval findUniqueOrThrow
   */
  export type MaintenanceApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceApproval to fetch.
     */
    where: MaintenanceApprovalWhereUniqueInput
  }

  /**
   * MaintenanceApproval findFirst
   */
  export type MaintenanceApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceApproval to fetch.
     */
    where?: MaintenanceApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovals to fetch.
     */
    orderBy?: MaintenanceApprovalOrderByWithRelationInput | MaintenanceApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceApprovals.
     */
    cursor?: MaintenanceApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceApprovals.
     */
    distinct?: MaintenanceApprovalScalarFieldEnum | MaintenanceApprovalScalarFieldEnum[]
  }

  /**
   * MaintenanceApproval findFirstOrThrow
   */
  export type MaintenanceApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceApproval to fetch.
     */
    where?: MaintenanceApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovals to fetch.
     */
    orderBy?: MaintenanceApprovalOrderByWithRelationInput | MaintenanceApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceApprovals.
     */
    cursor?: MaintenanceApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceApprovals.
     */
    distinct?: MaintenanceApprovalScalarFieldEnum | MaintenanceApprovalScalarFieldEnum[]
  }

  /**
   * MaintenanceApproval findMany
   */
  export type MaintenanceApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovals to fetch.
     */
    where?: MaintenanceApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovals to fetch.
     */
    orderBy?: MaintenanceApprovalOrderByWithRelationInput | MaintenanceApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceApprovals.
     */
    cursor?: MaintenanceApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovals.
     */
    skip?: number
    distinct?: MaintenanceApprovalScalarFieldEnum | MaintenanceApprovalScalarFieldEnum[]
  }

  /**
   * MaintenanceApproval create
   */
  export type MaintenanceApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceApproval.
     */
    data: XOR<MaintenanceApprovalCreateInput, MaintenanceApprovalUncheckedCreateInput>
  }

  /**
   * MaintenanceApproval createMany
   */
  export type MaintenanceApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceApprovals.
     */
    data: MaintenanceApprovalCreateManyInput | MaintenanceApprovalCreateManyInput[]
  }

  /**
   * MaintenanceApproval createManyAndReturn
   */
  export type MaintenanceApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceApprovals.
     */
    data: MaintenanceApprovalCreateManyInput | MaintenanceApprovalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceApproval update
   */
  export type MaintenanceApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceApproval.
     */
    data: XOR<MaintenanceApprovalUpdateInput, MaintenanceApprovalUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceApproval to update.
     */
    where: MaintenanceApprovalWhereUniqueInput
  }

  /**
   * MaintenanceApproval updateMany
   */
  export type MaintenanceApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceApprovals.
     */
    data: XOR<MaintenanceApprovalUpdateManyMutationInput, MaintenanceApprovalUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceApprovals to update
     */
    where?: MaintenanceApprovalWhereInput
  }

  /**
   * MaintenanceApproval upsert
   */
  export type MaintenanceApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceApproval to update in case it exists.
     */
    where: MaintenanceApprovalWhereUniqueInput
    /**
     * In case the MaintenanceApproval found by the `where` argument doesn't exist, create a new MaintenanceApproval with this data.
     */
    create: XOR<MaintenanceApprovalCreateInput, MaintenanceApprovalUncheckedCreateInput>
    /**
     * In case the MaintenanceApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceApprovalUpdateInput, MaintenanceApprovalUncheckedUpdateInput>
  }

  /**
   * MaintenanceApproval delete
   */
  export type MaintenanceApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceApproval to delete.
     */
    where: MaintenanceApprovalWhereUniqueInput
  }

  /**
   * MaintenanceApproval deleteMany
   */
  export type MaintenanceApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceApprovals to delete
     */
    where?: MaintenanceApprovalWhereInput
  }

  /**
   * MaintenanceApproval.branch
   */
  export type MaintenanceApproval$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MaintenanceApproval without action
   */
  export type MaintenanceApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApproval
     */
    select?: MaintenanceApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceApprovalInclude<ExtArgs> | null
  }


  /**
   * Model RepairVoucher
   */

  export type AggregateRepairVoucher = {
    _count: RepairVoucherCountAggregateOutputType | null
    _avg: RepairVoucherAvgAggregateOutputType | null
    _sum: RepairVoucherSumAggregateOutputType | null
    _min: RepairVoucherMinAggregateOutputType | null
    _max: RepairVoucherMaxAggregateOutputType | null
  }

  export type RepairVoucherAvgAggregateOutputType = {
    totalCost: number | null
  }

  export type RepairVoucherSumAggregateOutputType = {
    totalCost: number | null
  }

  export type RepairVoucherMinAggregateOutputType = {
    id: string | null
    code: string | null
    requestId: string | null
    type: string | null
    parts: string | null
    totalCost: number | null
    branchId: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type RepairVoucherMaxAggregateOutputType = {
    id: string | null
    code: string | null
    requestId: string | null
    type: string | null
    parts: string | null
    totalCost: number | null
    branchId: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type RepairVoucherCountAggregateOutputType = {
    id: number
    code: number
    requestId: number
    type: number
    parts: number
    totalCost: number
    branchId: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type RepairVoucherAvgAggregateInputType = {
    totalCost?: true
  }

  export type RepairVoucherSumAggregateInputType = {
    totalCost?: true
  }

  export type RepairVoucherMinAggregateInputType = {
    id?: true
    code?: true
    requestId?: true
    type?: true
    parts?: true
    totalCost?: true
    branchId?: true
    createdAt?: true
    createdBy?: true
  }

  export type RepairVoucherMaxAggregateInputType = {
    id?: true
    code?: true
    requestId?: true
    type?: true
    parts?: true
    totalCost?: true
    branchId?: true
    createdAt?: true
    createdBy?: true
  }

  export type RepairVoucherCountAggregateInputType = {
    id?: true
    code?: true
    requestId?: true
    type?: true
    parts?: true
    totalCost?: true
    branchId?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type RepairVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairVoucher to aggregate.
     */
    where?: RepairVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairVouchers to fetch.
     */
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairVouchers
    **/
    _count?: true | RepairVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairVoucherMaxAggregateInputType
  }

  export type GetRepairVoucherAggregateType<T extends RepairVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairVoucher[P]>
      : GetScalarType<T[P], AggregateRepairVoucher[P]>
  }




  export type RepairVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairVoucherWhereInput
    orderBy?: RepairVoucherOrderByWithAggregationInput | RepairVoucherOrderByWithAggregationInput[]
    by: RepairVoucherScalarFieldEnum[] | RepairVoucherScalarFieldEnum
    having?: RepairVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairVoucherCountAggregateInputType | true
    _avg?: RepairVoucherAvgAggregateInputType
    _sum?: RepairVoucherSumAggregateInputType
    _min?: RepairVoucherMinAggregateInputType
    _max?: RepairVoucherMaxAggregateInputType
  }

  export type RepairVoucherGroupByOutputType = {
    id: string
    code: string
    requestId: string
    type: string
    parts: string
    totalCost: number
    branchId: string | null
    createdAt: Date
    createdBy: string | null
    _count: RepairVoucherCountAggregateOutputType | null
    _avg: RepairVoucherAvgAggregateOutputType | null
    _sum: RepairVoucherSumAggregateOutputType | null
    _min: RepairVoucherMinAggregateOutputType | null
    _max: RepairVoucherMaxAggregateOutputType | null
  }

  type GetRepairVoucherGroupByPayload<T extends RepairVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], RepairVoucherGroupByOutputType[P]>
        }
      >
    >


  export type RepairVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    requestId?: boolean
    type?: boolean
    parts?: boolean
    totalCost?: boolean
    branchId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    branch?: boolean | RepairVoucher$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repairVoucher"]>

  export type RepairVoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    requestId?: boolean
    type?: boolean
    parts?: boolean
    totalCost?: boolean
    branchId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    branch?: boolean | RepairVoucher$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repairVoucher"]>

  export type RepairVoucherSelectScalar = {
    id?: boolean
    code?: boolean
    requestId?: boolean
    type?: boolean
    parts?: boolean
    totalCost?: boolean
    branchId?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type RepairVoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | RepairVoucher$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }
  export type RepairVoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | RepairVoucher$branchArgs<ExtArgs>
    request?: boolean | MaintenanceRequestDefaultArgs<ExtArgs>
  }

  export type $RepairVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RepairVoucher"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      request: Prisma.$MaintenanceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      requestId: string
      type: string
      parts: string
      totalCost: number
      branchId: string | null
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["repairVoucher"]>
    composites: {}
  }

  type RepairVoucherGetPayload<S extends boolean | null | undefined | RepairVoucherDefaultArgs> = $Result.GetResult<Prisma.$RepairVoucherPayload, S>

  type RepairVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepairVoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepairVoucherCountAggregateInputType | true
    }

  export interface RepairVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepairVoucher'], meta: { name: 'RepairVoucher' } }
    /**
     * Find zero or one RepairVoucher that matches the filter.
     * @param {RepairVoucherFindUniqueArgs} args - Arguments to find a RepairVoucher
     * @example
     * // Get one RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepairVoucherFindUniqueArgs>(args: SelectSubset<T, RepairVoucherFindUniqueArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RepairVoucher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepairVoucherFindUniqueOrThrowArgs} args - Arguments to find a RepairVoucher
     * @example
     * // Get one RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepairVoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, RepairVoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RepairVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherFindFirstArgs} args - Arguments to find a RepairVoucher
     * @example
     * // Get one RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepairVoucherFindFirstArgs>(args?: SelectSubset<T, RepairVoucherFindFirstArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RepairVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherFindFirstOrThrowArgs} args - Arguments to find a RepairVoucher
     * @example
     * // Get one RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepairVoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, RepairVoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RepairVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairVouchers
     * const repairVouchers = await prisma.repairVoucher.findMany()
     * 
     * // Get first 10 RepairVouchers
     * const repairVouchers = await prisma.repairVoucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairVoucherWithIdOnly = await prisma.repairVoucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepairVoucherFindManyArgs>(args?: SelectSubset<T, RepairVoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RepairVoucher.
     * @param {RepairVoucherCreateArgs} args - Arguments to create a RepairVoucher.
     * @example
     * // Create one RepairVoucher
     * const RepairVoucher = await prisma.repairVoucher.create({
     *   data: {
     *     // ... data to create a RepairVoucher
     *   }
     * })
     * 
     */
    create<T extends RepairVoucherCreateArgs>(args: SelectSubset<T, RepairVoucherCreateArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RepairVouchers.
     * @param {RepairVoucherCreateManyArgs} args - Arguments to create many RepairVouchers.
     * @example
     * // Create many RepairVouchers
     * const repairVoucher = await prisma.repairVoucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepairVoucherCreateManyArgs>(args?: SelectSubset<T, RepairVoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RepairVouchers and returns the data saved in the database.
     * @param {RepairVoucherCreateManyAndReturnArgs} args - Arguments to create many RepairVouchers.
     * @example
     * // Create many RepairVouchers
     * const repairVoucher = await prisma.repairVoucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RepairVouchers and only return the `id`
     * const repairVoucherWithIdOnly = await prisma.repairVoucher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepairVoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, RepairVoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RepairVoucher.
     * @param {RepairVoucherDeleteArgs} args - Arguments to delete one RepairVoucher.
     * @example
     * // Delete one RepairVoucher
     * const RepairVoucher = await prisma.repairVoucher.delete({
     *   where: {
     *     // ... filter to delete one RepairVoucher
     *   }
     * })
     * 
     */
    delete<T extends RepairVoucherDeleteArgs>(args: SelectSubset<T, RepairVoucherDeleteArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RepairVoucher.
     * @param {RepairVoucherUpdateArgs} args - Arguments to update one RepairVoucher.
     * @example
     * // Update one RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepairVoucherUpdateArgs>(args: SelectSubset<T, RepairVoucherUpdateArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RepairVouchers.
     * @param {RepairVoucherDeleteManyArgs} args - Arguments to filter RepairVouchers to delete.
     * @example
     * // Delete a few RepairVouchers
     * const { count } = await prisma.repairVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepairVoucherDeleteManyArgs>(args?: SelectSubset<T, RepairVoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairVouchers
     * const repairVoucher = await prisma.repairVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepairVoucherUpdateManyArgs>(args: SelectSubset<T, RepairVoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairVoucher.
     * @param {RepairVoucherUpsertArgs} args - Arguments to update or create a RepairVoucher.
     * @example
     * // Update or create a RepairVoucher
     * const repairVoucher = await prisma.repairVoucher.upsert({
     *   create: {
     *     // ... data to create a RepairVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairVoucher we want to update
     *   }
     * })
     */
    upsert<T extends RepairVoucherUpsertArgs>(args: SelectSubset<T, RepairVoucherUpsertArgs<ExtArgs>>): Prisma__RepairVoucherClient<$Result.GetResult<Prisma.$RepairVoucherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RepairVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherCountArgs} args - Arguments to filter RepairVouchers to count.
     * @example
     * // Count the number of RepairVouchers
     * const count = await prisma.repairVoucher.count({
     *   where: {
     *     // ... the filter for the RepairVouchers we want to count
     *   }
     * })
    **/
    count<T extends RepairVoucherCountArgs>(
      args?: Subset<T, RepairVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairVoucherAggregateArgs>(args: Subset<T, RepairVoucherAggregateArgs>): Prisma.PrismaPromise<GetRepairVoucherAggregateType<T>>

    /**
     * Group by RepairVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairVoucherGroupByArgs['orderBy'] }
        : { orderBy?: RepairVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RepairVoucher model
   */
  readonly fields: RepairVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends RepairVoucher$branchArgs<ExtArgs> = {}>(args?: Subset<T, RepairVoucher$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    request<T extends MaintenanceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequestDefaultArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RepairVoucher model
   */ 
  interface RepairVoucherFieldRefs {
    readonly id: FieldRef<"RepairVoucher", 'String'>
    readonly code: FieldRef<"RepairVoucher", 'String'>
    readonly requestId: FieldRef<"RepairVoucher", 'String'>
    readonly type: FieldRef<"RepairVoucher", 'String'>
    readonly parts: FieldRef<"RepairVoucher", 'String'>
    readonly totalCost: FieldRef<"RepairVoucher", 'Float'>
    readonly branchId: FieldRef<"RepairVoucher", 'String'>
    readonly createdAt: FieldRef<"RepairVoucher", 'DateTime'>
    readonly createdBy: FieldRef<"RepairVoucher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RepairVoucher findUnique
   */
  export type RepairVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter, which RepairVoucher to fetch.
     */
    where: RepairVoucherWhereUniqueInput
  }

  /**
   * RepairVoucher findUniqueOrThrow
   */
  export type RepairVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter, which RepairVoucher to fetch.
     */
    where: RepairVoucherWhereUniqueInput
  }

  /**
   * RepairVoucher findFirst
   */
  export type RepairVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter, which RepairVoucher to fetch.
     */
    where?: RepairVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairVouchers to fetch.
     */
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairVouchers.
     */
    cursor?: RepairVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairVouchers.
     */
    distinct?: RepairVoucherScalarFieldEnum | RepairVoucherScalarFieldEnum[]
  }

  /**
   * RepairVoucher findFirstOrThrow
   */
  export type RepairVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter, which RepairVoucher to fetch.
     */
    where?: RepairVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairVouchers to fetch.
     */
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairVouchers.
     */
    cursor?: RepairVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairVouchers.
     */
    distinct?: RepairVoucherScalarFieldEnum | RepairVoucherScalarFieldEnum[]
  }

  /**
   * RepairVoucher findMany
   */
  export type RepairVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter, which RepairVouchers to fetch.
     */
    where?: RepairVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairVouchers to fetch.
     */
    orderBy?: RepairVoucherOrderByWithRelationInput | RepairVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairVouchers.
     */
    cursor?: RepairVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairVouchers.
     */
    skip?: number
    distinct?: RepairVoucherScalarFieldEnum | RepairVoucherScalarFieldEnum[]
  }

  /**
   * RepairVoucher create
   */
  export type RepairVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a RepairVoucher.
     */
    data: XOR<RepairVoucherCreateInput, RepairVoucherUncheckedCreateInput>
  }

  /**
   * RepairVoucher createMany
   */
  export type RepairVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RepairVouchers.
     */
    data: RepairVoucherCreateManyInput | RepairVoucherCreateManyInput[]
  }

  /**
   * RepairVoucher createManyAndReturn
   */
  export type RepairVoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RepairVouchers.
     */
    data: RepairVoucherCreateManyInput | RepairVoucherCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RepairVoucher update
   */
  export type RepairVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a RepairVoucher.
     */
    data: XOR<RepairVoucherUpdateInput, RepairVoucherUncheckedUpdateInput>
    /**
     * Choose, which RepairVoucher to update.
     */
    where: RepairVoucherWhereUniqueInput
  }

  /**
   * RepairVoucher updateMany
   */
  export type RepairVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RepairVouchers.
     */
    data: XOR<RepairVoucherUpdateManyMutationInput, RepairVoucherUncheckedUpdateManyInput>
    /**
     * Filter which RepairVouchers to update
     */
    where?: RepairVoucherWhereInput
  }

  /**
   * RepairVoucher upsert
   */
  export type RepairVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the RepairVoucher to update in case it exists.
     */
    where: RepairVoucherWhereUniqueInput
    /**
     * In case the RepairVoucher found by the `where` argument doesn't exist, create a new RepairVoucher with this data.
     */
    create: XOR<RepairVoucherCreateInput, RepairVoucherUncheckedCreateInput>
    /**
     * In case the RepairVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairVoucherUpdateInput, RepairVoucherUncheckedUpdateInput>
  }

  /**
   * RepairVoucher delete
   */
  export type RepairVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
    /**
     * Filter which RepairVoucher to delete.
     */
    where: RepairVoucherWhereUniqueInput
  }

  /**
   * RepairVoucher deleteMany
   */
  export type RepairVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairVouchers to delete
     */
    where?: RepairVoucherWhereInput
  }

  /**
   * RepairVoucher.branch
   */
  export type RepairVoucher$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * RepairVoucher without action
   */
  export type RepairVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairVoucher
     */
    select?: RepairVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairVoucherInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    branchId: string | null
    link: string | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    branchId: string | null
    link: string | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    branchId: number
    link: number
    type: number
    title: number
    message: number
    data: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    link?: true
    type?: true
    title?: true
    message?: true
    data?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    link?: true
    type?: true
    title?: true
    message?: true
    data?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    link?: true
    type?: true
    title?: true
    message?: true
    data?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    branchId: string | null
    link: string | null
    type: string
    title: string
    message: string
    data: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    link?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
    branch?: boolean | Notification$branchArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    link?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
    branch?: boolean | Notification$branchArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    branchId?: boolean
    link?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Notification$branchArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Notification$branchArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      branchId: string | null
      link: string | null
      type: string
      title: string
      message: string
      data: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Notification$branchArgs<ExtArgs> = {}>(args?: Subset<T, Notification$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly branchId: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.branch
   */
  export type Notification$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAssignment
   */

  export type AggregateServiceAssignment = {
    _count: ServiceAssignmentCountAggregateOutputType | null
    _avg: ServiceAssignmentAvgAggregateOutputType | null
    _sum: ServiceAssignmentSumAggregateOutputType | null
    _min: ServiceAssignmentMinAggregateOutputType | null
    _max: ServiceAssignmentMaxAggregateOutputType | null
  }

  export type ServiceAssignmentAvgAggregateOutputType = {
    proposedTotal: number | null
    totalCost: number | null
  }

  export type ServiceAssignmentSumAggregateOutputType = {
    proposedTotal: number | null
    totalCost: number | null
  }

  export type ServiceAssignmentMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    serialNumber: string | null
    technicianId: string | null
    technicianName: string | null
    status: string | null
    proposedParts: string | null
    proposedTotal: number | null
    usedParts: string | null
    totalCost: number | null
    needsApproval: boolean | null
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    actionTaken: string | null
    resolution: string | null
    assignedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    customerId: string | null
    customerName: string | null
    requestId: string | null
    branchId: string | null
    centerBranchId: string | null
    originBranchId: string | null
  }

  export type ServiceAssignmentMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    serialNumber: string | null
    technicianId: string | null
    technicianName: string | null
    status: string | null
    proposedParts: string | null
    proposedTotal: number | null
    usedParts: string | null
    totalCost: number | null
    needsApproval: boolean | null
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    actionTaken: string | null
    resolution: string | null
    assignedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    customerId: string | null
    customerName: string | null
    requestId: string | null
    branchId: string | null
    centerBranchId: string | null
    originBranchId: string | null
  }

  export type ServiceAssignmentCountAggregateOutputType = {
    id: number
    machineId: number
    serialNumber: number
    technicianId: number
    technicianName: number
    status: number
    proposedParts: number
    proposedTotal: number
    usedParts: number
    totalCost: number
    needsApproval: number
    approvedAt: number
    rejectedAt: number
    rejectionReason: number
    actionTaken: number
    resolution: number
    assignedAt: number
    startedAt: number
    completedAt: number
    customerId: number
    customerName: number
    requestId: number
    branchId: number
    centerBranchId: number
    originBranchId: number
    _all: number
  }


  export type ServiceAssignmentAvgAggregateInputType = {
    proposedTotal?: true
    totalCost?: true
  }

  export type ServiceAssignmentSumAggregateInputType = {
    proposedTotal?: true
    totalCost?: true
  }

  export type ServiceAssignmentMinAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    technicianId?: true
    technicianName?: true
    status?: true
    proposedParts?: true
    proposedTotal?: true
    usedParts?: true
    totalCost?: true
    needsApproval?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    actionTaken?: true
    resolution?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    customerId?: true
    customerName?: true
    requestId?: true
    branchId?: true
    centerBranchId?: true
    originBranchId?: true
  }

  export type ServiceAssignmentMaxAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    technicianId?: true
    technicianName?: true
    status?: true
    proposedParts?: true
    proposedTotal?: true
    usedParts?: true
    totalCost?: true
    needsApproval?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    actionTaken?: true
    resolution?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    customerId?: true
    customerName?: true
    requestId?: true
    branchId?: true
    centerBranchId?: true
    originBranchId?: true
  }

  export type ServiceAssignmentCountAggregateInputType = {
    id?: true
    machineId?: true
    serialNumber?: true
    technicianId?: true
    technicianName?: true
    status?: true
    proposedParts?: true
    proposedTotal?: true
    usedParts?: true
    totalCost?: true
    needsApproval?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    actionTaken?: true
    resolution?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    customerId?: true
    customerName?: true
    requestId?: true
    branchId?: true
    centerBranchId?: true
    originBranchId?: true
    _all?: true
  }

  export type ServiceAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignment to aggregate.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAssignments
    **/
    _count?: true | ServiceAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAssignmentMaxAggregateInputType
  }

  export type GetServiceAssignmentAggregateType<T extends ServiceAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAssignment[P]>
      : GetScalarType<T[P], AggregateServiceAssignment[P]>
  }




  export type ServiceAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithAggregationInput | ServiceAssignmentOrderByWithAggregationInput[]
    by: ServiceAssignmentScalarFieldEnum[] | ServiceAssignmentScalarFieldEnum
    having?: ServiceAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAssignmentCountAggregateInputType | true
    _avg?: ServiceAssignmentAvgAggregateInputType
    _sum?: ServiceAssignmentSumAggregateInputType
    _min?: ServiceAssignmentMinAggregateInputType
    _max?: ServiceAssignmentMaxAggregateInputType
  }

  export type ServiceAssignmentGroupByOutputType = {
    id: string
    machineId: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status: string
    proposedParts: string | null
    proposedTotal: number
    usedParts: string | null
    totalCost: number
    needsApproval: boolean
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    actionTaken: string | null
    resolution: string | null
    assignedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    customerId: string | null
    customerName: string | null
    requestId: string | null
    branchId: string | null
    centerBranchId: string | null
    originBranchId: string
    _count: ServiceAssignmentCountAggregateOutputType | null
    _avg: ServiceAssignmentAvgAggregateOutputType | null
    _sum: ServiceAssignmentSumAggregateOutputType | null
    _min: ServiceAssignmentMinAggregateOutputType | null
    _max: ServiceAssignmentMaxAggregateOutputType | null
  }

  type GetServiceAssignmentGroupByPayload<T extends ServiceAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    technicianId?: boolean
    technicianName?: boolean
    status?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    usedParts?: boolean
    totalCost?: boolean
    needsApproval?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    actionTaken?: boolean
    resolution?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    branchId?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
    machine?: boolean | WarehouseMachineDefaultArgs<ExtArgs>
    logs?: boolean | ServiceAssignment$logsArgs<ExtArgs>
    _count?: boolean | ServiceAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignment"]>

  export type ServiceAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    technicianId?: boolean
    technicianName?: boolean
    status?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    usedParts?: boolean
    totalCost?: boolean
    needsApproval?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    actionTaken?: boolean
    resolution?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    branchId?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
    machine?: boolean | WarehouseMachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignment"]>

  export type ServiceAssignmentSelectScalar = {
    id?: boolean
    machineId?: boolean
    serialNumber?: boolean
    technicianId?: boolean
    technicianName?: boolean
    status?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    usedParts?: boolean
    totalCost?: boolean
    needsApproval?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    actionTaken?: boolean
    resolution?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    customerId?: boolean
    customerName?: boolean
    requestId?: boolean
    branchId?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
  }

  export type ServiceAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | WarehouseMachineDefaultArgs<ExtArgs>
    logs?: boolean | ServiceAssignment$logsArgs<ExtArgs>
    _count?: boolean | ServiceAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | WarehouseMachineDefaultArgs<ExtArgs>
  }

  export type $ServiceAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAssignment"
    objects: {
      machine: Prisma.$WarehouseMachinePayload<ExtArgs>
      logs: Prisma.$ServiceAssignmentLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      serialNumber: string
      technicianId: string
      technicianName: string
      status: string
      proposedParts: string | null
      proposedTotal: number
      usedParts: string | null
      totalCost: number
      needsApproval: boolean
      approvedAt: Date | null
      rejectedAt: Date | null
      rejectionReason: string | null
      actionTaken: string | null
      resolution: string | null
      assignedAt: Date
      startedAt: Date | null
      completedAt: Date | null
      customerId: string | null
      customerName: string | null
      requestId: string | null
      branchId: string | null
      centerBranchId: string | null
      originBranchId: string
    }, ExtArgs["result"]["serviceAssignment"]>
    composites: {}
  }

  type ServiceAssignmentGetPayload<S extends boolean | null | undefined | ServiceAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ServiceAssignmentPayload, S>

  type ServiceAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceAssignmentCountAggregateInputType | true
    }

  export interface ServiceAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAssignment'], meta: { name: 'ServiceAssignment' } }
    /**
     * Find zero or one ServiceAssignment that matches the filter.
     * @param {ServiceAssignmentFindUniqueArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAssignmentFindUniqueArgs>(args: SelectSubset<T, ServiceAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindFirstArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAssignmentFindFirstArgs>(args?: SelectSubset<T, ServiceAssignmentFindFirstArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindFirstOrThrowArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAssignments
     * const serviceAssignments = await prisma.serviceAssignment.findMany()
     * 
     * // Get first 10 ServiceAssignments
     * const serviceAssignments = await prisma.serviceAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAssignmentWithIdOnly = await prisma.serviceAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAssignmentFindManyArgs>(args?: SelectSubset<T, ServiceAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceAssignment.
     * @param {ServiceAssignmentCreateArgs} args - Arguments to create a ServiceAssignment.
     * @example
     * // Create one ServiceAssignment
     * const ServiceAssignment = await prisma.serviceAssignment.create({
     *   data: {
     *     // ... data to create a ServiceAssignment
     *   }
     * })
     * 
     */
    create<T extends ServiceAssignmentCreateArgs>(args: SelectSubset<T, ServiceAssignmentCreateArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceAssignments.
     * @param {ServiceAssignmentCreateManyArgs} args - Arguments to create many ServiceAssignments.
     * @example
     * // Create many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAssignmentCreateManyArgs>(args?: SelectSubset<T, ServiceAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAssignments and returns the data saved in the database.
     * @param {ServiceAssignmentCreateManyAndReturnArgs} args - Arguments to create many ServiceAssignments.
     * @example
     * // Create many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAssignments and only return the `id`
     * const serviceAssignmentWithIdOnly = await prisma.serviceAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceAssignment.
     * @param {ServiceAssignmentDeleteArgs} args - Arguments to delete one ServiceAssignment.
     * @example
     * // Delete one ServiceAssignment
     * const ServiceAssignment = await prisma.serviceAssignment.delete({
     *   where: {
     *     // ... filter to delete one ServiceAssignment
     *   }
     * })
     * 
     */
    delete<T extends ServiceAssignmentDeleteArgs>(args: SelectSubset<T, ServiceAssignmentDeleteArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceAssignment.
     * @param {ServiceAssignmentUpdateArgs} args - Arguments to update one ServiceAssignment.
     * @example
     * // Update one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAssignmentUpdateArgs>(args: SelectSubset<T, ServiceAssignmentUpdateArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceAssignments.
     * @param {ServiceAssignmentDeleteManyArgs} args - Arguments to filter ServiceAssignments to delete.
     * @example
     * // Delete a few ServiceAssignments
     * const { count } = await prisma.serviceAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAssignmentDeleteManyArgs>(args?: SelectSubset<T, ServiceAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAssignmentUpdateManyArgs>(args: SelectSubset<T, ServiceAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceAssignment.
     * @param {ServiceAssignmentUpsertArgs} args - Arguments to update or create a ServiceAssignment.
     * @example
     * // Update or create a ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.upsert({
     *   create: {
     *     // ... data to create a ServiceAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAssignmentUpsertArgs>(args: SelectSubset<T, ServiceAssignmentUpsertArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentCountArgs} args - Arguments to filter ServiceAssignments to count.
     * @example
     * // Count the number of ServiceAssignments
     * const count = await prisma.serviceAssignment.count({
     *   where: {
     *     // ... the filter for the ServiceAssignments we want to count
     *   }
     * })
    **/
    count<T extends ServiceAssignmentCountArgs>(
      args?: Subset<T, ServiceAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAssignmentAggregateArgs>(args: Subset<T, ServiceAssignmentAggregateArgs>): Prisma.PrismaPromise<GetServiceAssignmentAggregateType<T>>

    /**
     * Group by ServiceAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAssignment model
   */
  readonly fields: ServiceAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends WarehouseMachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseMachineDefaultArgs<ExtArgs>>): Prisma__WarehouseMachineClient<$Result.GetResult<Prisma.$WarehouseMachinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logs<T extends ServiceAssignment$logsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAssignment$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAssignment model
   */ 
  interface ServiceAssignmentFieldRefs {
    readonly id: FieldRef<"ServiceAssignment", 'String'>
    readonly machineId: FieldRef<"ServiceAssignment", 'String'>
    readonly serialNumber: FieldRef<"ServiceAssignment", 'String'>
    readonly technicianId: FieldRef<"ServiceAssignment", 'String'>
    readonly technicianName: FieldRef<"ServiceAssignment", 'String'>
    readonly status: FieldRef<"ServiceAssignment", 'String'>
    readonly proposedParts: FieldRef<"ServiceAssignment", 'String'>
    readonly proposedTotal: FieldRef<"ServiceAssignment", 'Float'>
    readonly usedParts: FieldRef<"ServiceAssignment", 'String'>
    readonly totalCost: FieldRef<"ServiceAssignment", 'Float'>
    readonly needsApproval: FieldRef<"ServiceAssignment", 'Boolean'>
    readonly approvedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly rejectedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly rejectionReason: FieldRef<"ServiceAssignment", 'String'>
    readonly actionTaken: FieldRef<"ServiceAssignment", 'String'>
    readonly resolution: FieldRef<"ServiceAssignment", 'String'>
    readonly assignedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly startedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly customerId: FieldRef<"ServiceAssignment", 'String'>
    readonly customerName: FieldRef<"ServiceAssignment", 'String'>
    readonly requestId: FieldRef<"ServiceAssignment", 'String'>
    readonly branchId: FieldRef<"ServiceAssignment", 'String'>
    readonly centerBranchId: FieldRef<"ServiceAssignment", 'String'>
    readonly originBranchId: FieldRef<"ServiceAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAssignment findUnique
   */
  export type ServiceAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment findUniqueOrThrow
   */
  export type ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment findFirst
   */
  export type ServiceAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignments.
     */
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment findFirstOrThrow
   */
  export type ServiceAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignments.
     */
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment findMany
   */
  export type ServiceAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignments to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment create
   */
  export type ServiceAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAssignment.
     */
    data: XOR<ServiceAssignmentCreateInput, ServiceAssignmentUncheckedCreateInput>
  }

  /**
   * ServiceAssignment createMany
   */
  export type ServiceAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAssignments.
     */
    data: ServiceAssignmentCreateManyInput | ServiceAssignmentCreateManyInput[]
  }

  /**
   * ServiceAssignment createManyAndReturn
   */
  export type ServiceAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceAssignments.
     */
    data: ServiceAssignmentCreateManyInput | ServiceAssignmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAssignment update
   */
  export type ServiceAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAssignment.
     */
    data: XOR<ServiceAssignmentUpdateInput, ServiceAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ServiceAssignment to update.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment updateMany
   */
  export type ServiceAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAssignments.
     */
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAssignments to update
     */
    where?: ServiceAssignmentWhereInput
  }

  /**
   * ServiceAssignment upsert
   */
  export type ServiceAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAssignment to update in case it exists.
     */
    where: ServiceAssignmentWhereUniqueInput
    /**
     * In case the ServiceAssignment found by the `where` argument doesn't exist, create a new ServiceAssignment with this data.
     */
    create: XOR<ServiceAssignmentCreateInput, ServiceAssignmentUncheckedCreateInput>
    /**
     * In case the ServiceAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAssignmentUpdateInput, ServiceAssignmentUncheckedUpdateInput>
  }

  /**
   * ServiceAssignment delete
   */
  export type ServiceAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ServiceAssignment to delete.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment deleteMany
   */
  export type ServiceAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignments to delete
     */
    where?: ServiceAssignmentWhereInput
  }

  /**
   * ServiceAssignment.logs
   */
  export type ServiceAssignment$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    where?: ServiceAssignmentLogWhereInput
    orderBy?: ServiceAssignmentLogOrderByWithRelationInput | ServiceAssignmentLogOrderByWithRelationInput[]
    cursor?: ServiceAssignmentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAssignmentLogScalarFieldEnum | ServiceAssignmentLogScalarFieldEnum[]
  }

  /**
   * ServiceAssignment without action
   */
  export type ServiceAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAssignmentLog
   */

  export type AggregateServiceAssignmentLog = {
    _count: ServiceAssignmentLogCountAggregateOutputType | null
    _min: ServiceAssignmentLogMinAggregateOutputType | null
    _max: ServiceAssignmentLogMaxAggregateOutputType | null
  }

  export type ServiceAssignmentLogMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    performedById: string | null
    performedAt: Date | null
  }

  export type ServiceAssignmentLogMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    action: string | null
    details: string | null
    performedBy: string | null
    performedById: string | null
    performedAt: Date | null
  }

  export type ServiceAssignmentLogCountAggregateOutputType = {
    id: number
    assignmentId: number
    action: number
    details: number
    performedBy: number
    performedById: number
    performedAt: number
    _all: number
  }


  export type ServiceAssignmentLogMinAggregateInputType = {
    id?: true
    assignmentId?: true
    action?: true
    details?: true
    performedBy?: true
    performedById?: true
    performedAt?: true
  }

  export type ServiceAssignmentLogMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    action?: true
    details?: true
    performedBy?: true
    performedById?: true
    performedAt?: true
  }

  export type ServiceAssignmentLogCountAggregateInputType = {
    id?: true
    assignmentId?: true
    action?: true
    details?: true
    performedBy?: true
    performedById?: true
    performedAt?: true
    _all?: true
  }

  export type ServiceAssignmentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignmentLog to aggregate.
     */
    where?: ServiceAssignmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignmentLogs to fetch.
     */
    orderBy?: ServiceAssignmentLogOrderByWithRelationInput | ServiceAssignmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAssignmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAssignmentLogs
    **/
    _count?: true | ServiceAssignmentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAssignmentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAssignmentLogMaxAggregateInputType
  }

  export type GetServiceAssignmentLogAggregateType<T extends ServiceAssignmentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAssignmentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAssignmentLog[P]>
      : GetScalarType<T[P], AggregateServiceAssignmentLog[P]>
  }




  export type ServiceAssignmentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentLogWhereInput
    orderBy?: ServiceAssignmentLogOrderByWithAggregationInput | ServiceAssignmentLogOrderByWithAggregationInput[]
    by: ServiceAssignmentLogScalarFieldEnum[] | ServiceAssignmentLogScalarFieldEnum
    having?: ServiceAssignmentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAssignmentLogCountAggregateInputType | true
    _min?: ServiceAssignmentLogMinAggregateInputType
    _max?: ServiceAssignmentLogMaxAggregateInputType
  }

  export type ServiceAssignmentLogGroupByOutputType = {
    id: string
    assignmentId: string
    action: string
    details: string | null
    performedBy: string
    performedById: string | null
    performedAt: Date
    _count: ServiceAssignmentLogCountAggregateOutputType | null
    _min: ServiceAssignmentLogMinAggregateOutputType | null
    _max: ServiceAssignmentLogMaxAggregateOutputType | null
  }

  type GetServiceAssignmentLogGroupByPayload<T extends ServiceAssignmentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAssignmentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAssignmentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAssignmentLogGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAssignmentLogGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAssignmentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    performedById?: boolean
    performedAt?: boolean
    assignment?: boolean | ServiceAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignmentLog"]>

  export type ServiceAssignmentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    performedById?: boolean
    performedAt?: boolean
    assignment?: boolean | ServiceAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignmentLog"]>

  export type ServiceAssignmentLogSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    action?: boolean
    details?: boolean
    performedBy?: boolean
    performedById?: boolean
    performedAt?: boolean
  }

  export type ServiceAssignmentLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | ServiceAssignmentDefaultArgs<ExtArgs>
  }
  export type ServiceAssignmentLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | ServiceAssignmentDefaultArgs<ExtArgs>
  }

  export type $ServiceAssignmentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAssignmentLog"
    objects: {
      assignment: Prisma.$ServiceAssignmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      action: string
      details: string | null
      performedBy: string
      performedById: string | null
      performedAt: Date
    }, ExtArgs["result"]["serviceAssignmentLog"]>
    composites: {}
  }

  type ServiceAssignmentLogGetPayload<S extends boolean | null | undefined | ServiceAssignmentLogDefaultArgs> = $Result.GetResult<Prisma.$ServiceAssignmentLogPayload, S>

  type ServiceAssignmentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceAssignmentLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceAssignmentLogCountAggregateInputType | true
    }

  export interface ServiceAssignmentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAssignmentLog'], meta: { name: 'ServiceAssignmentLog' } }
    /**
     * Find zero or one ServiceAssignmentLog that matches the filter.
     * @param {ServiceAssignmentLogFindUniqueArgs} args - Arguments to find a ServiceAssignmentLog
     * @example
     * // Get one ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAssignmentLogFindUniqueArgs>(args: SelectSubset<T, ServiceAssignmentLogFindUniqueArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceAssignmentLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceAssignmentLogFindUniqueOrThrowArgs} args - Arguments to find a ServiceAssignmentLog
     * @example
     * // Get one ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAssignmentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAssignmentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceAssignmentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogFindFirstArgs} args - Arguments to find a ServiceAssignmentLog
     * @example
     * // Get one ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAssignmentLogFindFirstArgs>(args?: SelectSubset<T, ServiceAssignmentLogFindFirstArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceAssignmentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogFindFirstOrThrowArgs} args - Arguments to find a ServiceAssignmentLog
     * @example
     * // Get one ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAssignmentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAssignmentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceAssignmentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAssignmentLogs
     * const serviceAssignmentLogs = await prisma.serviceAssignmentLog.findMany()
     * 
     * // Get first 10 ServiceAssignmentLogs
     * const serviceAssignmentLogs = await prisma.serviceAssignmentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAssignmentLogWithIdOnly = await prisma.serviceAssignmentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAssignmentLogFindManyArgs>(args?: SelectSubset<T, ServiceAssignmentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceAssignmentLog.
     * @param {ServiceAssignmentLogCreateArgs} args - Arguments to create a ServiceAssignmentLog.
     * @example
     * // Create one ServiceAssignmentLog
     * const ServiceAssignmentLog = await prisma.serviceAssignmentLog.create({
     *   data: {
     *     // ... data to create a ServiceAssignmentLog
     *   }
     * })
     * 
     */
    create<T extends ServiceAssignmentLogCreateArgs>(args: SelectSubset<T, ServiceAssignmentLogCreateArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceAssignmentLogs.
     * @param {ServiceAssignmentLogCreateManyArgs} args - Arguments to create many ServiceAssignmentLogs.
     * @example
     * // Create many ServiceAssignmentLogs
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAssignmentLogCreateManyArgs>(args?: SelectSubset<T, ServiceAssignmentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAssignmentLogs and returns the data saved in the database.
     * @param {ServiceAssignmentLogCreateManyAndReturnArgs} args - Arguments to create many ServiceAssignmentLogs.
     * @example
     * // Create many ServiceAssignmentLogs
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAssignmentLogs and only return the `id`
     * const serviceAssignmentLogWithIdOnly = await prisma.serviceAssignmentLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAssignmentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAssignmentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceAssignmentLog.
     * @param {ServiceAssignmentLogDeleteArgs} args - Arguments to delete one ServiceAssignmentLog.
     * @example
     * // Delete one ServiceAssignmentLog
     * const ServiceAssignmentLog = await prisma.serviceAssignmentLog.delete({
     *   where: {
     *     // ... filter to delete one ServiceAssignmentLog
     *   }
     * })
     * 
     */
    delete<T extends ServiceAssignmentLogDeleteArgs>(args: SelectSubset<T, ServiceAssignmentLogDeleteArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceAssignmentLog.
     * @param {ServiceAssignmentLogUpdateArgs} args - Arguments to update one ServiceAssignmentLog.
     * @example
     * // Update one ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAssignmentLogUpdateArgs>(args: SelectSubset<T, ServiceAssignmentLogUpdateArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceAssignmentLogs.
     * @param {ServiceAssignmentLogDeleteManyArgs} args - Arguments to filter ServiceAssignmentLogs to delete.
     * @example
     * // Delete a few ServiceAssignmentLogs
     * const { count } = await prisma.serviceAssignmentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAssignmentLogDeleteManyArgs>(args?: SelectSubset<T, ServiceAssignmentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAssignmentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAssignmentLogs
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAssignmentLogUpdateManyArgs>(args: SelectSubset<T, ServiceAssignmentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceAssignmentLog.
     * @param {ServiceAssignmentLogUpsertArgs} args - Arguments to update or create a ServiceAssignmentLog.
     * @example
     * // Update or create a ServiceAssignmentLog
     * const serviceAssignmentLog = await prisma.serviceAssignmentLog.upsert({
     *   create: {
     *     // ... data to create a ServiceAssignmentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAssignmentLog we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAssignmentLogUpsertArgs>(args: SelectSubset<T, ServiceAssignmentLogUpsertArgs<ExtArgs>>): Prisma__ServiceAssignmentLogClient<$Result.GetResult<Prisma.$ServiceAssignmentLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceAssignmentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogCountArgs} args - Arguments to filter ServiceAssignmentLogs to count.
     * @example
     * // Count the number of ServiceAssignmentLogs
     * const count = await prisma.serviceAssignmentLog.count({
     *   where: {
     *     // ... the filter for the ServiceAssignmentLogs we want to count
     *   }
     * })
    **/
    count<T extends ServiceAssignmentLogCountArgs>(
      args?: Subset<T, ServiceAssignmentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAssignmentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAssignmentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAssignmentLogAggregateArgs>(args: Subset<T, ServiceAssignmentLogAggregateArgs>): Prisma.PrismaPromise<GetServiceAssignmentLogAggregateType<T>>

    /**
     * Group by ServiceAssignmentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAssignmentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAssignmentLogGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAssignmentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAssignmentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAssignmentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAssignmentLog model
   */
  readonly fields: ServiceAssignmentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAssignmentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAssignmentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends ServiceAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAssignmentDefaultArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAssignmentLog model
   */ 
  interface ServiceAssignmentLogFieldRefs {
    readonly id: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly assignmentId: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly action: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly details: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly performedBy: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly performedById: FieldRef<"ServiceAssignmentLog", 'String'>
    readonly performedAt: FieldRef<"ServiceAssignmentLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAssignmentLog findUnique
   */
  export type ServiceAssignmentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignmentLog to fetch.
     */
    where: ServiceAssignmentLogWhereUniqueInput
  }

  /**
   * ServiceAssignmentLog findUniqueOrThrow
   */
  export type ServiceAssignmentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignmentLog to fetch.
     */
    where: ServiceAssignmentLogWhereUniqueInput
  }

  /**
   * ServiceAssignmentLog findFirst
   */
  export type ServiceAssignmentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignmentLog to fetch.
     */
    where?: ServiceAssignmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignmentLogs to fetch.
     */
    orderBy?: ServiceAssignmentLogOrderByWithRelationInput | ServiceAssignmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignmentLogs.
     */
    cursor?: ServiceAssignmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignmentLogs.
     */
    distinct?: ServiceAssignmentLogScalarFieldEnum | ServiceAssignmentLogScalarFieldEnum[]
  }

  /**
   * ServiceAssignmentLog findFirstOrThrow
   */
  export type ServiceAssignmentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignmentLog to fetch.
     */
    where?: ServiceAssignmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignmentLogs to fetch.
     */
    orderBy?: ServiceAssignmentLogOrderByWithRelationInput | ServiceAssignmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignmentLogs.
     */
    cursor?: ServiceAssignmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignmentLogs.
     */
    distinct?: ServiceAssignmentLogScalarFieldEnum | ServiceAssignmentLogScalarFieldEnum[]
  }

  /**
   * ServiceAssignmentLog findMany
   */
  export type ServiceAssignmentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignmentLogs to fetch.
     */
    where?: ServiceAssignmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignmentLogs to fetch.
     */
    orderBy?: ServiceAssignmentLogOrderByWithRelationInput | ServiceAssignmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAssignmentLogs.
     */
    cursor?: ServiceAssignmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignmentLogs.
     */
    skip?: number
    distinct?: ServiceAssignmentLogScalarFieldEnum | ServiceAssignmentLogScalarFieldEnum[]
  }

  /**
   * ServiceAssignmentLog create
   */
  export type ServiceAssignmentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAssignmentLog.
     */
    data: XOR<ServiceAssignmentLogCreateInput, ServiceAssignmentLogUncheckedCreateInput>
  }

  /**
   * ServiceAssignmentLog createMany
   */
  export type ServiceAssignmentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAssignmentLogs.
     */
    data: ServiceAssignmentLogCreateManyInput | ServiceAssignmentLogCreateManyInput[]
  }

  /**
   * ServiceAssignmentLog createManyAndReturn
   */
  export type ServiceAssignmentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceAssignmentLogs.
     */
    data: ServiceAssignmentLogCreateManyInput | ServiceAssignmentLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAssignmentLog update
   */
  export type ServiceAssignmentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAssignmentLog.
     */
    data: XOR<ServiceAssignmentLogUpdateInput, ServiceAssignmentLogUncheckedUpdateInput>
    /**
     * Choose, which ServiceAssignmentLog to update.
     */
    where: ServiceAssignmentLogWhereUniqueInput
  }

  /**
   * ServiceAssignmentLog updateMany
   */
  export type ServiceAssignmentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAssignmentLogs.
     */
    data: XOR<ServiceAssignmentLogUpdateManyMutationInput, ServiceAssignmentLogUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAssignmentLogs to update
     */
    where?: ServiceAssignmentLogWhereInput
  }

  /**
   * ServiceAssignmentLog upsert
   */
  export type ServiceAssignmentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAssignmentLog to update in case it exists.
     */
    where: ServiceAssignmentLogWhereUniqueInput
    /**
     * In case the ServiceAssignmentLog found by the `where` argument doesn't exist, create a new ServiceAssignmentLog with this data.
     */
    create: XOR<ServiceAssignmentLogCreateInput, ServiceAssignmentLogUncheckedCreateInput>
    /**
     * In case the ServiceAssignmentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAssignmentLogUpdateInput, ServiceAssignmentLogUncheckedUpdateInput>
  }

  /**
   * ServiceAssignmentLog delete
   */
  export type ServiceAssignmentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
    /**
     * Filter which ServiceAssignmentLog to delete.
     */
    where: ServiceAssignmentLogWhereUniqueInput
  }

  /**
   * ServiceAssignmentLog deleteMany
   */
  export type ServiceAssignmentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignmentLogs to delete
     */
    where?: ServiceAssignmentLogWhereInput
  }

  /**
   * ServiceAssignmentLog without action
   */
  export type ServiceAssignmentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignmentLog
     */
    select?: ServiceAssignmentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentLogInclude<ExtArgs> | null
  }


  /**
   * Model BranchDebt
   */

  export type AggregateBranchDebt = {
    _count: BranchDebtCountAggregateOutputType | null
    _avg: BranchDebtAvgAggregateOutputType | null
    _sum: BranchDebtSumAggregateOutputType | null
    _min: BranchDebtMinAggregateOutputType | null
    _max: BranchDebtMaxAggregateOutputType | null
  }

  export type BranchDebtAvgAggregateOutputType = {
    amount: number | null
    paidAmount: number | null
    remainingAmount: number | null
  }

  export type BranchDebtSumAggregateOutputType = {
    amount: number | null
    paidAmount: number | null
    remainingAmount: number | null
  }

  export type BranchDebtMinAggregateOutputType = {
    id: string | null
    type: string | null
    referenceId: string | null
    machineSerial: string | null
    customerId: string | null
    customerName: string | null
    amount: number | null
    paidAmount: number | null
    remainingAmount: number | null
    partsDetails: string | null
    status: string | null
    creditorBranchId: string | null
    debtorBranchId: string | null
    receiptNumber: string | null
    paymentPlace: string | null
    paidAt: Date | null
    paidBy: string | null
    paidByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchDebtMaxAggregateOutputType = {
    id: string | null
    type: string | null
    referenceId: string | null
    machineSerial: string | null
    customerId: string | null
    customerName: string | null
    amount: number | null
    paidAmount: number | null
    remainingAmount: number | null
    partsDetails: string | null
    status: string | null
    creditorBranchId: string | null
    debtorBranchId: string | null
    receiptNumber: string | null
    paymentPlace: string | null
    paidAt: Date | null
    paidBy: string | null
    paidByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchDebtCountAggregateOutputType = {
    id: number
    type: number
    referenceId: number
    machineSerial: number
    customerId: number
    customerName: number
    amount: number
    paidAmount: number
    remainingAmount: number
    partsDetails: number
    status: number
    creditorBranchId: number
    debtorBranchId: number
    receiptNumber: number
    paymentPlace: number
    paidAt: number
    paidBy: number
    paidByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchDebtAvgAggregateInputType = {
    amount?: true
    paidAmount?: true
    remainingAmount?: true
  }

  export type BranchDebtSumAggregateInputType = {
    amount?: true
    paidAmount?: true
    remainingAmount?: true
  }

  export type BranchDebtMinAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    amount?: true
    paidAmount?: true
    remainingAmount?: true
    partsDetails?: true
    status?: true
    creditorBranchId?: true
    debtorBranchId?: true
    receiptNumber?: true
    paymentPlace?: true
    paidAt?: true
    paidBy?: true
    paidByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchDebtMaxAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    amount?: true
    paidAmount?: true
    remainingAmount?: true
    partsDetails?: true
    status?: true
    creditorBranchId?: true
    debtorBranchId?: true
    receiptNumber?: true
    paymentPlace?: true
    paidAt?: true
    paidBy?: true
    paidByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchDebtCountAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    amount?: true
    paidAmount?: true
    remainingAmount?: true
    partsDetails?: true
    status?: true
    creditorBranchId?: true
    debtorBranchId?: true
    receiptNumber?: true
    paymentPlace?: true
    paidAt?: true
    paidBy?: true
    paidByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchDebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchDebt to aggregate.
     */
    where?: BranchDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchDebts to fetch.
     */
    orderBy?: BranchDebtOrderByWithRelationInput | BranchDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchDebts
    **/
    _count?: true | BranchDebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchDebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchDebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchDebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchDebtMaxAggregateInputType
  }

  export type GetBranchDebtAggregateType<T extends BranchDebtAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchDebt[P]>
      : GetScalarType<T[P], AggregateBranchDebt[P]>
  }




  export type BranchDebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchDebtWhereInput
    orderBy?: BranchDebtOrderByWithAggregationInput | BranchDebtOrderByWithAggregationInput[]
    by: BranchDebtScalarFieldEnum[] | BranchDebtScalarFieldEnum
    having?: BranchDebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchDebtCountAggregateInputType | true
    _avg?: BranchDebtAvgAggregateInputType
    _sum?: BranchDebtSumAggregateInputType
    _min?: BranchDebtMinAggregateInputType
    _max?: BranchDebtMaxAggregateInputType
  }

  export type BranchDebtGroupByOutputType = {
    id: string
    type: string
    referenceId: string
    machineSerial: string | null
    customerId: string | null
    customerName: string | null
    amount: number
    paidAmount: number
    remainingAmount: number
    partsDetails: string | null
    status: string
    creditorBranchId: string
    debtorBranchId: string
    receiptNumber: string | null
    paymentPlace: string | null
    paidAt: Date | null
    paidBy: string | null
    paidByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BranchDebtCountAggregateOutputType | null
    _avg: BranchDebtAvgAggregateOutputType | null
    _sum: BranchDebtSumAggregateOutputType | null
    _min: BranchDebtMinAggregateOutputType | null
    _max: BranchDebtMaxAggregateOutputType | null
  }

  type GetBranchDebtGroupByPayload<T extends BranchDebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchDebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchDebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchDebtGroupByOutputType[P]>
            : GetScalarType<T[P], BranchDebtGroupByOutputType[P]>
        }
      >
    >


  export type BranchDebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    referenceId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    amount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    partsDetails?: boolean
    status?: boolean
    creditorBranchId?: boolean
    debtorBranchId?: boolean
    receiptNumber?: boolean
    paymentPlace?: boolean
    paidAt?: boolean
    paidBy?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branchDebt"]>

  export type BranchDebtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    referenceId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    amount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    partsDetails?: boolean
    status?: boolean
    creditorBranchId?: boolean
    debtorBranchId?: boolean
    receiptNumber?: boolean
    paymentPlace?: boolean
    paidAt?: boolean
    paidBy?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branchDebt"]>

  export type BranchDebtSelectScalar = {
    id?: boolean
    type?: boolean
    referenceId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    amount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    partsDetails?: boolean
    status?: boolean
    creditorBranchId?: boolean
    debtorBranchId?: boolean
    receiptNumber?: boolean
    paymentPlace?: boolean
    paidAt?: boolean
    paidBy?: boolean
    paidByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BranchDebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchDebt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      referenceId: string
      machineSerial: string | null
      customerId: string | null
      customerName: string | null
      amount: number
      paidAmount: number
      remainingAmount: number
      partsDetails: string | null
      status: string
      creditorBranchId: string
      debtorBranchId: string
      receiptNumber: string | null
      paymentPlace: string | null
      paidAt: Date | null
      paidBy: string | null
      paidByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branchDebt"]>
    composites: {}
  }

  type BranchDebtGetPayload<S extends boolean | null | undefined | BranchDebtDefaultArgs> = $Result.GetResult<Prisma.$BranchDebtPayload, S>

  type BranchDebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchDebtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchDebtCountAggregateInputType | true
    }

  export interface BranchDebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchDebt'], meta: { name: 'BranchDebt' } }
    /**
     * Find zero or one BranchDebt that matches the filter.
     * @param {BranchDebtFindUniqueArgs} args - Arguments to find a BranchDebt
     * @example
     * // Get one BranchDebt
     * const branchDebt = await prisma.branchDebt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchDebtFindUniqueArgs>(args: SelectSubset<T, BranchDebtFindUniqueArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BranchDebt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchDebtFindUniqueOrThrowArgs} args - Arguments to find a BranchDebt
     * @example
     * // Get one BranchDebt
     * const branchDebt = await prisma.branchDebt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchDebtFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchDebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BranchDebt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtFindFirstArgs} args - Arguments to find a BranchDebt
     * @example
     * // Get one BranchDebt
     * const branchDebt = await prisma.branchDebt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchDebtFindFirstArgs>(args?: SelectSubset<T, BranchDebtFindFirstArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BranchDebt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtFindFirstOrThrowArgs} args - Arguments to find a BranchDebt
     * @example
     * // Get one BranchDebt
     * const branchDebt = await prisma.branchDebt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchDebtFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchDebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BranchDebts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchDebts
     * const branchDebts = await prisma.branchDebt.findMany()
     * 
     * // Get first 10 BranchDebts
     * const branchDebts = await prisma.branchDebt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchDebtWithIdOnly = await prisma.branchDebt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchDebtFindManyArgs>(args?: SelectSubset<T, BranchDebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BranchDebt.
     * @param {BranchDebtCreateArgs} args - Arguments to create a BranchDebt.
     * @example
     * // Create one BranchDebt
     * const BranchDebt = await prisma.branchDebt.create({
     *   data: {
     *     // ... data to create a BranchDebt
     *   }
     * })
     * 
     */
    create<T extends BranchDebtCreateArgs>(args: SelectSubset<T, BranchDebtCreateArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BranchDebts.
     * @param {BranchDebtCreateManyArgs} args - Arguments to create many BranchDebts.
     * @example
     * // Create many BranchDebts
     * const branchDebt = await prisma.branchDebt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchDebtCreateManyArgs>(args?: SelectSubset<T, BranchDebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchDebts and returns the data saved in the database.
     * @param {BranchDebtCreateManyAndReturnArgs} args - Arguments to create many BranchDebts.
     * @example
     * // Create many BranchDebts
     * const branchDebt = await prisma.branchDebt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchDebts and only return the `id`
     * const branchDebtWithIdOnly = await prisma.branchDebt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchDebtCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchDebtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BranchDebt.
     * @param {BranchDebtDeleteArgs} args - Arguments to delete one BranchDebt.
     * @example
     * // Delete one BranchDebt
     * const BranchDebt = await prisma.branchDebt.delete({
     *   where: {
     *     // ... filter to delete one BranchDebt
     *   }
     * })
     * 
     */
    delete<T extends BranchDebtDeleteArgs>(args: SelectSubset<T, BranchDebtDeleteArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BranchDebt.
     * @param {BranchDebtUpdateArgs} args - Arguments to update one BranchDebt.
     * @example
     * // Update one BranchDebt
     * const branchDebt = await prisma.branchDebt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchDebtUpdateArgs>(args: SelectSubset<T, BranchDebtUpdateArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BranchDebts.
     * @param {BranchDebtDeleteManyArgs} args - Arguments to filter BranchDebts to delete.
     * @example
     * // Delete a few BranchDebts
     * const { count } = await prisma.branchDebt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDebtDeleteManyArgs>(args?: SelectSubset<T, BranchDebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchDebts
     * const branchDebt = await prisma.branchDebt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchDebtUpdateManyArgs>(args: SelectSubset<T, BranchDebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchDebt.
     * @param {BranchDebtUpsertArgs} args - Arguments to update or create a BranchDebt.
     * @example
     * // Update or create a BranchDebt
     * const branchDebt = await prisma.branchDebt.upsert({
     *   create: {
     *     // ... data to create a BranchDebt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchDebt we want to update
     *   }
     * })
     */
    upsert<T extends BranchDebtUpsertArgs>(args: SelectSubset<T, BranchDebtUpsertArgs<ExtArgs>>): Prisma__BranchDebtClient<$Result.GetResult<Prisma.$BranchDebtPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BranchDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtCountArgs} args - Arguments to filter BranchDebts to count.
     * @example
     * // Count the number of BranchDebts
     * const count = await prisma.branchDebt.count({
     *   where: {
     *     // ... the filter for the BranchDebts we want to count
     *   }
     * })
    **/
    count<T extends BranchDebtCountArgs>(
      args?: Subset<T, BranchDebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchDebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchDebtAggregateArgs>(args: Subset<T, BranchDebtAggregateArgs>): Prisma.PrismaPromise<GetBranchDebtAggregateType<T>>

    /**
     * Group by BranchDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchDebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchDebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchDebtGroupByArgs['orderBy'] }
        : { orderBy?: BranchDebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchDebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchDebt model
   */
  readonly fields: BranchDebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchDebt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchDebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchDebt model
   */ 
  interface BranchDebtFieldRefs {
    readonly id: FieldRef<"BranchDebt", 'String'>
    readonly type: FieldRef<"BranchDebt", 'String'>
    readonly referenceId: FieldRef<"BranchDebt", 'String'>
    readonly machineSerial: FieldRef<"BranchDebt", 'String'>
    readonly customerId: FieldRef<"BranchDebt", 'String'>
    readonly customerName: FieldRef<"BranchDebt", 'String'>
    readonly amount: FieldRef<"BranchDebt", 'Float'>
    readonly paidAmount: FieldRef<"BranchDebt", 'Float'>
    readonly remainingAmount: FieldRef<"BranchDebt", 'Float'>
    readonly partsDetails: FieldRef<"BranchDebt", 'String'>
    readonly status: FieldRef<"BranchDebt", 'String'>
    readonly creditorBranchId: FieldRef<"BranchDebt", 'String'>
    readonly debtorBranchId: FieldRef<"BranchDebt", 'String'>
    readonly receiptNumber: FieldRef<"BranchDebt", 'String'>
    readonly paymentPlace: FieldRef<"BranchDebt", 'String'>
    readonly paidAt: FieldRef<"BranchDebt", 'DateTime'>
    readonly paidBy: FieldRef<"BranchDebt", 'String'>
    readonly paidByUserId: FieldRef<"BranchDebt", 'String'>
    readonly createdAt: FieldRef<"BranchDebt", 'DateTime'>
    readonly updatedAt: FieldRef<"BranchDebt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BranchDebt findUnique
   */
  export type BranchDebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter, which BranchDebt to fetch.
     */
    where: BranchDebtWhereUniqueInput
  }

  /**
   * BranchDebt findUniqueOrThrow
   */
  export type BranchDebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter, which BranchDebt to fetch.
     */
    where: BranchDebtWhereUniqueInput
  }

  /**
   * BranchDebt findFirst
   */
  export type BranchDebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter, which BranchDebt to fetch.
     */
    where?: BranchDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchDebts to fetch.
     */
    orderBy?: BranchDebtOrderByWithRelationInput | BranchDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchDebts.
     */
    cursor?: BranchDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchDebts.
     */
    distinct?: BranchDebtScalarFieldEnum | BranchDebtScalarFieldEnum[]
  }

  /**
   * BranchDebt findFirstOrThrow
   */
  export type BranchDebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter, which BranchDebt to fetch.
     */
    where?: BranchDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchDebts to fetch.
     */
    orderBy?: BranchDebtOrderByWithRelationInput | BranchDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchDebts.
     */
    cursor?: BranchDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchDebts.
     */
    distinct?: BranchDebtScalarFieldEnum | BranchDebtScalarFieldEnum[]
  }

  /**
   * BranchDebt findMany
   */
  export type BranchDebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter, which BranchDebts to fetch.
     */
    where?: BranchDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchDebts to fetch.
     */
    orderBy?: BranchDebtOrderByWithRelationInput | BranchDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchDebts.
     */
    cursor?: BranchDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchDebts.
     */
    skip?: number
    distinct?: BranchDebtScalarFieldEnum | BranchDebtScalarFieldEnum[]
  }

  /**
   * BranchDebt create
   */
  export type BranchDebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * The data needed to create a BranchDebt.
     */
    data: XOR<BranchDebtCreateInput, BranchDebtUncheckedCreateInput>
  }

  /**
   * BranchDebt createMany
   */
  export type BranchDebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchDebts.
     */
    data: BranchDebtCreateManyInput | BranchDebtCreateManyInput[]
  }

  /**
   * BranchDebt createManyAndReturn
   */
  export type BranchDebtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BranchDebts.
     */
    data: BranchDebtCreateManyInput | BranchDebtCreateManyInput[]
  }

  /**
   * BranchDebt update
   */
  export type BranchDebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * The data needed to update a BranchDebt.
     */
    data: XOR<BranchDebtUpdateInput, BranchDebtUncheckedUpdateInput>
    /**
     * Choose, which BranchDebt to update.
     */
    where: BranchDebtWhereUniqueInput
  }

  /**
   * BranchDebt updateMany
   */
  export type BranchDebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchDebts.
     */
    data: XOR<BranchDebtUpdateManyMutationInput, BranchDebtUncheckedUpdateManyInput>
    /**
     * Filter which BranchDebts to update
     */
    where?: BranchDebtWhereInput
  }

  /**
   * BranchDebt upsert
   */
  export type BranchDebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * The filter to search for the BranchDebt to update in case it exists.
     */
    where: BranchDebtWhereUniqueInput
    /**
     * In case the BranchDebt found by the `where` argument doesn't exist, create a new BranchDebt with this data.
     */
    create: XOR<BranchDebtCreateInput, BranchDebtUncheckedCreateInput>
    /**
     * In case the BranchDebt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchDebtUpdateInput, BranchDebtUncheckedUpdateInput>
  }

  /**
   * BranchDebt delete
   */
  export type BranchDebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
    /**
     * Filter which BranchDebt to delete.
     */
    where: BranchDebtWhereUniqueInput
  }

  /**
   * BranchDebt deleteMany
   */
  export type BranchDebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchDebts to delete
     */
    where?: BranchDebtWhereInput
  }

  /**
   * BranchDebt without action
   */
  export type BranchDebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchDebt
     */
    select?: BranchDebtSelect<ExtArgs> | null
  }


  /**
   * Model MaintenanceApprovalRequest
   */

  export type AggregateMaintenanceApprovalRequest = {
    _count: MaintenanceApprovalRequestCountAggregateOutputType | null
    _avg: MaintenanceApprovalRequestAvgAggregateOutputType | null
    _sum: MaintenanceApprovalRequestSumAggregateOutputType | null
    _min: MaintenanceApprovalRequestMinAggregateOutputType | null
    _max: MaintenanceApprovalRequestMaxAggregateOutputType | null
  }

  export type MaintenanceApprovalRequestAvgAggregateOutputType = {
    proposedTotal: number | null
  }

  export type MaintenanceApprovalRequestSumAggregateOutputType = {
    proposedTotal: number | null
  }

  export type MaintenanceApprovalRequestMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    machineSerial: string | null
    customerId: string | null
    customerName: string | null
    proposedParts: string | null
    proposedTotal: number | null
    diagnosis: string | null
    notes: string | null
    status: string | null
    rejectionReason: string | null
    respondedBy: string | null
    respondedById: string | null
    respondedAt: Date | null
    centerBranchId: string | null
    originBranchId: string | null
    createdAt: Date | null
  }

  export type MaintenanceApprovalRequestMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    machineSerial: string | null
    customerId: string | null
    customerName: string | null
    proposedParts: string | null
    proposedTotal: number | null
    diagnosis: string | null
    notes: string | null
    status: string | null
    rejectionReason: string | null
    respondedBy: string | null
    respondedById: string | null
    respondedAt: Date | null
    centerBranchId: string | null
    originBranchId: string | null
    createdAt: Date | null
  }

  export type MaintenanceApprovalRequestCountAggregateOutputType = {
    id: number
    assignmentId: number
    machineSerial: number
    customerId: number
    customerName: number
    proposedParts: number
    proposedTotal: number
    diagnosis: number
    notes: number
    status: number
    rejectionReason: number
    respondedBy: number
    respondedById: number
    respondedAt: number
    centerBranchId: number
    originBranchId: number
    createdAt: number
    _all: number
  }


  export type MaintenanceApprovalRequestAvgAggregateInputType = {
    proposedTotal?: true
  }

  export type MaintenanceApprovalRequestSumAggregateInputType = {
    proposedTotal?: true
  }

  export type MaintenanceApprovalRequestMinAggregateInputType = {
    id?: true
    assignmentId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    proposedParts?: true
    proposedTotal?: true
    diagnosis?: true
    notes?: true
    status?: true
    rejectionReason?: true
    respondedBy?: true
    respondedById?: true
    respondedAt?: true
    centerBranchId?: true
    originBranchId?: true
    createdAt?: true
  }

  export type MaintenanceApprovalRequestMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    proposedParts?: true
    proposedTotal?: true
    diagnosis?: true
    notes?: true
    status?: true
    rejectionReason?: true
    respondedBy?: true
    respondedById?: true
    respondedAt?: true
    centerBranchId?: true
    originBranchId?: true
    createdAt?: true
  }

  export type MaintenanceApprovalRequestCountAggregateInputType = {
    id?: true
    assignmentId?: true
    machineSerial?: true
    customerId?: true
    customerName?: true
    proposedParts?: true
    proposedTotal?: true
    diagnosis?: true
    notes?: true
    status?: true
    rejectionReason?: true
    respondedBy?: true
    respondedById?: true
    respondedAt?: true
    centerBranchId?: true
    originBranchId?: true
    createdAt?: true
    _all?: true
  }

  export type MaintenanceApprovalRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceApprovalRequest to aggregate.
     */
    where?: MaintenanceApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovalRequests to fetch.
     */
    orderBy?: MaintenanceApprovalRequestOrderByWithRelationInput | MaintenanceApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceApprovalRequests
    **/
    _count?: true | MaintenanceApprovalRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceApprovalRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceApprovalRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceApprovalRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceApprovalRequestMaxAggregateInputType
  }

  export type GetMaintenanceApprovalRequestAggregateType<T extends MaintenanceApprovalRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceApprovalRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceApprovalRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceApprovalRequest[P]>
  }




  export type MaintenanceApprovalRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceApprovalRequestWhereInput
    orderBy?: MaintenanceApprovalRequestOrderByWithAggregationInput | MaintenanceApprovalRequestOrderByWithAggregationInput[]
    by: MaintenanceApprovalRequestScalarFieldEnum[] | MaintenanceApprovalRequestScalarFieldEnum
    having?: MaintenanceApprovalRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceApprovalRequestCountAggregateInputType | true
    _avg?: MaintenanceApprovalRequestAvgAggregateInputType
    _sum?: MaintenanceApprovalRequestSumAggregateInputType
    _min?: MaintenanceApprovalRequestMinAggregateInputType
    _max?: MaintenanceApprovalRequestMaxAggregateInputType
  }

  export type MaintenanceApprovalRequestGroupByOutputType = {
    id: string
    assignmentId: string
    machineSerial: string
    customerId: string | null
    customerName: string
    proposedParts: string
    proposedTotal: number
    diagnosis: string | null
    notes: string | null
    status: string
    rejectionReason: string | null
    respondedBy: string | null
    respondedById: string | null
    respondedAt: Date | null
    centerBranchId: string
    originBranchId: string
    createdAt: Date
    _count: MaintenanceApprovalRequestCountAggregateOutputType | null
    _avg: MaintenanceApprovalRequestAvgAggregateOutputType | null
    _sum: MaintenanceApprovalRequestSumAggregateOutputType | null
    _min: MaintenanceApprovalRequestMinAggregateOutputType | null
    _max: MaintenanceApprovalRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceApprovalRequestGroupByPayload<T extends MaintenanceApprovalRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceApprovalRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceApprovalRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceApprovalRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceApprovalRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceApprovalRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    respondedBy?: boolean
    respondedById?: boolean
    respondedAt?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["maintenanceApprovalRequest"]>

  export type MaintenanceApprovalRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    respondedBy?: boolean
    respondedById?: boolean
    respondedAt?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["maintenanceApprovalRequest"]>

  export type MaintenanceApprovalRequestSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    machineSerial?: boolean
    customerId?: boolean
    customerName?: boolean
    proposedParts?: boolean
    proposedTotal?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    respondedBy?: boolean
    respondedById?: boolean
    respondedAt?: boolean
    centerBranchId?: boolean
    originBranchId?: boolean
    createdAt?: boolean
  }


  export type $MaintenanceApprovalRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceApprovalRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      machineSerial: string
      customerId: string | null
      customerName: string
      proposedParts: string
      proposedTotal: number
      diagnosis: string | null
      notes: string | null
      status: string
      rejectionReason: string | null
      respondedBy: string | null
      respondedById: string | null
      respondedAt: Date | null
      centerBranchId: string
      originBranchId: string
      createdAt: Date
    }, ExtArgs["result"]["maintenanceApprovalRequest"]>
    composites: {}
  }

  type MaintenanceApprovalRequestGetPayload<S extends boolean | null | undefined | MaintenanceApprovalRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload, S>

  type MaintenanceApprovalRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceApprovalRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceApprovalRequestCountAggregateInputType | true
    }

  export interface MaintenanceApprovalRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceApprovalRequest'], meta: { name: 'MaintenanceApprovalRequest' } }
    /**
     * Find zero or one MaintenanceApprovalRequest that matches the filter.
     * @param {MaintenanceApprovalRequestFindUniqueArgs} args - Arguments to find a MaintenanceApprovalRequest
     * @example
     * // Get one MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceApprovalRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceApprovalRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceApprovalRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceApprovalRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceApprovalRequest
     * @example
     * // Get one MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceApprovalRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceApprovalRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceApprovalRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestFindFirstArgs} args - Arguments to find a MaintenanceApprovalRequest
     * @example
     * // Get one MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceApprovalRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceApprovalRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceApprovalRequest
     * @example
     * // Get one MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceApprovalRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceApprovalRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceApprovalRequests
     * const maintenanceApprovalRequests = await prisma.maintenanceApprovalRequest.findMany()
     * 
     * // Get first 10 MaintenanceApprovalRequests
     * const maintenanceApprovalRequests = await prisma.maintenanceApprovalRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceApprovalRequestWithIdOnly = await prisma.maintenanceApprovalRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceApprovalRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceApprovalRequest.
     * @param {MaintenanceApprovalRequestCreateArgs} args - Arguments to create a MaintenanceApprovalRequest.
     * @example
     * // Create one MaintenanceApprovalRequest
     * const MaintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceApprovalRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceApprovalRequestCreateArgs>(args: SelectSubset<T, MaintenanceApprovalRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceApprovalRequests.
     * @param {MaintenanceApprovalRequestCreateManyArgs} args - Arguments to create many MaintenanceApprovalRequests.
     * @example
     * // Create many MaintenanceApprovalRequests
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceApprovalRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceApprovalRequests and returns the data saved in the database.
     * @param {MaintenanceApprovalRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceApprovalRequests.
     * @example
     * // Create many MaintenanceApprovalRequests
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceApprovalRequests and only return the `id`
     * const maintenanceApprovalRequestWithIdOnly = await prisma.maintenanceApprovalRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceApprovalRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceApprovalRequest.
     * @param {MaintenanceApprovalRequestDeleteArgs} args - Arguments to delete one MaintenanceApprovalRequest.
     * @example
     * // Delete one MaintenanceApprovalRequest
     * const MaintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceApprovalRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceApprovalRequestDeleteArgs>(args: SelectSubset<T, MaintenanceApprovalRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceApprovalRequest.
     * @param {MaintenanceApprovalRequestUpdateArgs} args - Arguments to update one MaintenanceApprovalRequest.
     * @example
     * // Update one MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceApprovalRequestUpdateArgs>(args: SelectSubset<T, MaintenanceApprovalRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceApprovalRequests.
     * @param {MaintenanceApprovalRequestDeleteManyArgs} args - Arguments to filter MaintenanceApprovalRequests to delete.
     * @example
     * // Delete a few MaintenanceApprovalRequests
     * const { count } = await prisma.maintenanceApprovalRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceApprovalRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceApprovalRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceApprovalRequests
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceApprovalRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceApprovalRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceApprovalRequest.
     * @param {MaintenanceApprovalRequestUpsertArgs} args - Arguments to update or create a MaintenanceApprovalRequest.
     * @example
     * // Update or create a MaintenanceApprovalRequest
     * const maintenanceApprovalRequest = await prisma.maintenanceApprovalRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceApprovalRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceApprovalRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceApprovalRequestUpsertArgs>(args: SelectSubset<T, MaintenanceApprovalRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceApprovalRequestClient<$Result.GetResult<Prisma.$MaintenanceApprovalRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestCountArgs} args - Arguments to filter MaintenanceApprovalRequests to count.
     * @example
     * // Count the number of MaintenanceApprovalRequests
     * const count = await prisma.maintenanceApprovalRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceApprovalRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceApprovalRequestCountArgs>(
      args?: Subset<T, MaintenanceApprovalRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceApprovalRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceApprovalRequestAggregateArgs>(args: Subset<T, MaintenanceApprovalRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceApprovalRequestAggregateType<T>>

    /**
     * Group by MaintenanceApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceApprovalRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceApprovalRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceApprovalRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceApprovalRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceApprovalRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceApprovalRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceApprovalRequest model
   */
  readonly fields: MaintenanceApprovalRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceApprovalRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceApprovalRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceApprovalRequest model
   */ 
  interface MaintenanceApprovalRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly assignmentId: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly machineSerial: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly customerId: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly customerName: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly proposedParts: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly proposedTotal: FieldRef<"MaintenanceApprovalRequest", 'Float'>
    readonly diagnosis: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly notes: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly status: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly rejectionReason: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly respondedBy: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly respondedById: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly respondedAt: FieldRef<"MaintenanceApprovalRequest", 'DateTime'>
    readonly centerBranchId: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly originBranchId: FieldRef<"MaintenanceApprovalRequest", 'String'>
    readonly createdAt: FieldRef<"MaintenanceApprovalRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceApprovalRequest findUnique
   */
  export type MaintenanceApprovalRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovalRequest to fetch.
     */
    where: MaintenanceApprovalRequestWhereUniqueInput
  }

  /**
   * MaintenanceApprovalRequest findUniqueOrThrow
   */
  export type MaintenanceApprovalRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovalRequest to fetch.
     */
    where: MaintenanceApprovalRequestWhereUniqueInput
  }

  /**
   * MaintenanceApprovalRequest findFirst
   */
  export type MaintenanceApprovalRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovalRequest to fetch.
     */
    where?: MaintenanceApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovalRequests to fetch.
     */
    orderBy?: MaintenanceApprovalRequestOrderByWithRelationInput | MaintenanceApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceApprovalRequests.
     */
    cursor?: MaintenanceApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceApprovalRequests.
     */
    distinct?: MaintenanceApprovalRequestScalarFieldEnum | MaintenanceApprovalRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceApprovalRequest findFirstOrThrow
   */
  export type MaintenanceApprovalRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovalRequest to fetch.
     */
    where?: MaintenanceApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovalRequests to fetch.
     */
    orderBy?: MaintenanceApprovalRequestOrderByWithRelationInput | MaintenanceApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceApprovalRequests.
     */
    cursor?: MaintenanceApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceApprovalRequests.
     */
    distinct?: MaintenanceApprovalRequestScalarFieldEnum | MaintenanceApprovalRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceApprovalRequest findMany
   */
  export type MaintenanceApprovalRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter, which MaintenanceApprovalRequests to fetch.
     */
    where?: MaintenanceApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceApprovalRequests to fetch.
     */
    orderBy?: MaintenanceApprovalRequestOrderByWithRelationInput | MaintenanceApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceApprovalRequests.
     */
    cursor?: MaintenanceApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceApprovalRequests.
     */
    skip?: number
    distinct?: MaintenanceApprovalRequestScalarFieldEnum | MaintenanceApprovalRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceApprovalRequest create
   */
  export type MaintenanceApprovalRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceApprovalRequest.
     */
    data: XOR<MaintenanceApprovalRequestCreateInput, MaintenanceApprovalRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceApprovalRequest createMany
   */
  export type MaintenanceApprovalRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceApprovalRequests.
     */
    data: MaintenanceApprovalRequestCreateManyInput | MaintenanceApprovalRequestCreateManyInput[]
  }

  /**
   * MaintenanceApprovalRequest createManyAndReturn
   */
  export type MaintenanceApprovalRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceApprovalRequests.
     */
    data: MaintenanceApprovalRequestCreateManyInput | MaintenanceApprovalRequestCreateManyInput[]
  }

  /**
   * MaintenanceApprovalRequest update
   */
  export type MaintenanceApprovalRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceApprovalRequest.
     */
    data: XOR<MaintenanceApprovalRequestUpdateInput, MaintenanceApprovalRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceApprovalRequest to update.
     */
    where: MaintenanceApprovalRequestWhereUniqueInput
  }

  /**
   * MaintenanceApprovalRequest updateMany
   */
  export type MaintenanceApprovalRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceApprovalRequests.
     */
    data: XOR<MaintenanceApprovalRequestUpdateManyMutationInput, MaintenanceApprovalRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceApprovalRequests to update
     */
    where?: MaintenanceApprovalRequestWhereInput
  }

  /**
   * MaintenanceApprovalRequest upsert
   */
  export type MaintenanceApprovalRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceApprovalRequest to update in case it exists.
     */
    where: MaintenanceApprovalRequestWhereUniqueInput
    /**
     * In case the MaintenanceApprovalRequest found by the `where` argument doesn't exist, create a new MaintenanceApprovalRequest with this data.
     */
    create: XOR<MaintenanceApprovalRequestCreateInput, MaintenanceApprovalRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceApprovalRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceApprovalRequestUpdateInput, MaintenanceApprovalRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceApprovalRequest delete
   */
  export type MaintenanceApprovalRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
    /**
     * Filter which MaintenanceApprovalRequest to delete.
     */
    where: MaintenanceApprovalRequestWhereUniqueInput
  }

  /**
   * MaintenanceApprovalRequest deleteMany
   */
  export type MaintenanceApprovalRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceApprovalRequests to delete
     */
    where?: MaintenanceApprovalRequestWhereInput
  }

  /**
   * MaintenanceApprovalRequest without action
   */
  export type MaintenanceApprovalRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceApprovalRequest
     */
    select?: MaintenanceApprovalRequestSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    email: 'email',
    displayName: 'displayName',
    role: 'role',
    canDoMaintenance: 'canDoMaintenance',
    password: 'password',
    theme: 'theme',
    fontFamily: 'fontFamily',
    fontSize: 'fontSize',
    highlightEffect: 'highlightEffect',
    notificationSound: 'notificationSound',
    mobilePush: 'mobilePush',
    createdAt: 'createdAt',
    branchId: 'branchId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ClientTypeScalarFieldEnum = (typeof ClientTypeScalarFieldEnum)[keyof typeof ClientTypeScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    type: 'type',
    isActive: 'isActive',
    parentBranchId: 'parentBranchId',
    maintenanceCenterId: 'maintenanceCenterId',
    createdAt: 'createdAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    bkcode: 'bkcode',
    client_name: 'client_name',
    supply_office: 'supply_office',
    operating_date: 'operating_date',
    address: 'address',
    contact_person: 'contact_person',
    scanned_id_path: 'scanned_id_path',
    national_id: 'national_id',
    dept: 'dept',
    telephone_1: 'telephone_1',
    telephone_2: 'telephone_2',
    has_gates: 'has_gates',
    bk_type: 'bk_type',
    notes: 'notes',
    papers_date: 'papers_date',
    isSpecial: 'isSpecial',
    clienttype: 'clienttype',
    branchId: 'branchId'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const MachineParameterScalarFieldEnum: {
    id: 'id',
    prefix: 'prefix',
    model: 'model',
    manufacturer: 'manufacturer'
  };

  export type MachineParameterScalarFieldEnum = (typeof MachineParameterScalarFieldEnum)[keyof typeof MachineParameterScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    role: 'role',
    permissionType: 'permissionType',
    permissionKey: 'permissionKey',
    isAllowed: 'isAllowed',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const SparePartScalarFieldEnum: {
    id: 'id',
    partNumber: 'partNumber',
    name: 'name',
    description: 'description',
    compatibleModels: 'compatibleModels',
    defaultCost: 'defaultCost',
    isConsumable: 'isConsumable',
    allowsMultiple: 'allowsMultiple'
  };

  export type SparePartScalarFieldEnum = (typeof SparePartScalarFieldEnum)[keyof typeof SparePartScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    partId: 'partId',
    quantity: 'quantity',
    minLevel: 'minLevel',
    location: 'location',
    branchId: 'branchId'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const MaintenanceRequestScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    posMachineId: 'posMachineId',
    customerName: 'customerName',
    machineModel: 'machineModel',
    machineManufacturer: 'machineManufacturer',
    serialNumber: 'serialNumber',
    status: 'status',
    branchId: 'branchId',
    servicedByBranchId: 'servicedByBranchId',
    technician: 'technician',
    notes: 'notes',
    complaint: 'complaint',
    actionTaken: 'actionTaken',
    createdAt: 'createdAt',
    closingUserId: 'closingUserId',
    closingUserName: 'closingUserName',
    closingTimestamp: 'closingTimestamp',
    usedParts: 'usedParts',
    receiptNumber: 'receiptNumber',
    totalCost: 'totalCost'
  };

  export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


  export const PriceChangeLogScalarFieldEnum: {
    id: 'id',
    partId: 'partId',
    oldCost: 'oldCost',
    newCost: 'newCost',
    changedAt: 'changedAt',
    userId: 'userId'
  };

  export type PriceChangeLogScalarFieldEnum = (typeof PriceChangeLogScalarFieldEnum)[keyof typeof PriceChangeLogScalarFieldEnum]


  export const UsedPartLogScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    customerId: 'customerId',
    customerName: 'customerName',
    posMachineId: 'posMachineId',
    technician: 'technician',
    closedByUserId: 'closedByUserId',
    closedAt: 'closedAt',
    parts: 'parts',
    receiptNumber: 'receiptNumber',
    branchId: 'branchId'
  };

  export type UsedPartLogScalarFieldEnum = (typeof UsedPartLogScalarFieldEnum)[keyof typeof UsedPartLogScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    partId: 'partId',
    type: 'type',
    quantity: 'quantity',
    reason: 'reason',
    requestId: 'requestId',
    userId: 'userId',
    performedBy: 'performedBy',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    customerName: 'customerName',
    requestId: 'requestId',
    amount: 'amount',
    type: 'type',
    reason: 'reason',
    paymentPlace: 'paymentPlace',
    paymentMethod: 'paymentMethod',
    receiptNumber: 'receiptNumber',
    notes: 'notes',
    userId: 'userId',
    userName: 'userName',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const MachineMovementLogScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    serialNumber: 'serialNumber',
    action: 'action',
    details: 'details',
    performedBy: 'performedBy',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type MachineMovementLogScalarFieldEnum = (typeof MachineMovementLogScalarFieldEnum)[keyof typeof MachineMovementLogScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    details: 'details',
    performedBy: 'performedBy',
    userId: 'userId',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const InstallmentScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    dueDate: 'dueDate',
    amount: 'amount',
    isPaid: 'isPaid',
    paidAt: 'paidAt',
    description: 'description',
    paidAmount: 'paidAmount',
    paymentPlace: 'paymentPlace',
    receiptNumber: 'receiptNumber',
    branchId: 'branchId'
  };

  export type InstallmentScalarFieldEnum = (typeof InstallmentScalarFieldEnum)[keyof typeof InstallmentScalarFieldEnum]


  export const MachineSaleScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    customerId: 'customerId',
    saleDate: 'saleDate',
    type: 'type',
    totalPrice: 'totalPrice',
    paidAmount: 'paidAmount',
    status: 'status',
    notes: 'notes',
    branchId: 'branchId'
  };

  export type MachineSaleScalarFieldEnum = (typeof MachineSaleScalarFieldEnum)[keyof typeof MachineSaleScalarFieldEnum]


  export const PosMachineScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    posId: 'posId',
    model: 'model',
    manufacturer: 'manufacturer',
    customerId: 'customerId',
    isMain: 'isMain',
    branchId: 'branchId'
  };

  export type PosMachineScalarFieldEnum = (typeof PosMachineScalarFieldEnum)[keyof typeof PosMachineScalarFieldEnum]


  export const SimCardScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    type: 'type',
    customerId: 'customerId',
    branchId: 'branchId'
  };

  export type SimCardScalarFieldEnum = (typeof SimCardScalarFieldEnum)[keyof typeof SimCardScalarFieldEnum]


  export const WarehouseMachineScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    model: 'model',
    manufacturer: 'manufacturer',
    status: 'status',
    resolution: 'resolution',
    notes: 'notes',
    importDate: 'importDate',
    updatedAt: 'updatedAt',
    originalOwnerId: 'originalOwnerId',
    branchId: 'branchId',
    requestId: 'requestId',
    customerId: 'customerId',
    customerName: 'customerName',
    readyForPickup: 'readyForPickup',
    currentAssignmentId: 'currentAssignmentId',
    currentTechnicianId: 'currentTechnicianId',
    currentTechnicianName: 'currentTechnicianName',
    originBranchId: 'originBranchId',
    proposedParts: 'proposedParts',
    proposedRepairNotes: 'proposedRepairNotes',
    proposedTotalCost: 'proposedTotalCost',
    repairNotes: 'repairNotes',
    totalCost: 'totalCost',
    usedParts: 'usedParts'
  };

  export type WarehouseMachineScalarFieldEnum = (typeof WarehouseMachineScalarFieldEnum)[keyof typeof WarehouseMachineScalarFieldEnum]


  export const WarehouseSimScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    type: 'type',
    status: 'status',
    notes: 'notes',
    importDate: 'importDate',
    updatedAt: 'updatedAt',
    branchId: 'branchId'
  };

  export type WarehouseSimScalarFieldEnum = (typeof WarehouseSimScalarFieldEnum)[keyof typeof WarehouseSimScalarFieldEnum]


  export const SimMovementLogScalarFieldEnum: {
    id: 'id',
    simId: 'simId',
    serialNumber: 'serialNumber',
    action: 'action',
    details: 'details',
    performedBy: 'performedBy',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type SimMovementLogScalarFieldEnum = (typeof SimMovementLogScalarFieldEnum)[keyof typeof SimMovementLogScalarFieldEnum]


  export const TransferOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    waybillNumber: 'waybillNumber',
    branchId: 'branchId',
    fromBranchId: 'fromBranchId',
    toBranchId: 'toBranchId',
    status: 'status',
    type: 'type',
    driverName: 'driverName',
    driverPhone: 'driverPhone',
    notes: 'notes',
    createdBy: 'createdBy',
    createdByName: 'createdByName',
    createdByUserId: 'createdByUserId',
    receivedByUserId: 'receivedByUserId',
    receivedAt: 'receivedAt',
    receivedBy: 'receivedBy',
    receivedByName: 'receivedByName',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferOrderScalarFieldEnum = (typeof TransferOrderScalarFieldEnum)[keyof typeof TransferOrderScalarFieldEnum]


  export const TransferOrderItemScalarFieldEnum: {
    id: 'id',
    transferOrderId: 'transferOrderId',
    serialNumber: 'serialNumber',
    type: 'type',
    model: 'model',
    manufacturer: 'manufacturer',
    isReceived: 'isReceived',
    receivedAt: 'receivedAt',
    notes: 'notes'
  };

  export type TransferOrderItemScalarFieldEnum = (typeof TransferOrderItemScalarFieldEnum)[keyof typeof TransferOrderItemScalarFieldEnum]


  export const MaintenanceApprovalScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    cost: 'cost',
    parts: 'parts',
    status: 'status',
    notes: 'notes',
    branchId: 'branchId',
    createdAt: 'createdAt',
    respondedAt: 'respondedAt',
    respondedBy: 'respondedBy'
  };

  export type MaintenanceApprovalScalarFieldEnum = (typeof MaintenanceApprovalScalarFieldEnum)[keyof typeof MaintenanceApprovalScalarFieldEnum]


  export const RepairVoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    requestId: 'requestId',
    type: 'type',
    parts: 'parts',
    totalCost: 'totalCost',
    branchId: 'branchId',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type RepairVoucherScalarFieldEnum = (typeof RepairVoucherScalarFieldEnum)[keyof typeof RepairVoucherScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    link: 'link',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ServiceAssignmentScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    serialNumber: 'serialNumber',
    technicianId: 'technicianId',
    technicianName: 'technicianName',
    status: 'status',
    proposedParts: 'proposedParts',
    proposedTotal: 'proposedTotal',
    usedParts: 'usedParts',
    totalCost: 'totalCost',
    needsApproval: 'needsApproval',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    rejectionReason: 'rejectionReason',
    actionTaken: 'actionTaken',
    resolution: 'resolution',
    assignedAt: 'assignedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    customerId: 'customerId',
    customerName: 'customerName',
    requestId: 'requestId',
    branchId: 'branchId',
    centerBranchId: 'centerBranchId',
    originBranchId: 'originBranchId'
  };

  export type ServiceAssignmentScalarFieldEnum = (typeof ServiceAssignmentScalarFieldEnum)[keyof typeof ServiceAssignmentScalarFieldEnum]


  export const ServiceAssignmentLogScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    action: 'action',
    details: 'details',
    performedBy: 'performedBy',
    performedById: 'performedById',
    performedAt: 'performedAt'
  };

  export type ServiceAssignmentLogScalarFieldEnum = (typeof ServiceAssignmentLogScalarFieldEnum)[keyof typeof ServiceAssignmentLogScalarFieldEnum]


  export const BranchDebtScalarFieldEnum: {
    id: 'id',
    type: 'type',
    referenceId: 'referenceId',
    machineSerial: 'machineSerial',
    customerId: 'customerId',
    customerName: 'customerName',
    amount: 'amount',
    paidAmount: 'paidAmount',
    remainingAmount: 'remainingAmount',
    partsDetails: 'partsDetails',
    status: 'status',
    creditorBranchId: 'creditorBranchId',
    debtorBranchId: 'debtorBranchId',
    receiptNumber: 'receiptNumber',
    paymentPlace: 'paymentPlace',
    paidAt: 'paidAt',
    paidBy: 'paidBy',
    paidByUserId: 'paidByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchDebtScalarFieldEnum = (typeof BranchDebtScalarFieldEnum)[keyof typeof BranchDebtScalarFieldEnum]


  export const MaintenanceApprovalRequestScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    machineSerial: 'machineSerial',
    customerId: 'customerId',
    customerName: 'customerName',
    proposedParts: 'proposedParts',
    proposedTotal: 'proposedTotal',
    diagnosis: 'diagnosis',
    notes: 'notes',
    status: 'status',
    rejectionReason: 'rejectionReason',
    respondedBy: 'respondedBy',
    respondedById: 'respondedById',
    respondedAt: 'respondedAt',
    centerBranchId: 'centerBranchId',
    originBranchId: 'originBranchId',
    createdAt: 'createdAt'
  };

  export type MaintenanceApprovalRequestScalarFieldEnum = (typeof MaintenanceApprovalRequestScalarFieldEnum)[keyof typeof MaintenanceApprovalRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    uid?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    canDoMaintenance?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    theme?: StringNullableFilter<"User"> | string | null
    fontFamily?: StringNullableFilter<"User"> | string | null
    fontSize?: StringNullableFilter<"User"> | string | null
    highlightEffect?: BoolFilter<"User"> | boolean
    notificationSound?: BoolFilter<"User"> | boolean
    mobilePush?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    uid?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    canDoMaintenance?: SortOrder
    password?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    highlightEffect?: SortOrder
    notificationSound?: SortOrder
    mobilePush?: SortOrder
    createdAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    uid?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    canDoMaintenance?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    theme?: StringNullableFilter<"User"> | string | null
    fontFamily?: StringNullableFilter<"User"> | string | null
    fontSize?: StringNullableFilter<"User"> | string | null
    highlightEffect?: BoolFilter<"User"> | boolean
    notificationSound?: BoolFilter<"User"> | boolean
    mobilePush?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    uid?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    canDoMaintenance?: SortOrder
    password?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    highlightEffect?: SortOrder
    notificationSound?: SortOrder
    mobilePush?: SortOrder
    createdAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    uid?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    canDoMaintenance?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    theme?: StringNullableWithAggregatesFilter<"User"> | string | null
    fontFamily?: StringNullableWithAggregatesFilter<"User"> | string | null
    fontSize?: StringNullableWithAggregatesFilter<"User"> | string | null
    highlightEffect?: BoolWithAggregatesFilter<"User"> | boolean
    notificationSound?: BoolWithAggregatesFilter<"User"> | boolean
    mobilePush?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientTypeWhereInput = {
    AND?: ClientTypeWhereInput | ClientTypeWhereInput[]
    OR?: ClientTypeWhereInput[]
    NOT?: ClientTypeWhereInput | ClientTypeWhereInput[]
    id?: StringFilter<"ClientType"> | string
    name?: StringFilter<"ClientType"> | string
    description?: StringNullableFilter<"ClientType"> | string | null
    createdAt?: DateTimeFilter<"ClientType"> | Date | string
  }

  export type ClientTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ClientTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ClientTypeWhereInput | ClientTypeWhereInput[]
    OR?: ClientTypeWhereInput[]
    NOT?: ClientTypeWhereInput | ClientTypeWhereInput[]
    description?: StringNullableFilter<"ClientType"> | string | null
    createdAt?: DateTimeFilter<"ClientType"> | Date | string
  }, "id" | "name">

  export type ClientTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClientTypeCountOrderByAggregateInput
    _max?: ClientTypeMaxOrderByAggregateInput
    _min?: ClientTypeMinOrderByAggregateInput
  }

  export type ClientTypeScalarWhereWithAggregatesInput = {
    AND?: ClientTypeScalarWhereWithAggregatesInput | ClientTypeScalarWhereWithAggregatesInput[]
    OR?: ClientTypeScalarWhereWithAggregatesInput[]
    NOT?: ClientTypeScalarWhereWithAggregatesInput | ClientTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientType"> | string
    name?: StringWithAggregatesFilter<"ClientType"> | string
    description?: StringNullableWithAggregatesFilter<"ClientType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientType"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    type?: StringFilter<"Branch"> | string
    isActive?: BoolFilter<"Branch"> | boolean
    parentBranchId?: StringNullableFilter<"Branch"> | string | null
    maintenanceCenterId?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    maintenanceCenter?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    servicedBranches?: BranchListRelationFilter
    parentBranch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    childBranches?: BranchListRelationFilter
    customers?: CustomerListRelationFilter
    installments?: InstallmentListRelationFilter
    inventory?: InventoryItemListRelationFilter
    machineMovements?: MachineMovementLogListRelationFilter
    sales?: MachineSaleListRelationFilter
    approvals?: MaintenanceApprovalListRelationFilter
    requests?: MaintenanceRequestListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    posMachines?: PosMachineListRelationFilter
    vouchers?: RepairVoucherListRelationFilter
    simCards?: SimCardListRelationFilter
    simMovements?: SimMovementLogListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    receivedTransfers?: TransferOrderListRelationFilter
    sentTransfers?: TransferOrderListRelationFilter
    usedPartLogs?: UsedPartLogListRelationFilter
    users?: UserListRelationFilter
    warehouseMachines?: WarehouseMachineListRelationFilter
    warehouseSims?: WarehouseSimListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    parentBranchId?: SortOrderInput | SortOrder
    maintenanceCenterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    maintenanceCenter?: BranchOrderByWithRelationInput
    servicedBranches?: BranchOrderByRelationAggregateInput
    parentBranch?: BranchOrderByWithRelationInput
    childBranches?: BranchOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    installments?: InstallmentOrderByRelationAggregateInput
    inventory?: InventoryItemOrderByRelationAggregateInput
    machineMovements?: MachineMovementLogOrderByRelationAggregateInput
    sales?: MachineSaleOrderByRelationAggregateInput
    approvals?: MaintenanceApprovalOrderByRelationAggregateInput
    requests?: MaintenanceRequestOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    posMachines?: PosMachineOrderByRelationAggregateInput
    vouchers?: RepairVoucherOrderByRelationAggregateInput
    simCards?: SimCardOrderByRelationAggregateInput
    simMovements?: SimMovementLogOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    systemLogs?: SystemLogOrderByRelationAggregateInput
    receivedTransfers?: TransferOrderOrderByRelationAggregateInput
    sentTransfers?: TransferOrderOrderByRelationAggregateInput
    usedPartLogs?: UsedPartLogOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    warehouseMachines?: WarehouseMachineOrderByRelationAggregateInput
    warehouseSims?: WarehouseSimOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    type?: StringFilter<"Branch"> | string
    isActive?: BoolFilter<"Branch"> | boolean
    parentBranchId?: StringNullableFilter<"Branch"> | string | null
    maintenanceCenterId?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    maintenanceCenter?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    servicedBranches?: BranchListRelationFilter
    parentBranch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    childBranches?: BranchListRelationFilter
    customers?: CustomerListRelationFilter
    installments?: InstallmentListRelationFilter
    inventory?: InventoryItemListRelationFilter
    machineMovements?: MachineMovementLogListRelationFilter
    sales?: MachineSaleListRelationFilter
    approvals?: MaintenanceApprovalListRelationFilter
    requests?: MaintenanceRequestListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    posMachines?: PosMachineListRelationFilter
    vouchers?: RepairVoucherListRelationFilter
    simCards?: SimCardListRelationFilter
    simMovements?: SimMovementLogListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    receivedTransfers?: TransferOrderListRelationFilter
    sentTransfers?: TransferOrderListRelationFilter
    usedPartLogs?: UsedPartLogListRelationFilter
    users?: UserListRelationFilter
    warehouseMachines?: WarehouseMachineListRelationFilter
    warehouseSims?: WarehouseSimListRelationFilter
  }, "id" | "code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    parentBranchId?: SortOrderInput | SortOrder
    maintenanceCenterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    type?: StringWithAggregatesFilter<"Branch"> | string
    isActive?: BoolWithAggregatesFilter<"Branch"> | boolean
    parentBranchId?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    maintenanceCenterId?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    bkcode?: StringFilter<"Customer"> | string
    client_name?: StringFilter<"Customer"> | string
    supply_office?: StringNullableFilter<"Customer"> | string | null
    operating_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    contact_person?: StringNullableFilter<"Customer"> | string | null
    scanned_id_path?: StringNullableFilter<"Customer"> | string | null
    national_id?: StringNullableFilter<"Customer"> | string | null
    dept?: StringNullableFilter<"Customer"> | string | null
    telephone_1?: StringNullableFilter<"Customer"> | string | null
    telephone_2?: StringNullableFilter<"Customer"> | string | null
    has_gates?: BoolNullableFilter<"Customer"> | boolean | null
    bk_type?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    papers_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isSpecial?: BoolNullableFilter<"Customer"> | boolean | null
    clienttype?: StringNullableFilter<"Customer"> | string | null
    branchId?: StringNullableFilter<"Customer"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    sales?: MachineSaleListRelationFilter
    requests?: MaintenanceRequestListRelationFilter
    payments?: PaymentListRelationFilter
    machines?: PosMachineListRelationFilter
    simCards?: SimCardListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    bkcode?: SortOrder
    client_name?: SortOrder
    supply_office?: SortOrderInput | SortOrder
    operating_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_person?: SortOrderInput | SortOrder
    scanned_id_path?: SortOrderInput | SortOrder
    national_id?: SortOrderInput | SortOrder
    dept?: SortOrderInput | SortOrder
    telephone_1?: SortOrderInput | SortOrder
    telephone_2?: SortOrderInput | SortOrder
    has_gates?: SortOrderInput | SortOrder
    bk_type?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    papers_date?: SortOrderInput | SortOrder
    isSpecial?: SortOrderInput | SortOrder
    clienttype?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    sales?: MachineSaleOrderByRelationAggregateInput
    requests?: MaintenanceRequestOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    machines?: PosMachineOrderByRelationAggregateInput
    simCards?: SimCardOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bkcode?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    client_name?: StringFilter<"Customer"> | string
    supply_office?: StringNullableFilter<"Customer"> | string | null
    operating_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    contact_person?: StringNullableFilter<"Customer"> | string | null
    scanned_id_path?: StringNullableFilter<"Customer"> | string | null
    national_id?: StringNullableFilter<"Customer"> | string | null
    dept?: StringNullableFilter<"Customer"> | string | null
    telephone_1?: StringNullableFilter<"Customer"> | string | null
    telephone_2?: StringNullableFilter<"Customer"> | string | null
    has_gates?: BoolNullableFilter<"Customer"> | boolean | null
    bk_type?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    papers_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isSpecial?: BoolNullableFilter<"Customer"> | boolean | null
    clienttype?: StringNullableFilter<"Customer"> | string | null
    branchId?: StringNullableFilter<"Customer"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    sales?: MachineSaleListRelationFilter
    requests?: MaintenanceRequestListRelationFilter
    payments?: PaymentListRelationFilter
    machines?: PosMachineListRelationFilter
    simCards?: SimCardListRelationFilter
  }, "id" | "bkcode">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    bkcode?: SortOrder
    client_name?: SortOrder
    supply_office?: SortOrderInput | SortOrder
    operating_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_person?: SortOrderInput | SortOrder
    scanned_id_path?: SortOrderInput | SortOrder
    national_id?: SortOrderInput | SortOrder
    dept?: SortOrderInput | SortOrder
    telephone_1?: SortOrderInput | SortOrder
    telephone_2?: SortOrderInput | SortOrder
    has_gates?: SortOrderInput | SortOrder
    bk_type?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    papers_date?: SortOrderInput | SortOrder
    isSpecial?: SortOrderInput | SortOrder
    clienttype?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    bkcode?: StringWithAggregatesFilter<"Customer"> | string
    client_name?: StringWithAggregatesFilter<"Customer"> | string
    supply_office?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    operating_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    contact_person?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    scanned_id_path?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    national_id?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dept?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    telephone_1?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    telephone_2?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    has_gates?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    bk_type?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    papers_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    isSpecial?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    clienttype?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type MachineParameterWhereInput = {
    AND?: MachineParameterWhereInput | MachineParameterWhereInput[]
    OR?: MachineParameterWhereInput[]
    NOT?: MachineParameterWhereInput | MachineParameterWhereInput[]
    id?: StringFilter<"MachineParameter"> | string
    prefix?: StringFilter<"MachineParameter"> | string
    model?: StringFilter<"MachineParameter"> | string
    manufacturer?: StringFilter<"MachineParameter"> | string
  }

  export type MachineParameterOrderByWithRelationInput = {
    id?: SortOrder
    prefix?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
  }

  export type MachineParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    prefix?: string
    AND?: MachineParameterWhereInput | MachineParameterWhereInput[]
    OR?: MachineParameterWhereInput[]
    NOT?: MachineParameterWhereInput | MachineParameterWhereInput[]
    model?: StringFilter<"MachineParameter"> | string
    manufacturer?: StringFilter<"MachineParameter"> | string
  }, "id" | "prefix">

  export type MachineParameterOrderByWithAggregationInput = {
    id?: SortOrder
    prefix?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    _count?: MachineParameterCountOrderByAggregateInput
    _max?: MachineParameterMaxOrderByAggregateInput
    _min?: MachineParameterMinOrderByAggregateInput
  }

  export type MachineParameterScalarWhereWithAggregatesInput = {
    AND?: MachineParameterScalarWhereWithAggregatesInput | MachineParameterScalarWhereWithAggregatesInput[]
    OR?: MachineParameterScalarWhereWithAggregatesInput[]
    NOT?: MachineParameterScalarWhereWithAggregatesInput | MachineParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineParameter"> | string
    prefix?: StringWithAggregatesFilter<"MachineParameter"> | string
    model?: StringWithAggregatesFilter<"MachineParameter"> | string
    manufacturer?: StringWithAggregatesFilter<"MachineParameter"> | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    role?: StringFilter<"RolePermission"> | string
    permissionType?: StringFilter<"RolePermission"> | string
    permissionKey?: StringFilter<"RolePermission"> | string
    isAllowed?: BoolFilter<"RolePermission"> | boolean
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedBy?: StringNullableFilter<"RolePermission"> | string | null
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionType?: SortOrder
    permissionKey?: SortOrder
    isAllowed?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    role_permissionType_permissionKey?: RolePermissionRolePermissionTypePermissionKeyCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    role?: StringFilter<"RolePermission"> | string
    permissionType?: StringFilter<"RolePermission"> | string
    permissionKey?: StringFilter<"RolePermission"> | string
    isAllowed?: BoolFilter<"RolePermission"> | boolean
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedBy?: StringNullableFilter<"RolePermission"> | string | null
  }, "id" | "role_permissionType_permissionKey">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionType?: SortOrder
    permissionKey?: SortOrder
    isAllowed?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    role?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionType?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionKey?: StringWithAggregatesFilter<"RolePermission"> | string
    isAllowed?: BoolWithAggregatesFilter<"RolePermission"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"RolePermission"> | string | null
  }

  export type SparePartWhereInput = {
    AND?: SparePartWhereInput | SparePartWhereInput[]
    OR?: SparePartWhereInput[]
    NOT?: SparePartWhereInput | SparePartWhereInput[]
    id?: StringFilter<"SparePart"> | string
    partNumber?: StringNullableFilter<"SparePart"> | string | null
    name?: StringFilter<"SparePart"> | string
    description?: StringNullableFilter<"SparePart"> | string | null
    compatibleModels?: StringNullableFilter<"SparePart"> | string | null
    defaultCost?: FloatFilter<"SparePart"> | number
    isConsumable?: BoolNullableFilter<"SparePart"> | boolean | null
    allowsMultiple?: BoolNullableFilter<"SparePart"> | boolean | null
    inventoryItems?: InventoryItemListRelationFilter
  }

  export type SparePartOrderByWithRelationInput = {
    id?: SortOrder
    partNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    compatibleModels?: SortOrderInput | SortOrder
    defaultCost?: SortOrder
    isConsumable?: SortOrderInput | SortOrder
    allowsMultiple?: SortOrderInput | SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
  }

  export type SparePartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SparePartWhereInput | SparePartWhereInput[]
    OR?: SparePartWhereInput[]
    NOT?: SparePartWhereInput | SparePartWhereInput[]
    partNumber?: StringNullableFilter<"SparePart"> | string | null
    name?: StringFilter<"SparePart"> | string
    description?: StringNullableFilter<"SparePart"> | string | null
    compatibleModels?: StringNullableFilter<"SparePart"> | string | null
    defaultCost?: FloatFilter<"SparePart"> | number
    isConsumable?: BoolNullableFilter<"SparePart"> | boolean | null
    allowsMultiple?: BoolNullableFilter<"SparePart"> | boolean | null
    inventoryItems?: InventoryItemListRelationFilter
  }, "id">

  export type SparePartOrderByWithAggregationInput = {
    id?: SortOrder
    partNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    compatibleModels?: SortOrderInput | SortOrder
    defaultCost?: SortOrder
    isConsumable?: SortOrderInput | SortOrder
    allowsMultiple?: SortOrderInput | SortOrder
    _count?: SparePartCountOrderByAggregateInput
    _avg?: SparePartAvgOrderByAggregateInput
    _max?: SparePartMaxOrderByAggregateInput
    _min?: SparePartMinOrderByAggregateInput
    _sum?: SparePartSumOrderByAggregateInput
  }

  export type SparePartScalarWhereWithAggregatesInput = {
    AND?: SparePartScalarWhereWithAggregatesInput | SparePartScalarWhereWithAggregatesInput[]
    OR?: SparePartScalarWhereWithAggregatesInput[]
    NOT?: SparePartScalarWhereWithAggregatesInput | SparePartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SparePart"> | string
    partNumber?: StringNullableWithAggregatesFilter<"SparePart"> | string | null
    name?: StringWithAggregatesFilter<"SparePart"> | string
    description?: StringNullableWithAggregatesFilter<"SparePart"> | string | null
    compatibleModels?: StringNullableWithAggregatesFilter<"SparePart"> | string | null
    defaultCost?: FloatWithAggregatesFilter<"SparePart"> | number
    isConsumable?: BoolNullableWithAggregatesFilter<"SparePart"> | boolean | null
    allowsMultiple?: BoolNullableWithAggregatesFilter<"SparePart"> | boolean | null
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    partId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    minLevel?: IntFilter<"InventoryItem"> | number
    location?: StringNullableFilter<"InventoryItem"> | string | null
    branchId?: StringNullableFilter<"InventoryItem"> | string | null
    part?: XOR<SparePartRelationFilter, SparePartWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    minLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    part?: SparePartOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    partId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    minLevel?: IntFilter<"InventoryItem"> | number
    location?: StringNullableFilter<"InventoryItem"> | string | null
    branchId?: StringNullableFilter<"InventoryItem"> | string | null
    part?: XOR<SparePartRelationFilter, SparePartWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    minLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    partId?: StringWithAggregatesFilter<"InventoryItem"> | string
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    minLevel?: IntWithAggregatesFilter<"InventoryItem"> | number
    location?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
  }

  export type MaintenanceRequestWhereInput = {
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    customerId?: StringFilter<"MaintenanceRequest"> | string
    posMachineId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    customerName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineModel?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineManufacturer?: StringNullableFilter<"MaintenanceRequest"> | string | null
    serialNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: StringFilter<"MaintenanceRequest"> | string
    branchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    servicedByBranchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    technician?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    complaint?: StringNullableFilter<"MaintenanceRequest"> | string | null
    actionTaken?: StringNullableFilter<"MaintenanceRequest"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    closingUserId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingUserName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingTimestamp?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    usedParts?: StringNullableFilter<"MaintenanceRequest"> | string | null
    receiptNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    totalCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    approval?: XOR<MaintenanceApprovalNullableRelationFilter, MaintenanceApprovalWhereInput> | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    posMachine?: XOR<PosMachineNullableRelationFilter, PosMachineWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    vouchers?: RepairVoucherListRelationFilter
  }

  export type MaintenanceRequestOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    posMachineId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    machineModel?: SortOrderInput | SortOrder
    machineManufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    branchId?: SortOrderInput | SortOrder
    servicedByBranchId?: SortOrderInput | SortOrder
    technician?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    complaint?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    closingUserId?: SortOrderInput | SortOrder
    closingUserName?: SortOrderInput | SortOrder
    closingTimestamp?: SortOrderInput | SortOrder
    usedParts?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    approval?: MaintenanceApprovalOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    posMachine?: PosMachineOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    vouchers?: RepairVoucherOrderByRelationAggregateInput
  }

  export type MaintenanceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    customerId?: StringFilter<"MaintenanceRequest"> | string
    posMachineId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    customerName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineModel?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineManufacturer?: StringNullableFilter<"MaintenanceRequest"> | string | null
    serialNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: StringFilter<"MaintenanceRequest"> | string
    branchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    servicedByBranchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    technician?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    complaint?: StringNullableFilter<"MaintenanceRequest"> | string | null
    actionTaken?: StringNullableFilter<"MaintenanceRequest"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    closingUserId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingUserName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingTimestamp?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    usedParts?: StringNullableFilter<"MaintenanceRequest"> | string | null
    receiptNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    totalCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    approval?: XOR<MaintenanceApprovalNullableRelationFilter, MaintenanceApprovalWhereInput> | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    posMachine?: XOR<PosMachineNullableRelationFilter, PosMachineWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    vouchers?: RepairVoucherListRelationFilter
  }, "id">

  export type MaintenanceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    posMachineId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    machineModel?: SortOrderInput | SortOrder
    machineManufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    branchId?: SortOrderInput | SortOrder
    servicedByBranchId?: SortOrderInput | SortOrder
    technician?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    complaint?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    closingUserId?: SortOrderInput | SortOrder
    closingUserName?: SortOrderInput | SortOrder
    closingTimestamp?: SortOrderInput | SortOrder
    usedParts?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    _count?: MaintenanceRequestCountOrderByAggregateInput
    _avg?: MaintenanceRequestAvgOrderByAggregateInput
    _max?: MaintenanceRequestMaxOrderByAggregateInput
    _min?: MaintenanceRequestMinOrderByAggregateInput
    _sum?: MaintenanceRequestSumOrderByAggregateInput
  }

  export type MaintenanceRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    customerId?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    posMachineId?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    machineModel?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    machineManufacturer?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    status?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    branchId?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    servicedByBranchId?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    technician?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    complaint?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    actionTaken?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    closingUserId?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    closingUserName?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    closingTimestamp?: DateTimeNullableWithAggregatesFilter<"MaintenanceRequest"> | Date | string | null
    usedParts?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    totalCost?: FloatNullableWithAggregatesFilter<"MaintenanceRequest"> | number | null
  }

  export type PriceChangeLogWhereInput = {
    AND?: PriceChangeLogWhereInput | PriceChangeLogWhereInput[]
    OR?: PriceChangeLogWhereInput[]
    NOT?: PriceChangeLogWhereInput | PriceChangeLogWhereInput[]
    id?: StringFilter<"PriceChangeLog"> | string
    partId?: StringFilter<"PriceChangeLog"> | string
    oldCost?: FloatFilter<"PriceChangeLog"> | number
    newCost?: FloatFilter<"PriceChangeLog"> | number
    changedAt?: DateTimeFilter<"PriceChangeLog"> | Date | string
    userId?: StringNullableFilter<"PriceChangeLog"> | string | null
  }

  export type PriceChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    partId?: SortOrder
    oldCost?: SortOrder
    newCost?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
  }

  export type PriceChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceChangeLogWhereInput | PriceChangeLogWhereInput[]
    OR?: PriceChangeLogWhereInput[]
    NOT?: PriceChangeLogWhereInput | PriceChangeLogWhereInput[]
    partId?: StringFilter<"PriceChangeLog"> | string
    oldCost?: FloatFilter<"PriceChangeLog"> | number
    newCost?: FloatFilter<"PriceChangeLog"> | number
    changedAt?: DateTimeFilter<"PriceChangeLog"> | Date | string
    userId?: StringNullableFilter<"PriceChangeLog"> | string | null
  }, "id">

  export type PriceChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    partId?: SortOrder
    oldCost?: SortOrder
    newCost?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: PriceChangeLogCountOrderByAggregateInput
    _avg?: PriceChangeLogAvgOrderByAggregateInput
    _max?: PriceChangeLogMaxOrderByAggregateInput
    _min?: PriceChangeLogMinOrderByAggregateInput
    _sum?: PriceChangeLogSumOrderByAggregateInput
  }

  export type PriceChangeLogScalarWhereWithAggregatesInput = {
    AND?: PriceChangeLogScalarWhereWithAggregatesInput | PriceChangeLogScalarWhereWithAggregatesInput[]
    OR?: PriceChangeLogScalarWhereWithAggregatesInput[]
    NOT?: PriceChangeLogScalarWhereWithAggregatesInput | PriceChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceChangeLog"> | string
    partId?: StringWithAggregatesFilter<"PriceChangeLog"> | string
    oldCost?: FloatWithAggregatesFilter<"PriceChangeLog"> | number
    newCost?: FloatWithAggregatesFilter<"PriceChangeLog"> | number
    changedAt?: DateTimeWithAggregatesFilter<"PriceChangeLog"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"PriceChangeLog"> | string | null
  }

  export type UsedPartLogWhereInput = {
    AND?: UsedPartLogWhereInput | UsedPartLogWhereInput[]
    OR?: UsedPartLogWhereInput[]
    NOT?: UsedPartLogWhereInput | UsedPartLogWhereInput[]
    id?: StringFilter<"UsedPartLog"> | string
    requestId?: StringFilter<"UsedPartLog"> | string
    customerId?: StringFilter<"UsedPartLog"> | string
    customerName?: StringNullableFilter<"UsedPartLog"> | string | null
    posMachineId?: StringNullableFilter<"UsedPartLog"> | string | null
    technician?: StringNullableFilter<"UsedPartLog"> | string | null
    closedByUserId?: StringNullableFilter<"UsedPartLog"> | string | null
    closedAt?: DateTimeFilter<"UsedPartLog"> | Date | string
    parts?: StringFilter<"UsedPartLog"> | string
    receiptNumber?: StringNullableFilter<"UsedPartLog"> | string | null
    branchId?: StringNullableFilter<"UsedPartLog"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type UsedPartLogOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrderInput | SortOrder
    posMachineId?: SortOrderInput | SortOrder
    technician?: SortOrderInput | SortOrder
    closedByUserId?: SortOrderInput | SortOrder
    closedAt?: SortOrder
    parts?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type UsedPartLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsedPartLogWhereInput | UsedPartLogWhereInput[]
    OR?: UsedPartLogWhereInput[]
    NOT?: UsedPartLogWhereInput | UsedPartLogWhereInput[]
    requestId?: StringFilter<"UsedPartLog"> | string
    customerId?: StringFilter<"UsedPartLog"> | string
    customerName?: StringNullableFilter<"UsedPartLog"> | string | null
    posMachineId?: StringNullableFilter<"UsedPartLog"> | string | null
    technician?: StringNullableFilter<"UsedPartLog"> | string | null
    closedByUserId?: StringNullableFilter<"UsedPartLog"> | string | null
    closedAt?: DateTimeFilter<"UsedPartLog"> | Date | string
    parts?: StringFilter<"UsedPartLog"> | string
    receiptNumber?: StringNullableFilter<"UsedPartLog"> | string | null
    branchId?: StringNullableFilter<"UsedPartLog"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type UsedPartLogOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrderInput | SortOrder
    posMachineId?: SortOrderInput | SortOrder
    technician?: SortOrderInput | SortOrder
    closedByUserId?: SortOrderInput | SortOrder
    closedAt?: SortOrder
    parts?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: UsedPartLogCountOrderByAggregateInput
    _max?: UsedPartLogMaxOrderByAggregateInput
    _min?: UsedPartLogMinOrderByAggregateInput
  }

  export type UsedPartLogScalarWhereWithAggregatesInput = {
    AND?: UsedPartLogScalarWhereWithAggregatesInput | UsedPartLogScalarWhereWithAggregatesInput[]
    OR?: UsedPartLogScalarWhereWithAggregatesInput[]
    NOT?: UsedPartLogScalarWhereWithAggregatesInput | UsedPartLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsedPartLog"> | string
    requestId?: StringWithAggregatesFilter<"UsedPartLog"> | string
    customerId?: StringWithAggregatesFilter<"UsedPartLog"> | string
    customerName?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
    posMachineId?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
    technician?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
    closedByUserId?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
    closedAt?: DateTimeWithAggregatesFilter<"UsedPartLog"> | Date | string
    parts?: StringWithAggregatesFilter<"UsedPartLog"> | string
    receiptNumber?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"UsedPartLog"> | string | null
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    partId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    requestId?: StringNullableFilter<"StockMovement"> | string | null
    userId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    branchId?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    partId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    partId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    requestId?: StringNullableFilter<"StockMovement"> | string | null
    userId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    branchId?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    partId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    partId?: StringWithAggregatesFilter<"StockMovement"> | string
    type?: StringWithAggregatesFilter<"StockMovement"> | string
    quantity?: IntWithAggregatesFilter<"StockMovement"> | number
    reason?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    userId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    customerName?: StringNullableFilter<"Payment"> | string | null
    requestId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    type?: StringNullableFilter<"Payment"> | string | null
    reason?: StringNullableFilter<"Payment"> | string | null
    paymentPlace?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    receiptNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    userId?: StringNullableFilter<"Payment"> | string | null
    userName?: StringNullableFilter<"Payment"> | string | null
    branchId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    customerId?: StringNullableFilter<"Payment"> | string | null
    customerName?: StringNullableFilter<"Payment"> | string | null
    requestId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    type?: StringNullableFilter<"Payment"> | string | null
    reason?: StringNullableFilter<"Payment"> | string | null
    paymentPlace?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    receiptNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    userId?: StringNullableFilter<"Payment"> | string | null
    userName?: StringNullableFilter<"Payment"> | string | null
    branchId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    customerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    type?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    reason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentPlace?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    userName?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type MachineMovementLogWhereInput = {
    AND?: MachineMovementLogWhereInput | MachineMovementLogWhereInput[]
    OR?: MachineMovementLogWhereInput[]
    NOT?: MachineMovementLogWhereInput | MachineMovementLogWhereInput[]
    id?: StringFilter<"MachineMovementLog"> | string
    machineId?: StringNullableFilter<"MachineMovementLog"> | string | null
    serialNumber?: StringFilter<"MachineMovementLog"> | string
    action?: StringFilter<"MachineMovementLog"> | string
    details?: StringNullableFilter<"MachineMovementLog"> | string | null
    performedBy?: StringNullableFilter<"MachineMovementLog"> | string | null
    branchId?: StringNullableFilter<"MachineMovementLog"> | string | null
    createdAt?: DateTimeFilter<"MachineMovementLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type MachineMovementLogOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type MachineMovementLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MachineMovementLogWhereInput | MachineMovementLogWhereInput[]
    OR?: MachineMovementLogWhereInput[]
    NOT?: MachineMovementLogWhereInput | MachineMovementLogWhereInput[]
    machineId?: StringNullableFilter<"MachineMovementLog"> | string | null
    serialNumber?: StringFilter<"MachineMovementLog"> | string
    action?: StringFilter<"MachineMovementLog"> | string
    details?: StringNullableFilter<"MachineMovementLog"> | string | null
    performedBy?: StringNullableFilter<"MachineMovementLog"> | string | null
    branchId?: StringNullableFilter<"MachineMovementLog"> | string | null
    createdAt?: DateTimeFilter<"MachineMovementLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type MachineMovementLogOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MachineMovementLogCountOrderByAggregateInput
    _max?: MachineMovementLogMaxOrderByAggregateInput
    _min?: MachineMovementLogMinOrderByAggregateInput
  }

  export type MachineMovementLogScalarWhereWithAggregatesInput = {
    AND?: MachineMovementLogScalarWhereWithAggregatesInput | MachineMovementLogScalarWhereWithAggregatesInput[]
    OR?: MachineMovementLogScalarWhereWithAggregatesInput[]
    NOT?: MachineMovementLogScalarWhereWithAggregatesInput | MachineMovementLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineMovementLog"> | string
    machineId?: StringNullableWithAggregatesFilter<"MachineMovementLog"> | string | null
    serialNumber?: StringWithAggregatesFilter<"MachineMovementLog"> | string
    action?: StringWithAggregatesFilter<"MachineMovementLog"> | string
    details?: StringNullableWithAggregatesFilter<"MachineMovementLog"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"MachineMovementLog"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"MachineMovementLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MachineMovementLog"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    performedBy?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringNullableFilter<"SystemLog"> | string | null
    branchId?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    performedBy?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringNullableFilter<"SystemLog"> | string | null
    branchId?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    entityType?: StringWithAggregatesFilter<"SystemLog"> | string
    entityId?: StringWithAggregatesFilter<"SystemLog"> | string
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    details?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type InstallmentWhereInput = {
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    id?: StringFilter<"Installment"> | string
    saleId?: StringFilter<"Installment"> | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: FloatFilter<"Installment"> | number
    isPaid?: BoolFilter<"Installment"> | boolean
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    description?: StringNullableFilter<"Installment"> | string | null
    paidAmount?: FloatNullableFilter<"Installment"> | number | null
    paymentPlace?: StringNullableFilter<"Installment"> | string | null
    receiptNumber?: StringNullableFilter<"Installment"> | string | null
    branchId?: StringNullableFilter<"Installment"> | string | null
    sale?: XOR<MachineSaleRelationFilter, MachineSaleWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type InstallmentOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    sale?: MachineSaleOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type InstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    saleId?: StringFilter<"Installment"> | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: FloatFilter<"Installment"> | number
    isPaid?: BoolFilter<"Installment"> | boolean
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    description?: StringNullableFilter<"Installment"> | string | null
    paidAmount?: FloatNullableFilter<"Installment"> | number | null
    paymentPlace?: StringNullableFilter<"Installment"> | string | null
    receiptNumber?: StringNullableFilter<"Installment"> | string | null
    branchId?: StringNullableFilter<"Installment"> | string | null
    sale?: XOR<MachineSaleRelationFilter, MachineSaleWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type InstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: InstallmentCountOrderByAggregateInput
    _avg?: InstallmentAvgOrderByAggregateInput
    _max?: InstallmentMaxOrderByAggregateInput
    _min?: InstallmentMinOrderByAggregateInput
    _sum?: InstallmentSumOrderByAggregateInput
  }

  export type InstallmentScalarWhereWithAggregatesInput = {
    AND?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    OR?: InstallmentScalarWhereWithAggregatesInput[]
    NOT?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Installment"> | string
    saleId?: StringWithAggregatesFilter<"Installment"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    amount?: FloatWithAggregatesFilter<"Installment"> | number
    isPaid?: BoolWithAggregatesFilter<"Installment"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"Installment"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Installment"> | string | null
    paidAmount?: FloatNullableWithAggregatesFilter<"Installment"> | number | null
    paymentPlace?: StringNullableWithAggregatesFilter<"Installment"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"Installment"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Installment"> | string | null
  }

  export type MachineSaleWhereInput = {
    AND?: MachineSaleWhereInput | MachineSaleWhereInput[]
    OR?: MachineSaleWhereInput[]
    NOT?: MachineSaleWhereInput | MachineSaleWhereInput[]
    id?: StringFilter<"MachineSale"> | string
    serialNumber?: StringFilter<"MachineSale"> | string
    customerId?: StringFilter<"MachineSale"> | string
    saleDate?: DateTimeFilter<"MachineSale"> | Date | string
    type?: StringFilter<"MachineSale"> | string
    totalPrice?: FloatFilter<"MachineSale"> | number
    paidAmount?: FloatFilter<"MachineSale"> | number
    status?: StringFilter<"MachineSale"> | string
    notes?: StringNullableFilter<"MachineSale"> | string | null
    branchId?: StringNullableFilter<"MachineSale"> | string | null
    installments?: InstallmentListRelationFilter
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type MachineSaleOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    type?: SortOrder
    totalPrice?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    installments?: InstallmentOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type MachineSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MachineSaleWhereInput | MachineSaleWhereInput[]
    OR?: MachineSaleWhereInput[]
    NOT?: MachineSaleWhereInput | MachineSaleWhereInput[]
    serialNumber?: StringFilter<"MachineSale"> | string
    customerId?: StringFilter<"MachineSale"> | string
    saleDate?: DateTimeFilter<"MachineSale"> | Date | string
    type?: StringFilter<"MachineSale"> | string
    totalPrice?: FloatFilter<"MachineSale"> | number
    paidAmount?: FloatFilter<"MachineSale"> | number
    status?: StringFilter<"MachineSale"> | string
    notes?: StringNullableFilter<"MachineSale"> | string | null
    branchId?: StringNullableFilter<"MachineSale"> | string | null
    installments?: InstallmentListRelationFilter
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type MachineSaleOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    type?: SortOrder
    totalPrice?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: MachineSaleCountOrderByAggregateInput
    _avg?: MachineSaleAvgOrderByAggregateInput
    _max?: MachineSaleMaxOrderByAggregateInput
    _min?: MachineSaleMinOrderByAggregateInput
    _sum?: MachineSaleSumOrderByAggregateInput
  }

  export type MachineSaleScalarWhereWithAggregatesInput = {
    AND?: MachineSaleScalarWhereWithAggregatesInput | MachineSaleScalarWhereWithAggregatesInput[]
    OR?: MachineSaleScalarWhereWithAggregatesInput[]
    NOT?: MachineSaleScalarWhereWithAggregatesInput | MachineSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineSale"> | string
    serialNumber?: StringWithAggregatesFilter<"MachineSale"> | string
    customerId?: StringWithAggregatesFilter<"MachineSale"> | string
    saleDate?: DateTimeWithAggregatesFilter<"MachineSale"> | Date | string
    type?: StringWithAggregatesFilter<"MachineSale"> | string
    totalPrice?: FloatWithAggregatesFilter<"MachineSale"> | number
    paidAmount?: FloatWithAggregatesFilter<"MachineSale"> | number
    status?: StringWithAggregatesFilter<"MachineSale"> | string
    notes?: StringNullableWithAggregatesFilter<"MachineSale"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"MachineSale"> | string | null
  }

  export type PosMachineWhereInput = {
    AND?: PosMachineWhereInput | PosMachineWhereInput[]
    OR?: PosMachineWhereInput[]
    NOT?: PosMachineWhereInput | PosMachineWhereInput[]
    id?: StringFilter<"PosMachine"> | string
    serialNumber?: StringFilter<"PosMachine"> | string
    posId?: StringNullableFilter<"PosMachine"> | string | null
    model?: StringNullableFilter<"PosMachine"> | string | null
    manufacturer?: StringNullableFilter<"PosMachine"> | string | null
    customerId?: StringNullableFilter<"PosMachine"> | string | null
    isMain?: BoolNullableFilter<"PosMachine"> | boolean | null
    branchId?: StringNullableFilter<"PosMachine"> | string | null
    requests?: MaintenanceRequestListRelationFilter
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type PosMachineOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    posId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    isMain?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    requests?: MaintenanceRequestOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type PosMachineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: PosMachineWhereInput | PosMachineWhereInput[]
    OR?: PosMachineWhereInput[]
    NOT?: PosMachineWhereInput | PosMachineWhereInput[]
    posId?: StringNullableFilter<"PosMachine"> | string | null
    model?: StringNullableFilter<"PosMachine"> | string | null
    manufacturer?: StringNullableFilter<"PosMachine"> | string | null
    customerId?: StringNullableFilter<"PosMachine"> | string | null
    isMain?: BoolNullableFilter<"PosMachine"> | boolean | null
    branchId?: StringNullableFilter<"PosMachine"> | string | null
    requests?: MaintenanceRequestListRelationFilter
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id" | "serialNumber">

  export type PosMachineOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    posId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    isMain?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: PosMachineCountOrderByAggregateInput
    _max?: PosMachineMaxOrderByAggregateInput
    _min?: PosMachineMinOrderByAggregateInput
  }

  export type PosMachineScalarWhereWithAggregatesInput = {
    AND?: PosMachineScalarWhereWithAggregatesInput | PosMachineScalarWhereWithAggregatesInput[]
    OR?: PosMachineScalarWhereWithAggregatesInput[]
    NOT?: PosMachineScalarWhereWithAggregatesInput | PosMachineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PosMachine"> | string
    serialNumber?: StringWithAggregatesFilter<"PosMachine"> | string
    posId?: StringNullableWithAggregatesFilter<"PosMachine"> | string | null
    model?: StringNullableWithAggregatesFilter<"PosMachine"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"PosMachine"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"PosMachine"> | string | null
    isMain?: BoolNullableWithAggregatesFilter<"PosMachine"> | boolean | null
    branchId?: StringNullableWithAggregatesFilter<"PosMachine"> | string | null
  }

  export type SimCardWhereInput = {
    AND?: SimCardWhereInput | SimCardWhereInput[]
    OR?: SimCardWhereInput[]
    NOT?: SimCardWhereInput | SimCardWhereInput[]
    id?: StringFilter<"SimCard"> | string
    serialNumber?: StringFilter<"SimCard"> | string
    type?: StringNullableFilter<"SimCard"> | string | null
    customerId?: StringNullableFilter<"SimCard"> | string | null
    branchId?: StringNullableFilter<"SimCard"> | string | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type SimCardOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type SimCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: SimCardWhereInput | SimCardWhereInput[]
    OR?: SimCardWhereInput[]
    NOT?: SimCardWhereInput | SimCardWhereInput[]
    type?: StringNullableFilter<"SimCard"> | string | null
    customerId?: StringNullableFilter<"SimCard"> | string | null
    branchId?: StringNullableFilter<"SimCard"> | string | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id" | "serialNumber">

  export type SimCardOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: SimCardCountOrderByAggregateInput
    _max?: SimCardMaxOrderByAggregateInput
    _min?: SimCardMinOrderByAggregateInput
  }

  export type SimCardScalarWhereWithAggregatesInput = {
    AND?: SimCardScalarWhereWithAggregatesInput | SimCardScalarWhereWithAggregatesInput[]
    OR?: SimCardScalarWhereWithAggregatesInput[]
    NOT?: SimCardScalarWhereWithAggregatesInput | SimCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimCard"> | string
    serialNumber?: StringWithAggregatesFilter<"SimCard"> | string
    type?: StringNullableWithAggregatesFilter<"SimCard"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"SimCard"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"SimCard"> | string | null
  }

  export type WarehouseMachineWhereInput = {
    AND?: WarehouseMachineWhereInput | WarehouseMachineWhereInput[]
    OR?: WarehouseMachineWhereInput[]
    NOT?: WarehouseMachineWhereInput | WarehouseMachineWhereInput[]
    id?: StringFilter<"WarehouseMachine"> | string
    serialNumber?: StringFilter<"WarehouseMachine"> | string
    model?: StringNullableFilter<"WarehouseMachine"> | string | null
    manufacturer?: StringNullableFilter<"WarehouseMachine"> | string | null
    status?: StringFilter<"WarehouseMachine"> | string
    resolution?: StringNullableFilter<"WarehouseMachine"> | string | null
    notes?: StringNullableFilter<"WarehouseMachine"> | string | null
    importDate?: DateTimeFilter<"WarehouseMachine"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseMachine"> | Date | string
    originalOwnerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    branchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    requestId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerName?: StringNullableFilter<"WarehouseMachine"> | string | null
    readyForPickup?: BoolFilter<"WarehouseMachine"> | boolean
    currentAssignmentId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianName?: StringNullableFilter<"WarehouseMachine"> | string | null
    originBranchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedRepairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedTotalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    repairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    totalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    usedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
    serviceAssignments?: ServiceAssignmentListRelationFilter
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type WarehouseMachineOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    originalOwnerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    readyForPickup?: SortOrder
    currentAssignmentId?: SortOrderInput | SortOrder
    currentTechnicianId?: SortOrderInput | SortOrder
    currentTechnicianName?: SortOrderInput | SortOrder
    originBranchId?: SortOrderInput | SortOrder
    proposedParts?: SortOrderInput | SortOrder
    proposedRepairNotes?: SortOrderInput | SortOrder
    proposedTotalCost?: SortOrderInput | SortOrder
    repairNotes?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    usedParts?: SortOrderInput | SortOrder
    serviceAssignments?: ServiceAssignmentOrderByRelationAggregateInput
    branch?: BranchOrderByWithRelationInput
  }

  export type WarehouseMachineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: WarehouseMachineWhereInput | WarehouseMachineWhereInput[]
    OR?: WarehouseMachineWhereInput[]
    NOT?: WarehouseMachineWhereInput | WarehouseMachineWhereInput[]
    model?: StringNullableFilter<"WarehouseMachine"> | string | null
    manufacturer?: StringNullableFilter<"WarehouseMachine"> | string | null
    status?: StringFilter<"WarehouseMachine"> | string
    resolution?: StringNullableFilter<"WarehouseMachine"> | string | null
    notes?: StringNullableFilter<"WarehouseMachine"> | string | null
    importDate?: DateTimeFilter<"WarehouseMachine"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseMachine"> | Date | string
    originalOwnerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    branchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    requestId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerName?: StringNullableFilter<"WarehouseMachine"> | string | null
    readyForPickup?: BoolFilter<"WarehouseMachine"> | boolean
    currentAssignmentId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianName?: StringNullableFilter<"WarehouseMachine"> | string | null
    originBranchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedRepairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedTotalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    repairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    totalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    usedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
    serviceAssignments?: ServiceAssignmentListRelationFilter
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id" | "serialNumber">

  export type WarehouseMachineOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    originalOwnerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    readyForPickup?: SortOrder
    currentAssignmentId?: SortOrderInput | SortOrder
    currentTechnicianId?: SortOrderInput | SortOrder
    currentTechnicianName?: SortOrderInput | SortOrder
    originBranchId?: SortOrderInput | SortOrder
    proposedParts?: SortOrderInput | SortOrder
    proposedRepairNotes?: SortOrderInput | SortOrder
    proposedTotalCost?: SortOrderInput | SortOrder
    repairNotes?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    usedParts?: SortOrderInput | SortOrder
    _count?: WarehouseMachineCountOrderByAggregateInput
    _avg?: WarehouseMachineAvgOrderByAggregateInput
    _max?: WarehouseMachineMaxOrderByAggregateInput
    _min?: WarehouseMachineMinOrderByAggregateInput
    _sum?: WarehouseMachineSumOrderByAggregateInput
  }

  export type WarehouseMachineScalarWhereWithAggregatesInput = {
    AND?: WarehouseMachineScalarWhereWithAggregatesInput | WarehouseMachineScalarWhereWithAggregatesInput[]
    OR?: WarehouseMachineScalarWhereWithAggregatesInput[]
    NOT?: WarehouseMachineScalarWhereWithAggregatesInput | WarehouseMachineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseMachine"> | string
    serialNumber?: StringWithAggregatesFilter<"WarehouseMachine"> | string
    model?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    status?: StringWithAggregatesFilter<"WarehouseMachine"> | string
    resolution?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    importDate?: DateTimeWithAggregatesFilter<"WarehouseMachine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseMachine"> | Date | string
    originalOwnerId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    readyForPickup?: BoolWithAggregatesFilter<"WarehouseMachine"> | boolean
    currentAssignmentId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    currentTechnicianId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    currentTechnicianName?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    originBranchId?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    proposedParts?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    proposedRepairNotes?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    proposedTotalCost?: FloatNullableWithAggregatesFilter<"WarehouseMachine"> | number | null
    repairNotes?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
    totalCost?: FloatNullableWithAggregatesFilter<"WarehouseMachine"> | number | null
    usedParts?: StringNullableWithAggregatesFilter<"WarehouseMachine"> | string | null
  }

  export type WarehouseSimWhereInput = {
    AND?: WarehouseSimWhereInput | WarehouseSimWhereInput[]
    OR?: WarehouseSimWhereInput[]
    NOT?: WarehouseSimWhereInput | WarehouseSimWhereInput[]
    id?: StringFilter<"WarehouseSim"> | string
    serialNumber?: StringFilter<"WarehouseSim"> | string
    type?: StringNullableFilter<"WarehouseSim"> | string | null
    status?: StringFilter<"WarehouseSim"> | string
    notes?: StringNullableFilter<"WarehouseSim"> | string | null
    importDate?: DateTimeFilter<"WarehouseSim"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseSim"> | Date | string
    branchId?: StringNullableFilter<"WarehouseSim"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type WarehouseSimOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type WarehouseSimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: WarehouseSimWhereInput | WarehouseSimWhereInput[]
    OR?: WarehouseSimWhereInput[]
    NOT?: WarehouseSimWhereInput | WarehouseSimWhereInput[]
    type?: StringNullableFilter<"WarehouseSim"> | string | null
    status?: StringFilter<"WarehouseSim"> | string
    notes?: StringNullableFilter<"WarehouseSim"> | string | null
    importDate?: DateTimeFilter<"WarehouseSim"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseSim"> | Date | string
    branchId?: StringNullableFilter<"WarehouseSim"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id" | "serialNumber">

  export type WarehouseSimOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: WarehouseSimCountOrderByAggregateInput
    _max?: WarehouseSimMaxOrderByAggregateInput
    _min?: WarehouseSimMinOrderByAggregateInput
  }

  export type WarehouseSimScalarWhereWithAggregatesInput = {
    AND?: WarehouseSimScalarWhereWithAggregatesInput | WarehouseSimScalarWhereWithAggregatesInput[]
    OR?: WarehouseSimScalarWhereWithAggregatesInput[]
    NOT?: WarehouseSimScalarWhereWithAggregatesInput | WarehouseSimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseSim"> | string
    serialNumber?: StringWithAggregatesFilter<"WarehouseSim"> | string
    type?: StringNullableWithAggregatesFilter<"WarehouseSim"> | string | null
    status?: StringWithAggregatesFilter<"WarehouseSim"> | string
    notes?: StringNullableWithAggregatesFilter<"WarehouseSim"> | string | null
    importDate?: DateTimeWithAggregatesFilter<"WarehouseSim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseSim"> | Date | string
    branchId?: StringNullableWithAggregatesFilter<"WarehouseSim"> | string | null
  }

  export type SimMovementLogWhereInput = {
    AND?: SimMovementLogWhereInput | SimMovementLogWhereInput[]
    OR?: SimMovementLogWhereInput[]
    NOT?: SimMovementLogWhereInput | SimMovementLogWhereInput[]
    id?: StringFilter<"SimMovementLog"> | string
    simId?: StringFilter<"SimMovementLog"> | string
    serialNumber?: StringFilter<"SimMovementLog"> | string
    action?: StringFilter<"SimMovementLog"> | string
    details?: StringNullableFilter<"SimMovementLog"> | string | null
    performedBy?: StringNullableFilter<"SimMovementLog"> | string | null
    branchId?: StringNullableFilter<"SimMovementLog"> | string | null
    createdAt?: DateTimeFilter<"SimMovementLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type SimMovementLogOrderByWithRelationInput = {
    id?: SortOrder
    simId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type SimMovementLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimMovementLogWhereInput | SimMovementLogWhereInput[]
    OR?: SimMovementLogWhereInput[]
    NOT?: SimMovementLogWhereInput | SimMovementLogWhereInput[]
    simId?: StringFilter<"SimMovementLog"> | string
    serialNumber?: StringFilter<"SimMovementLog"> | string
    action?: StringFilter<"SimMovementLog"> | string
    details?: StringNullableFilter<"SimMovementLog"> | string | null
    performedBy?: StringNullableFilter<"SimMovementLog"> | string | null
    branchId?: StringNullableFilter<"SimMovementLog"> | string | null
    createdAt?: DateTimeFilter<"SimMovementLog"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type SimMovementLogOrderByWithAggregationInput = {
    id?: SortOrder
    simId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SimMovementLogCountOrderByAggregateInput
    _max?: SimMovementLogMaxOrderByAggregateInput
    _min?: SimMovementLogMinOrderByAggregateInput
  }

  export type SimMovementLogScalarWhereWithAggregatesInput = {
    AND?: SimMovementLogScalarWhereWithAggregatesInput | SimMovementLogScalarWhereWithAggregatesInput[]
    OR?: SimMovementLogScalarWhereWithAggregatesInput[]
    NOT?: SimMovementLogScalarWhereWithAggregatesInput | SimMovementLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimMovementLog"> | string
    simId?: StringWithAggregatesFilter<"SimMovementLog"> | string
    serialNumber?: StringWithAggregatesFilter<"SimMovementLog"> | string
    action?: StringWithAggregatesFilter<"SimMovementLog"> | string
    details?: StringNullableWithAggregatesFilter<"SimMovementLog"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"SimMovementLog"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"SimMovementLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SimMovementLog"> | Date | string
  }

  export type TransferOrderWhereInput = {
    AND?: TransferOrderWhereInput | TransferOrderWhereInput[]
    OR?: TransferOrderWhereInput[]
    NOT?: TransferOrderWhereInput | TransferOrderWhereInput[]
    id?: StringFilter<"TransferOrder"> | string
    orderNumber?: StringFilter<"TransferOrder"> | string
    waybillNumber?: StringNullableFilter<"TransferOrder"> | string | null
    branchId?: StringNullableFilter<"TransferOrder"> | string | null
    fromBranchId?: StringFilter<"TransferOrder"> | string
    toBranchId?: StringFilter<"TransferOrder"> | string
    status?: StringFilter<"TransferOrder"> | string
    type?: StringFilter<"TransferOrder"> | string
    driverName?: StringNullableFilter<"TransferOrder"> | string | null
    driverPhone?: StringNullableFilter<"TransferOrder"> | string | null
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    createdBy?: StringNullableFilter<"TransferOrder"> | string | null
    createdByName?: StringNullableFilter<"TransferOrder"> | string | null
    createdByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedBy?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByName?: StringNullableFilter<"TransferOrder"> | string | null
    rejectionReason?: StringNullableFilter<"TransferOrder"> | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
    toBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    fromBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    items?: TransferOrderItemListRelationFilter
  }

  export type TransferOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    waybillNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    receivedByName?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    toBranch?: BranchOrderByWithRelationInput
    fromBranch?: BranchOrderByWithRelationInput
    items?: TransferOrderItemOrderByRelationAggregateInput
  }

  export type TransferOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: TransferOrderWhereInput | TransferOrderWhereInput[]
    OR?: TransferOrderWhereInput[]
    NOT?: TransferOrderWhereInput | TransferOrderWhereInput[]
    waybillNumber?: StringNullableFilter<"TransferOrder"> | string | null
    branchId?: StringNullableFilter<"TransferOrder"> | string | null
    fromBranchId?: StringFilter<"TransferOrder"> | string
    toBranchId?: StringFilter<"TransferOrder"> | string
    status?: StringFilter<"TransferOrder"> | string
    type?: StringFilter<"TransferOrder"> | string
    driverName?: StringNullableFilter<"TransferOrder"> | string | null
    driverPhone?: StringNullableFilter<"TransferOrder"> | string | null
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    createdBy?: StringNullableFilter<"TransferOrder"> | string | null
    createdByName?: StringNullableFilter<"TransferOrder"> | string | null
    createdByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedBy?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByName?: StringNullableFilter<"TransferOrder"> | string | null
    rejectionReason?: StringNullableFilter<"TransferOrder"> | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
    toBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    fromBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    items?: TransferOrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type TransferOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    waybillNumber?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    receivedByName?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferOrderCountOrderByAggregateInput
    _max?: TransferOrderMaxOrderByAggregateInput
    _min?: TransferOrderMinOrderByAggregateInput
  }

  export type TransferOrderScalarWhereWithAggregatesInput = {
    AND?: TransferOrderScalarWhereWithAggregatesInput | TransferOrderScalarWhereWithAggregatesInput[]
    OR?: TransferOrderScalarWhereWithAggregatesInput[]
    NOT?: TransferOrderScalarWhereWithAggregatesInput | TransferOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"TransferOrder"> | string
    waybillNumber?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    fromBranchId?: StringWithAggregatesFilter<"TransferOrder"> | string
    toBranchId?: StringWithAggregatesFilter<"TransferOrder"> | string
    status?: StringWithAggregatesFilter<"TransferOrder"> | string
    type?: StringWithAggregatesFilter<"TransferOrder"> | string
    driverName?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    driverPhone?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    createdByName?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    receivedByUserId?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"TransferOrder"> | Date | string | null
    receivedBy?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    receivedByName?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferOrder"> | Date | string
  }

  export type TransferOrderItemWhereInput = {
    AND?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    OR?: TransferOrderItemWhereInput[]
    NOT?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    id?: StringFilter<"TransferOrderItem"> | string
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    serialNumber?: StringNullableFilter<"TransferOrderItem"> | string | null
    type?: StringNullableFilter<"TransferOrderItem"> | string | null
    model?: StringNullableFilter<"TransferOrderItem"> | string | null
    manufacturer?: StringNullableFilter<"TransferOrderItem"> | string | null
    isReceived?: BoolFilter<"TransferOrderItem"> | boolean
    receivedAt?: DateTimeNullableFilter<"TransferOrderItem"> | Date | string | null
    notes?: StringNullableFilter<"TransferOrderItem"> | string | null
    transferOrder?: XOR<TransferOrderRelationFilter, TransferOrderWhereInput>
  }

  export type TransferOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    isReceived?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    transferOrder?: TransferOrderOrderByWithRelationInput
  }

  export type TransferOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    OR?: TransferOrderItemWhereInput[]
    NOT?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    serialNumber?: StringNullableFilter<"TransferOrderItem"> | string | null
    type?: StringNullableFilter<"TransferOrderItem"> | string | null
    model?: StringNullableFilter<"TransferOrderItem"> | string | null
    manufacturer?: StringNullableFilter<"TransferOrderItem"> | string | null
    isReceived?: BoolFilter<"TransferOrderItem"> | boolean
    receivedAt?: DateTimeNullableFilter<"TransferOrderItem"> | Date | string | null
    notes?: StringNullableFilter<"TransferOrderItem"> | string | null
    transferOrder?: XOR<TransferOrderRelationFilter, TransferOrderWhereInput>
  }, "id">

  export type TransferOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    isReceived?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: TransferOrderItemCountOrderByAggregateInput
    _max?: TransferOrderItemMaxOrderByAggregateInput
    _min?: TransferOrderItemMinOrderByAggregateInput
  }

  export type TransferOrderItemScalarWhereWithAggregatesInput = {
    AND?: TransferOrderItemScalarWhereWithAggregatesInput | TransferOrderItemScalarWhereWithAggregatesInput[]
    OR?: TransferOrderItemScalarWhereWithAggregatesInput[]
    NOT?: TransferOrderItemScalarWhereWithAggregatesInput | TransferOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferOrderItem"> | string
    transferOrderId?: StringWithAggregatesFilter<"TransferOrderItem"> | string
    serialNumber?: StringNullableWithAggregatesFilter<"TransferOrderItem"> | string | null
    type?: StringNullableWithAggregatesFilter<"TransferOrderItem"> | string | null
    model?: StringNullableWithAggregatesFilter<"TransferOrderItem"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"TransferOrderItem"> | string | null
    isReceived?: BoolWithAggregatesFilter<"TransferOrderItem"> | boolean
    receivedAt?: DateTimeNullableWithAggregatesFilter<"TransferOrderItem"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"TransferOrderItem"> | string | null
  }

  export type MaintenanceApprovalWhereInput = {
    AND?: MaintenanceApprovalWhereInput | MaintenanceApprovalWhereInput[]
    OR?: MaintenanceApprovalWhereInput[]
    NOT?: MaintenanceApprovalWhereInput | MaintenanceApprovalWhereInput[]
    id?: StringFilter<"MaintenanceApproval"> | string
    requestId?: StringFilter<"MaintenanceApproval"> | string
    cost?: FloatFilter<"MaintenanceApproval"> | number
    parts?: StringFilter<"MaintenanceApproval"> | string
    status?: StringFilter<"MaintenanceApproval"> | string
    notes?: StringNullableFilter<"MaintenanceApproval"> | string | null
    branchId?: StringNullableFilter<"MaintenanceApproval"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceApproval"> | Date | string
    respondedAt?: DateTimeNullableFilter<"MaintenanceApproval"> | Date | string | null
    respondedBy?: StringNullableFilter<"MaintenanceApproval"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    request?: XOR<MaintenanceRequestRelationFilter, MaintenanceRequestWhereInput>
  }

  export type MaintenanceApprovalOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    cost?: SortOrder
    parts?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    request?: MaintenanceRequestOrderByWithRelationInput
  }

  export type MaintenanceApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestId?: string
    AND?: MaintenanceApprovalWhereInput | MaintenanceApprovalWhereInput[]
    OR?: MaintenanceApprovalWhereInput[]
    NOT?: MaintenanceApprovalWhereInput | MaintenanceApprovalWhereInput[]
    cost?: FloatFilter<"MaintenanceApproval"> | number
    parts?: StringFilter<"MaintenanceApproval"> | string
    status?: StringFilter<"MaintenanceApproval"> | string
    notes?: StringNullableFilter<"MaintenanceApproval"> | string | null
    branchId?: StringNullableFilter<"MaintenanceApproval"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceApproval"> | Date | string
    respondedAt?: DateTimeNullableFilter<"MaintenanceApproval"> | Date | string | null
    respondedBy?: StringNullableFilter<"MaintenanceApproval"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    request?: XOR<MaintenanceRequestRelationFilter, MaintenanceRequestWhereInput>
  }, "id" | "requestId">

  export type MaintenanceApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    cost?: SortOrder
    parts?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    _count?: MaintenanceApprovalCountOrderByAggregateInput
    _avg?: MaintenanceApprovalAvgOrderByAggregateInput
    _max?: MaintenanceApprovalMaxOrderByAggregateInput
    _min?: MaintenanceApprovalMinOrderByAggregateInput
    _sum?: MaintenanceApprovalSumOrderByAggregateInput
  }

  export type MaintenanceApprovalScalarWhereWithAggregatesInput = {
    AND?: MaintenanceApprovalScalarWhereWithAggregatesInput | MaintenanceApprovalScalarWhereWithAggregatesInput[]
    OR?: MaintenanceApprovalScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceApprovalScalarWhereWithAggregatesInput | MaintenanceApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceApproval"> | string
    requestId?: StringWithAggregatesFilter<"MaintenanceApproval"> | string
    cost?: FloatWithAggregatesFilter<"MaintenanceApproval"> | number
    parts?: StringWithAggregatesFilter<"MaintenanceApproval"> | string
    status?: StringWithAggregatesFilter<"MaintenanceApproval"> | string
    notes?: StringNullableWithAggregatesFilter<"MaintenanceApproval"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"MaintenanceApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceApproval"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceApproval"> | Date | string | null
    respondedBy?: StringNullableWithAggregatesFilter<"MaintenanceApproval"> | string | null
  }

  export type RepairVoucherWhereInput = {
    AND?: RepairVoucherWhereInput | RepairVoucherWhereInput[]
    OR?: RepairVoucherWhereInput[]
    NOT?: RepairVoucherWhereInput | RepairVoucherWhereInput[]
    id?: StringFilter<"RepairVoucher"> | string
    code?: StringFilter<"RepairVoucher"> | string
    requestId?: StringFilter<"RepairVoucher"> | string
    type?: StringFilter<"RepairVoucher"> | string
    parts?: StringFilter<"RepairVoucher"> | string
    totalCost?: FloatFilter<"RepairVoucher"> | number
    branchId?: StringNullableFilter<"RepairVoucher"> | string | null
    createdAt?: DateTimeFilter<"RepairVoucher"> | Date | string
    createdBy?: StringNullableFilter<"RepairVoucher"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    request?: XOR<MaintenanceRequestRelationFilter, MaintenanceRequestWhereInput>
  }

  export type RepairVoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    parts?: SortOrder
    totalCost?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    request?: MaintenanceRequestOrderByWithRelationInput
  }

  export type RepairVoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RepairVoucherWhereInput | RepairVoucherWhereInput[]
    OR?: RepairVoucherWhereInput[]
    NOT?: RepairVoucherWhereInput | RepairVoucherWhereInput[]
    requestId?: StringFilter<"RepairVoucher"> | string
    type?: StringFilter<"RepairVoucher"> | string
    parts?: StringFilter<"RepairVoucher"> | string
    totalCost?: FloatFilter<"RepairVoucher"> | number
    branchId?: StringNullableFilter<"RepairVoucher"> | string | null
    createdAt?: DateTimeFilter<"RepairVoucher"> | Date | string
    createdBy?: StringNullableFilter<"RepairVoucher"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    request?: XOR<MaintenanceRequestRelationFilter, MaintenanceRequestWhereInput>
  }, "id" | "code">

  export type RepairVoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    parts?: SortOrder
    totalCost?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: RepairVoucherCountOrderByAggregateInput
    _avg?: RepairVoucherAvgOrderByAggregateInput
    _max?: RepairVoucherMaxOrderByAggregateInput
    _min?: RepairVoucherMinOrderByAggregateInput
    _sum?: RepairVoucherSumOrderByAggregateInput
  }

  export type RepairVoucherScalarWhereWithAggregatesInput = {
    AND?: RepairVoucherScalarWhereWithAggregatesInput | RepairVoucherScalarWhereWithAggregatesInput[]
    OR?: RepairVoucherScalarWhereWithAggregatesInput[]
    NOT?: RepairVoucherScalarWhereWithAggregatesInput | RepairVoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RepairVoucher"> | string
    code?: StringWithAggregatesFilter<"RepairVoucher"> | string
    requestId?: StringWithAggregatesFilter<"RepairVoucher"> | string
    type?: StringWithAggregatesFilter<"RepairVoucher"> | string
    parts?: StringWithAggregatesFilter<"RepairVoucher"> | string
    totalCost?: FloatWithAggregatesFilter<"RepairVoucher"> | number
    branchId?: StringNullableWithAggregatesFilter<"RepairVoucher"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RepairVoucher"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"RepairVoucher"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    branchId?: StringNullableFilter<"Notification"> | string | null
    link?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringNullableFilter<"Notification"> | string | null
    branchId?: StringNullableFilter<"Notification"> | string | null
    link?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ServiceAssignmentWhereInput = {
    AND?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    OR?: ServiceAssignmentWhereInput[]
    NOT?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    id?: StringFilter<"ServiceAssignment"> | string
    machineId?: StringFilter<"ServiceAssignment"> | string
    serialNumber?: StringFilter<"ServiceAssignment"> | string
    technicianId?: StringFilter<"ServiceAssignment"> | string
    technicianName?: StringFilter<"ServiceAssignment"> | string
    status?: StringFilter<"ServiceAssignment"> | string
    proposedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    proposedTotal?: FloatFilter<"ServiceAssignment"> | number
    usedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    totalCost?: FloatFilter<"ServiceAssignment"> | number
    needsApproval?: BoolFilter<"ServiceAssignment"> | boolean
    approvedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectionReason?: StringNullableFilter<"ServiceAssignment"> | string | null
    actionTaken?: StringNullableFilter<"ServiceAssignment"> | string | null
    resolution?: StringNullableFilter<"ServiceAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    customerId?: StringNullableFilter<"ServiceAssignment"> | string | null
    customerName?: StringNullableFilter<"ServiceAssignment"> | string | null
    requestId?: StringNullableFilter<"ServiceAssignment"> | string | null
    branchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    centerBranchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    originBranchId?: StringFilter<"ServiceAssignment"> | string
    machine?: XOR<WarehouseMachineRelationFilter, WarehouseMachineWhereInput>
    logs?: ServiceAssignmentLogListRelationFilter
  }

  export type ServiceAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    technicianId?: SortOrder
    technicianName?: SortOrder
    status?: SortOrder
    proposedParts?: SortOrderInput | SortOrder
    proposedTotal?: SortOrder
    usedParts?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    needsApproval?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    centerBranchId?: SortOrderInput | SortOrder
    originBranchId?: SortOrder
    machine?: WarehouseMachineOrderByWithRelationInput
    logs?: ServiceAssignmentLogOrderByRelationAggregateInput
  }

  export type ServiceAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    OR?: ServiceAssignmentWhereInput[]
    NOT?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    machineId?: StringFilter<"ServiceAssignment"> | string
    serialNumber?: StringFilter<"ServiceAssignment"> | string
    technicianId?: StringFilter<"ServiceAssignment"> | string
    technicianName?: StringFilter<"ServiceAssignment"> | string
    status?: StringFilter<"ServiceAssignment"> | string
    proposedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    proposedTotal?: FloatFilter<"ServiceAssignment"> | number
    usedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    totalCost?: FloatFilter<"ServiceAssignment"> | number
    needsApproval?: BoolFilter<"ServiceAssignment"> | boolean
    approvedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectionReason?: StringNullableFilter<"ServiceAssignment"> | string | null
    actionTaken?: StringNullableFilter<"ServiceAssignment"> | string | null
    resolution?: StringNullableFilter<"ServiceAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    customerId?: StringNullableFilter<"ServiceAssignment"> | string | null
    customerName?: StringNullableFilter<"ServiceAssignment"> | string | null
    requestId?: StringNullableFilter<"ServiceAssignment"> | string | null
    branchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    centerBranchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    originBranchId?: StringFilter<"ServiceAssignment"> | string
    machine?: XOR<WarehouseMachineRelationFilter, WarehouseMachineWhereInput>
    logs?: ServiceAssignmentLogListRelationFilter
  }, "id">

  export type ServiceAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    technicianId?: SortOrder
    technicianName?: SortOrder
    status?: SortOrder
    proposedParts?: SortOrderInput | SortOrder
    proposedTotal?: SortOrder
    usedParts?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    needsApproval?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    centerBranchId?: SortOrderInput | SortOrder
    originBranchId?: SortOrder
    _count?: ServiceAssignmentCountOrderByAggregateInput
    _avg?: ServiceAssignmentAvgOrderByAggregateInput
    _max?: ServiceAssignmentMaxOrderByAggregateInput
    _min?: ServiceAssignmentMinOrderByAggregateInput
    _sum?: ServiceAssignmentSumOrderByAggregateInput
  }

  export type ServiceAssignmentScalarWhereWithAggregatesInput = {
    AND?: ServiceAssignmentScalarWhereWithAggregatesInput | ServiceAssignmentScalarWhereWithAggregatesInput[]
    OR?: ServiceAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ServiceAssignmentScalarWhereWithAggregatesInput | ServiceAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    machineId?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    serialNumber?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    technicianId?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    technicianName?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    status?: StringWithAggregatesFilter<"ServiceAssignment"> | string
    proposedParts?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    proposedTotal?: FloatWithAggregatesFilter<"ServiceAssignment"> | number
    usedParts?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    totalCost?: FloatWithAggregatesFilter<"ServiceAssignment"> | number
    needsApproval?: BoolWithAggregatesFilter<"ServiceAssignment"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    actionTaken?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"ServiceAssignment"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    customerId?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    centerBranchId?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
    originBranchId?: StringWithAggregatesFilter<"ServiceAssignment"> | string
  }

  export type ServiceAssignmentLogWhereInput = {
    AND?: ServiceAssignmentLogWhereInput | ServiceAssignmentLogWhereInput[]
    OR?: ServiceAssignmentLogWhereInput[]
    NOT?: ServiceAssignmentLogWhereInput | ServiceAssignmentLogWhereInput[]
    id?: StringFilter<"ServiceAssignmentLog"> | string
    assignmentId?: StringFilter<"ServiceAssignmentLog"> | string
    action?: StringFilter<"ServiceAssignmentLog"> | string
    details?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedBy?: StringFilter<"ServiceAssignmentLog"> | string
    performedById?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedAt?: DateTimeFilter<"ServiceAssignmentLog"> | Date | string
    assignment?: XOR<ServiceAssignmentRelationFilter, ServiceAssignmentWhereInput>
  }

  export type ServiceAssignmentLogOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    performedById?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    assignment?: ServiceAssignmentOrderByWithRelationInput
  }

  export type ServiceAssignmentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceAssignmentLogWhereInput | ServiceAssignmentLogWhereInput[]
    OR?: ServiceAssignmentLogWhereInput[]
    NOT?: ServiceAssignmentLogWhereInput | ServiceAssignmentLogWhereInput[]
    assignmentId?: StringFilter<"ServiceAssignmentLog"> | string
    action?: StringFilter<"ServiceAssignmentLog"> | string
    details?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedBy?: StringFilter<"ServiceAssignmentLog"> | string
    performedById?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedAt?: DateTimeFilter<"ServiceAssignmentLog"> | Date | string
    assignment?: XOR<ServiceAssignmentRelationFilter, ServiceAssignmentWhereInput>
  }, "id">

  export type ServiceAssignmentLogOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    performedById?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    _count?: ServiceAssignmentLogCountOrderByAggregateInput
    _max?: ServiceAssignmentLogMaxOrderByAggregateInput
    _min?: ServiceAssignmentLogMinOrderByAggregateInput
  }

  export type ServiceAssignmentLogScalarWhereWithAggregatesInput = {
    AND?: ServiceAssignmentLogScalarWhereWithAggregatesInput | ServiceAssignmentLogScalarWhereWithAggregatesInput[]
    OR?: ServiceAssignmentLogScalarWhereWithAggregatesInput[]
    NOT?: ServiceAssignmentLogScalarWhereWithAggregatesInput | ServiceAssignmentLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceAssignmentLog"> | string
    assignmentId?: StringWithAggregatesFilter<"ServiceAssignmentLog"> | string
    action?: StringWithAggregatesFilter<"ServiceAssignmentLog"> | string
    details?: StringNullableWithAggregatesFilter<"ServiceAssignmentLog"> | string | null
    performedBy?: StringWithAggregatesFilter<"ServiceAssignmentLog"> | string
    performedById?: StringNullableWithAggregatesFilter<"ServiceAssignmentLog"> | string | null
    performedAt?: DateTimeWithAggregatesFilter<"ServiceAssignmentLog"> | Date | string
  }

  export type BranchDebtWhereInput = {
    AND?: BranchDebtWhereInput | BranchDebtWhereInput[]
    OR?: BranchDebtWhereInput[]
    NOT?: BranchDebtWhereInput | BranchDebtWhereInput[]
    id?: StringFilter<"BranchDebt"> | string
    type?: StringFilter<"BranchDebt"> | string
    referenceId?: StringFilter<"BranchDebt"> | string
    machineSerial?: StringNullableFilter<"BranchDebt"> | string | null
    customerId?: StringNullableFilter<"BranchDebt"> | string | null
    customerName?: StringNullableFilter<"BranchDebt"> | string | null
    amount?: FloatFilter<"BranchDebt"> | number
    paidAmount?: FloatFilter<"BranchDebt"> | number
    remainingAmount?: FloatFilter<"BranchDebt"> | number
    partsDetails?: StringNullableFilter<"BranchDebt"> | string | null
    status?: StringFilter<"BranchDebt"> | string
    creditorBranchId?: StringFilter<"BranchDebt"> | string
    debtorBranchId?: StringFilter<"BranchDebt"> | string
    receiptNumber?: StringNullableFilter<"BranchDebt"> | string | null
    paymentPlace?: StringNullableFilter<"BranchDebt"> | string | null
    paidAt?: DateTimeNullableFilter<"BranchDebt"> | Date | string | null
    paidBy?: StringNullableFilter<"BranchDebt"> | string | null
    paidByUserId?: StringNullableFilter<"BranchDebt"> | string | null
    createdAt?: DateTimeFilter<"BranchDebt"> | Date | string
    updatedAt?: DateTimeFilter<"BranchDebt"> | Date | string
  }

  export type BranchDebtOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    machineSerial?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    partsDetails?: SortOrderInput | SortOrder
    status?: SortOrder
    creditorBranchId?: SortOrder
    debtorBranchId?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidBy?: SortOrderInput | SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchDebtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchDebtWhereInput | BranchDebtWhereInput[]
    OR?: BranchDebtWhereInput[]
    NOT?: BranchDebtWhereInput | BranchDebtWhereInput[]
    type?: StringFilter<"BranchDebt"> | string
    referenceId?: StringFilter<"BranchDebt"> | string
    machineSerial?: StringNullableFilter<"BranchDebt"> | string | null
    customerId?: StringNullableFilter<"BranchDebt"> | string | null
    customerName?: StringNullableFilter<"BranchDebt"> | string | null
    amount?: FloatFilter<"BranchDebt"> | number
    paidAmount?: FloatFilter<"BranchDebt"> | number
    remainingAmount?: FloatFilter<"BranchDebt"> | number
    partsDetails?: StringNullableFilter<"BranchDebt"> | string | null
    status?: StringFilter<"BranchDebt"> | string
    creditorBranchId?: StringFilter<"BranchDebt"> | string
    debtorBranchId?: StringFilter<"BranchDebt"> | string
    receiptNumber?: StringNullableFilter<"BranchDebt"> | string | null
    paymentPlace?: StringNullableFilter<"BranchDebt"> | string | null
    paidAt?: DateTimeNullableFilter<"BranchDebt"> | Date | string | null
    paidBy?: StringNullableFilter<"BranchDebt"> | string | null
    paidByUserId?: StringNullableFilter<"BranchDebt"> | string | null
    createdAt?: DateTimeFilter<"BranchDebt"> | Date | string
    updatedAt?: DateTimeFilter<"BranchDebt"> | Date | string
  }, "id">

  export type BranchDebtOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    machineSerial?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    partsDetails?: SortOrderInput | SortOrder
    status?: SortOrder
    creditorBranchId?: SortOrder
    debtorBranchId?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    paymentPlace?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidBy?: SortOrderInput | SortOrder
    paidByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchDebtCountOrderByAggregateInput
    _avg?: BranchDebtAvgOrderByAggregateInput
    _max?: BranchDebtMaxOrderByAggregateInput
    _min?: BranchDebtMinOrderByAggregateInput
    _sum?: BranchDebtSumOrderByAggregateInput
  }

  export type BranchDebtScalarWhereWithAggregatesInput = {
    AND?: BranchDebtScalarWhereWithAggregatesInput | BranchDebtScalarWhereWithAggregatesInput[]
    OR?: BranchDebtScalarWhereWithAggregatesInput[]
    NOT?: BranchDebtScalarWhereWithAggregatesInput | BranchDebtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BranchDebt"> | string
    type?: StringWithAggregatesFilter<"BranchDebt"> | string
    referenceId?: StringWithAggregatesFilter<"BranchDebt"> | string
    machineSerial?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    amount?: FloatWithAggregatesFilter<"BranchDebt"> | number
    paidAmount?: FloatWithAggregatesFilter<"BranchDebt"> | number
    remainingAmount?: FloatWithAggregatesFilter<"BranchDebt"> | number
    partsDetails?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    status?: StringWithAggregatesFilter<"BranchDebt"> | string
    creditorBranchId?: StringWithAggregatesFilter<"BranchDebt"> | string
    debtorBranchId?: StringWithAggregatesFilter<"BranchDebt"> | string
    receiptNumber?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    paymentPlace?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"BranchDebt"> | Date | string | null
    paidBy?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    paidByUserId?: StringNullableWithAggregatesFilter<"BranchDebt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BranchDebt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BranchDebt"> | Date | string
  }

  export type MaintenanceApprovalRequestWhereInput = {
    AND?: MaintenanceApprovalRequestWhereInput | MaintenanceApprovalRequestWhereInput[]
    OR?: MaintenanceApprovalRequestWhereInput[]
    NOT?: MaintenanceApprovalRequestWhereInput | MaintenanceApprovalRequestWhereInput[]
    id?: StringFilter<"MaintenanceApprovalRequest"> | string
    assignmentId?: StringFilter<"MaintenanceApprovalRequest"> | string
    machineSerial?: StringFilter<"MaintenanceApprovalRequest"> | string
    customerId?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    customerName?: StringFilter<"MaintenanceApprovalRequest"> | string
    proposedParts?: StringFilter<"MaintenanceApprovalRequest"> | string
    proposedTotal?: FloatFilter<"MaintenanceApprovalRequest"> | number
    diagnosis?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    status?: StringFilter<"MaintenanceApprovalRequest"> | string
    rejectionReason?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedBy?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedById?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedAt?: DateTimeNullableFilter<"MaintenanceApprovalRequest"> | Date | string | null
    centerBranchId?: StringFilter<"MaintenanceApprovalRequest"> | string
    originBranchId?: StringFilter<"MaintenanceApprovalRequest"> | string
    createdAt?: DateTimeFilter<"MaintenanceApprovalRequest"> | Date | string
  }

  export type MaintenanceApprovalRequestOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    respondedById?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceApprovalRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assignmentId?: string
    AND?: MaintenanceApprovalRequestWhereInput | MaintenanceApprovalRequestWhereInput[]
    OR?: MaintenanceApprovalRequestWhereInput[]
    NOT?: MaintenanceApprovalRequestWhereInput | MaintenanceApprovalRequestWhereInput[]
    machineSerial?: StringFilter<"MaintenanceApprovalRequest"> | string
    customerId?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    customerName?: StringFilter<"MaintenanceApprovalRequest"> | string
    proposedParts?: StringFilter<"MaintenanceApprovalRequest"> | string
    proposedTotal?: FloatFilter<"MaintenanceApprovalRequest"> | number
    diagnosis?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    status?: StringFilter<"MaintenanceApprovalRequest"> | string
    rejectionReason?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedBy?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedById?: StringNullableFilter<"MaintenanceApprovalRequest"> | string | null
    respondedAt?: DateTimeNullableFilter<"MaintenanceApprovalRequest"> | Date | string | null
    centerBranchId?: StringFilter<"MaintenanceApprovalRequest"> | string
    originBranchId?: StringFilter<"MaintenanceApprovalRequest"> | string
    createdAt?: DateTimeFilter<"MaintenanceApprovalRequest"> | Date | string
  }, "id" | "assignmentId">

  export type MaintenanceApprovalRequestOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    respondedById?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
    createdAt?: SortOrder
    _count?: MaintenanceApprovalRequestCountOrderByAggregateInput
    _avg?: MaintenanceApprovalRequestAvgOrderByAggregateInput
    _max?: MaintenanceApprovalRequestMaxOrderByAggregateInput
    _min?: MaintenanceApprovalRequestMinOrderByAggregateInput
    _sum?: MaintenanceApprovalRequestSumOrderByAggregateInput
  }

  export type MaintenanceApprovalRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceApprovalRequestScalarWhereWithAggregatesInput | MaintenanceApprovalRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceApprovalRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceApprovalRequestScalarWhereWithAggregatesInput | MaintenanceApprovalRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    assignmentId?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    machineSerial?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    customerId?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    customerName?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    proposedParts?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    proposedTotal?: FloatWithAggregatesFilter<"MaintenanceApprovalRequest"> | number
    diagnosis?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    status?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    rejectionReason?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    respondedBy?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    respondedById?: StringNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceApprovalRequest"> | Date | string | null
    centerBranchId?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    originBranchId?: StringWithAggregatesFilter<"MaintenanceApprovalRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceApprovalRequest"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
    branchId?: string | null
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
    branchId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ClientTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ClientTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ClientTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MachineParameterCreateInput = {
    id?: string
    prefix: string
    model: string
    manufacturer: string
  }

  export type MachineParameterUncheckedCreateInput = {
    id?: string
    prefix: string
    model: string
    manufacturer: string
  }

  export type MachineParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type MachineParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type MachineParameterCreateManyInput = {
    id?: string
    prefix: string
    model: string
    manufacturer: string
  }

  export type MachineParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type MachineParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    role: string
    permissionType: string
    permissionKey: string
    isAllowed?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    role: string
    permissionType: string
    permissionKey: string
    isAllowed?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionKey?: StringFieldUpdateOperationsInput | string
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionKey?: StringFieldUpdateOperationsInput | string
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    role: string
    permissionType: string
    permissionKey: string
    isAllowed?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionKey?: StringFieldUpdateOperationsInput | string
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionKey?: StringFieldUpdateOperationsInput | string
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SparePartCreateInput = {
    id?: string
    partNumber?: string | null
    name: string
    description?: string | null
    compatibleModels?: string | null
    defaultCost?: number
    isConsumable?: boolean | null
    allowsMultiple?: boolean | null
    inventoryItems?: InventoryItemCreateNestedManyWithoutPartInput
  }

  export type SparePartUncheckedCreateInput = {
    id?: string
    partNumber?: string | null
    name: string
    description?: string | null
    compatibleModels?: string | null
    defaultCost?: number
    isConsumable?: boolean | null
    allowsMultiple?: boolean | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutPartInput
  }

  export type SparePartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inventoryItems?: InventoryItemUpdateManyWithoutPartNestedInput
  }

  export type SparePartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutPartNestedInput
  }

  export type SparePartCreateManyInput = {
    id?: string
    partNumber?: string | null
    name: string
    description?: string | null
    compatibleModels?: string | null
    defaultCost?: number
    isConsumable?: boolean | null
    allowsMultiple?: boolean | null
  }

  export type SparePartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SparePartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InventoryItemCreateInput = {
    id?: string
    quantity?: number
    minLevel?: number
    location?: string | null
    part: SparePartCreateNestedOneWithoutInventoryItemsInput
    branch?: BranchCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    partId: string
    quantity?: number
    minLevel?: number
    location?: string | null
    branchId?: string | null
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    part?: SparePartUpdateOneRequiredWithoutInventoryItemsNestedInput
    branch?: BranchUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    partId: string
    quantity?: number
    minLevel?: number
    location?: string | null
    branchId?: string | null
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestCreateInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalCreateNestedOneWithoutRequestInput
    customer: CustomerCreateNestedOneWithoutRequestsInput
    posMachine?: PosMachineCreateNestedOneWithoutRequestsInput
    branch?: BranchCreateNestedOneWithoutRequestsInput
    vouchers?: RepairVoucherCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUncheckedCreateInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUpdateOneWithoutRequestNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRequestsNestedInput
    posMachine?: PosMachineUpdateOneWithoutRequestsNestedInput
    branch?: BranchUpdateOneWithoutRequestsNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestCreateManyInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
  }

  export type MaintenanceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MaintenanceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PriceChangeLogCreateInput = {
    id?: string
    partId: string
    oldCost: number
    newCost: number
    changedAt?: Date | string
    userId?: string | null
  }

  export type PriceChangeLogUncheckedCreateInput = {
    id?: string
    partId: string
    oldCost: number
    newCost: number
    changedAt?: Date | string
    userId?: string | null
  }

  export type PriceChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    oldCost?: FloatFieldUpdateOperationsInput | number
    newCost?: FloatFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    oldCost?: FloatFieldUpdateOperationsInput | number
    newCost?: FloatFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceChangeLogCreateManyInput = {
    id?: string
    partId: string
    oldCost: number
    newCost: number
    changedAt?: Date | string
    userId?: string | null
  }

  export type PriceChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    oldCost?: FloatFieldUpdateOperationsInput | number
    newCost?: FloatFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    oldCost?: FloatFieldUpdateOperationsInput | number
    newCost?: FloatFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsedPartLogCreateInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
    branch?: BranchCreateNestedOneWithoutUsedPartLogsInput
  }

  export type UsedPartLogUncheckedCreateInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type UsedPartLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutUsedPartLogsNestedInput
  }

  export type UsedPartLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsedPartLogCreateManyInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type UsedPartLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsedPartLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockMovementCreateInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutPaymentsInput
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMovementLogCreateInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutMachineMovementsInput
  }

  export type MachineMovementLogUncheckedCreateInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type MachineMovementLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutMachineMovementsNestedInput
  }

  export type MachineMovementLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMovementLogCreateManyInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type MachineMovementLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMovementLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSystemLogsInput
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSystemLogsNestedInput
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentCreateInput = {
    id?: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    sale: MachineSaleCreateNestedOneWithoutInstallmentsInput
    branch?: BranchCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateInput = {
    id?: string
    saleId: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type InstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: MachineSaleUpdateOneRequiredWithoutInstallmentsNestedInput
    branch?: BranchUpdateOneWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentCreateManyInput = {
    id?: string
    saleId: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type InstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MachineSaleCreateInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    installments?: InstallmentCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    branch?: BranchCreateNestedOneWithoutSalesInput
  }

  export type MachineSaleUncheckedCreateInput = {
    id?: string
    serialNumber: string
    customerId: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    branchId?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type MachineSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    branch?: BranchUpdateOneWithoutSalesNestedInput
  }

  export type MachineSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type MachineSaleCreateManyInput = {
    id?: string
    serialNumber: string
    customerId: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    branchId?: string | null
  }

  export type MachineSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MachineSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PosMachineCreateInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    requests?: MaintenanceRequestCreateNestedManyWithoutPosMachineInput
    customer?: CustomerCreateNestedOneWithoutMachinesInput
    branch?: BranchCreateNestedOneWithoutPosMachinesInput
  }

  export type PosMachineUncheckedCreateInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    customerId?: string | null
    isMain?: boolean | null
    branchId?: string | null
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutPosMachineInput
  }

  export type PosMachineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requests?: MaintenanceRequestUpdateManyWithoutPosMachineNestedInput
    customer?: CustomerUpdateOneWithoutMachinesNestedInput
    branch?: BranchUpdateOneWithoutPosMachinesNestedInput
  }

  export type PosMachineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutPosMachineNestedInput
  }

  export type PosMachineCreateManyInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    customerId?: string | null
    isMain?: boolean | null
    branchId?: string | null
  }

  export type PosMachineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PosMachineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardCreateInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customer?: CustomerCreateNestedOneWithoutSimCardsInput
    branch?: BranchCreateNestedOneWithoutSimCardsInput
  }

  export type SimCardUncheckedCreateInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customerId?: string | null
    branchId?: string | null
  }

  export type SimCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSimCardsNestedInput
    branch?: BranchUpdateOneWithoutSimCardsNestedInput
  }

  export type SimCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardCreateManyInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customerId?: string | null
    branchId?: string | null
  }

  export type SimCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseMachineCreateInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutMachineInput
    branch?: BranchCreateNestedOneWithoutWarehouseMachinesInput
  }

  export type WarehouseMachineUncheckedCreateInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    branchId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WarehouseMachineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutMachineNestedInput
    branch?: BranchUpdateOneWithoutWarehouseMachinesNestedInput
  }

  export type WarehouseMachineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WarehouseMachineCreateManyInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    branchId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
  }

  export type WarehouseMachineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseMachineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseSimCreateInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutWarehouseSimsInput
  }

  export type WarehouseSimUncheckedCreateInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type WarehouseSimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutWarehouseSimsNestedInput
  }

  export type WarehouseSimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseSimCreateManyInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type WarehouseSimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseSimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimMovementLogCreateInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSimMovementsInput
  }

  export type SimMovementLogUncheckedCreateInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type SimMovementLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSimMovementsNestedInput
  }

  export type SimMovementLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimMovementLogCreateManyInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type SimMovementLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimMovementLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderCreateInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    toBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
    fromBranch: BranchCreateNestedOneWithoutSentTransfersInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    fromBranchId: string
    toBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    fromBranchId?: StringFieldUpdateOperationsInput | string
    toBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderCreateManyInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    fromBranchId: string
    toBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    fromBranchId?: StringFieldUpdateOperationsInput | string
    toBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderItemCreateInput = {
    id?: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
    transferOrder: TransferOrderCreateNestedOneWithoutItemsInput
  }

  export type TransferOrderItemUncheckedCreateInput = {
    id?: string
    transferOrderId: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
  }

  export type TransferOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transferOrder?: TransferOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferOrderItemCreateManyInput = {
    id?: string
    transferOrderId: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
  }

  export type TransferOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceApprovalCreateInput = {
    id?: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
    branch?: BranchCreateNestedOneWithoutApprovalsInput
    request: MaintenanceRequestCreateNestedOneWithoutApprovalInput
  }

  export type MaintenanceApprovalUncheckedCreateInput = {
    id?: string
    requestId: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    branchId?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
  }

  export type MaintenanceApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutApprovalsNestedInput
    request?: MaintenanceRequestUpdateOneRequiredWithoutApprovalNestedInput
  }

  export type MaintenanceApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceApprovalCreateManyInput = {
    id?: string
    requestId: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    branchId?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
  }

  export type MaintenanceApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherCreateInput = {
    id?: string
    code: string
    type: string
    parts: string
    totalCost: number
    createdAt?: Date | string
    createdBy?: string | null
    branch?: BranchCreateNestedOneWithoutVouchersInput
    request: MaintenanceRequestCreateNestedOneWithoutVouchersInput
  }

  export type RepairVoucherUncheckedCreateInput = {
    id?: string
    code: string
    requestId: string
    type: string
    parts: string
    totalCost: number
    branchId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type RepairVoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    request?: MaintenanceRequestUpdateOneRequiredWithoutVouchersNestedInput
  }

  export type RepairVoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherCreateManyInput = {
    id?: string
    code: string
    requestId: string
    type: string
    parts: string
    totalCost: number
    branchId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type RepairVoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    userId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    branchId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId?: string | null
    branchId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentCreateInput = {
    id?: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
    machine: WarehouseMachineCreateNestedOneWithoutServiceAssignmentsInput
    logs?: ServiceAssignmentLogCreateNestedManyWithoutAssignmentInput
  }

  export type ServiceAssignmentUncheckedCreateInput = {
    id?: string
    machineId: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
    logs?: ServiceAssignmentLogUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type ServiceAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
    machine?: WarehouseMachineUpdateOneRequiredWithoutServiceAssignmentsNestedInput
    logs?: ServiceAssignmentLogUpdateManyWithoutAssignmentNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
    logs?: ServiceAssignmentLogUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type ServiceAssignmentCreateManyInput = {
    id?: string
    machineId: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
  }

  export type ServiceAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAssignmentLogCreateInput = {
    id?: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
    assignment: ServiceAssignmentCreateNestedOneWithoutLogsInput
  }

  export type ServiceAssignmentLogUncheckedCreateInput = {
    id?: string
    assignmentId: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
  }

  export type ServiceAssignmentLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: ServiceAssignmentUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ServiceAssignmentLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentLogCreateManyInput = {
    id?: string
    assignmentId: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
  }

  export type ServiceAssignmentLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchDebtCreateInput = {
    id?: string
    type: string
    referenceId: string
    machineSerial?: string | null
    customerId?: string | null
    customerName?: string | null
    amount: number
    paidAmount?: number
    remainingAmount: number
    partsDetails?: string | null
    status?: string
    creditorBranchId: string
    debtorBranchId: string
    receiptNumber?: string | null
    paymentPlace?: string | null
    paidAt?: Date | string | null
    paidBy?: string | null
    paidByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchDebtUncheckedCreateInput = {
    id?: string
    type: string
    referenceId: string
    machineSerial?: string | null
    customerId?: string | null
    customerName?: string | null
    amount: number
    paidAmount?: number
    remainingAmount: number
    partsDetails?: string | null
    status?: string
    creditorBranchId: string
    debtorBranchId: string
    receiptNumber?: string | null
    paymentPlace?: string | null
    paidAt?: Date | string | null
    paidBy?: string | null
    paidByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchDebtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    machineSerial?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    partsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creditorBranchId?: StringFieldUpdateOperationsInput | string
    debtorBranchId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchDebtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    machineSerial?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    partsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creditorBranchId?: StringFieldUpdateOperationsInput | string
    debtorBranchId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchDebtCreateManyInput = {
    id?: string
    type: string
    referenceId: string
    machineSerial?: string | null
    customerId?: string | null
    customerName?: string | null
    amount: number
    paidAmount?: number
    remainingAmount: number
    partsDetails?: string | null
    status?: string
    creditorBranchId: string
    debtorBranchId: string
    receiptNumber?: string | null
    paymentPlace?: string | null
    paidAt?: Date | string | null
    paidBy?: string | null
    paidByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchDebtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    machineSerial?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    partsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creditorBranchId?: StringFieldUpdateOperationsInput | string
    debtorBranchId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchDebtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    machineSerial?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    partsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creditorBranchId?: StringFieldUpdateOperationsInput | string
    debtorBranchId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    paidByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceApprovalRequestCreateInput = {
    id?: string
    assignmentId: string
    machineSerial: string
    customerId?: string | null
    customerName: string
    proposedParts: string
    proposedTotal: number
    diagnosis?: string | null
    notes?: string | null
    status?: string
    rejectionReason?: string | null
    respondedBy?: string | null
    respondedById?: string | null
    respondedAt?: Date | string | null
    centerBranchId: string
    originBranchId: string
    createdAt?: Date | string
  }

  export type MaintenanceApprovalRequestUncheckedCreateInput = {
    id?: string
    assignmentId: string
    machineSerial: string
    customerId?: string | null
    customerName: string
    proposedParts: string
    proposedTotal: number
    diagnosis?: string | null
    notes?: string | null
    status?: string
    rejectionReason?: string | null
    respondedBy?: string | null
    respondedById?: string | null
    respondedAt?: Date | string | null
    centerBranchId: string
    originBranchId: string
    createdAt?: Date | string
  }

  export type MaintenanceApprovalRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    machineSerial?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    proposedParts?: StringFieldUpdateOperationsInput | string
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centerBranchId?: StringFieldUpdateOperationsInput | string
    originBranchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceApprovalRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    machineSerial?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    proposedParts?: StringFieldUpdateOperationsInput | string
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centerBranchId?: StringFieldUpdateOperationsInput | string
    originBranchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceApprovalRequestCreateManyInput = {
    id?: string
    assignmentId: string
    machineSerial: string
    customerId?: string | null
    customerName: string
    proposedParts: string
    proposedTotal: number
    diagnosis?: string | null
    notes?: string | null
    status?: string
    rejectionReason?: string | null
    respondedBy?: string | null
    respondedById?: string | null
    respondedAt?: Date | string | null
    centerBranchId: string
    originBranchId: string
    createdAt?: Date | string
  }

  export type MaintenanceApprovalRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    machineSerial?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    proposedParts?: StringFieldUpdateOperationsInput | string
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centerBranchId?: StringFieldUpdateOperationsInput | string
    originBranchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceApprovalRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    machineSerial?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    proposedParts?: StringFieldUpdateOperationsInput | string
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centerBranchId?: StringFieldUpdateOperationsInput | string
    originBranchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    canDoMaintenance?: SortOrder
    password?: SortOrder
    theme?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    highlightEffect?: SortOrder
    notificationSound?: SortOrder
    mobilePush?: SortOrder
    createdAt?: SortOrder
    branchId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    canDoMaintenance?: SortOrder
    password?: SortOrder
    theme?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    highlightEffect?: SortOrder
    notificationSound?: SortOrder
    mobilePush?: SortOrder
    createdAt?: SortOrder
    branchId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    canDoMaintenance?: SortOrder
    password?: SortOrder
    theme?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    highlightEffect?: SortOrder
    notificationSound?: SortOrder
    mobilePush?: SortOrder
    createdAt?: SortOrder
    branchId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClientTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type InstallmentListRelationFilter = {
    every?: InstallmentWhereInput
    some?: InstallmentWhereInput
    none?: InstallmentWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type MachineMovementLogListRelationFilter = {
    every?: MachineMovementLogWhereInput
    some?: MachineMovementLogWhereInput
    none?: MachineMovementLogWhereInput
  }

  export type MachineSaleListRelationFilter = {
    every?: MachineSaleWhereInput
    some?: MachineSaleWhereInput
    none?: MachineSaleWhereInput
  }

  export type MaintenanceApprovalListRelationFilter = {
    every?: MaintenanceApprovalWhereInput
    some?: MaintenanceApprovalWhereInput
    none?: MaintenanceApprovalWhereInput
  }

  export type MaintenanceRequestListRelationFilter = {
    every?: MaintenanceRequestWhereInput
    some?: MaintenanceRequestWhereInput
    none?: MaintenanceRequestWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PosMachineListRelationFilter = {
    every?: PosMachineWhereInput
    some?: PosMachineWhereInput
    none?: PosMachineWhereInput
  }

  export type RepairVoucherListRelationFilter = {
    every?: RepairVoucherWhereInput
    some?: RepairVoucherWhereInput
    none?: RepairVoucherWhereInput
  }

  export type SimCardListRelationFilter = {
    every?: SimCardWhereInput
    some?: SimCardWhereInput
    none?: SimCardWhereInput
  }

  export type SimMovementLogListRelationFilter = {
    every?: SimMovementLogWhereInput
    some?: SimMovementLogWhereInput
    none?: SimMovementLogWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type SystemLogListRelationFilter = {
    every?: SystemLogWhereInput
    some?: SystemLogWhereInput
    none?: SystemLogWhereInput
  }

  export type TransferOrderListRelationFilter = {
    every?: TransferOrderWhereInput
    some?: TransferOrderWhereInput
    none?: TransferOrderWhereInput
  }

  export type UsedPartLogListRelationFilter = {
    every?: UsedPartLogWhereInput
    some?: UsedPartLogWhereInput
    none?: UsedPartLogWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type WarehouseMachineListRelationFilter = {
    every?: WarehouseMachineWhereInput
    some?: WarehouseMachineWhereInput
    none?: WarehouseMachineWhereInput
  }

  export type WarehouseSimListRelationFilter = {
    every?: WarehouseSimWhereInput
    some?: WarehouseSimWhereInput
    none?: WarehouseSimWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineMovementLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepairVoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimMovementLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsedPartLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseSimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    parentBranchId?: SortOrder
    maintenanceCenterId?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    parentBranchId?: SortOrder
    maintenanceCenterId?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    parentBranchId?: SortOrder
    maintenanceCenterId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    bkcode?: SortOrder
    client_name?: SortOrder
    supply_office?: SortOrder
    operating_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    scanned_id_path?: SortOrder
    national_id?: SortOrder
    dept?: SortOrder
    telephone_1?: SortOrder
    telephone_2?: SortOrder
    has_gates?: SortOrder
    bk_type?: SortOrder
    notes?: SortOrder
    papers_date?: SortOrder
    isSpecial?: SortOrder
    clienttype?: SortOrder
    branchId?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    bkcode?: SortOrder
    client_name?: SortOrder
    supply_office?: SortOrder
    operating_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    scanned_id_path?: SortOrder
    national_id?: SortOrder
    dept?: SortOrder
    telephone_1?: SortOrder
    telephone_2?: SortOrder
    has_gates?: SortOrder
    bk_type?: SortOrder
    notes?: SortOrder
    papers_date?: SortOrder
    isSpecial?: SortOrder
    clienttype?: SortOrder
    branchId?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    bkcode?: SortOrder
    client_name?: SortOrder
    supply_office?: SortOrder
    operating_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    scanned_id_path?: SortOrder
    national_id?: SortOrder
    dept?: SortOrder
    telephone_1?: SortOrder
    telephone_2?: SortOrder
    has_gates?: SortOrder
    bk_type?: SortOrder
    notes?: SortOrder
    papers_date?: SortOrder
    isSpecial?: SortOrder
    clienttype?: SortOrder
    branchId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type MachineParameterCountOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
  }

  export type MachineParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
  }

  export type MachineParameterMinOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
  }

  export type RolePermissionRolePermissionTypePermissionKeyCompoundUniqueInput = {
    role: string
    permissionType: string
    permissionKey: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionType?: SortOrder
    permissionKey?: SortOrder
    isAllowed?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionType?: SortOrder
    permissionKey?: SortOrder
    isAllowed?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionType?: SortOrder
    permissionKey?: SortOrder
    isAllowed?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SparePartCountOrderByAggregateInput = {
    id?: SortOrder
    partNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    compatibleModels?: SortOrder
    defaultCost?: SortOrder
    isConsumable?: SortOrder
    allowsMultiple?: SortOrder
  }

  export type SparePartAvgOrderByAggregateInput = {
    defaultCost?: SortOrder
  }

  export type SparePartMaxOrderByAggregateInput = {
    id?: SortOrder
    partNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    compatibleModels?: SortOrder
    defaultCost?: SortOrder
    isConsumable?: SortOrder
    allowsMultiple?: SortOrder
  }

  export type SparePartMinOrderByAggregateInput = {
    id?: SortOrder
    partNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    compatibleModels?: SortOrder
    defaultCost?: SortOrder
    isConsumable?: SortOrder
    allowsMultiple?: SortOrder
  }

  export type SparePartSumOrderByAggregateInput = {
    defaultCost?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SparePartRelationFilter = {
    is?: SparePartWhereInput
    isNot?: SparePartWhereInput
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    minLevel?: SortOrder
    location?: SortOrder
    branchId?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    minLevel?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    minLevel?: SortOrder
    location?: SortOrder
    branchId?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    minLevel?: SortOrder
    location?: SortOrder
    branchId?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    minLevel?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MaintenanceApprovalNullableRelationFilter = {
    is?: MaintenanceApprovalWhereInput | null
    isNot?: MaintenanceApprovalWhereInput | null
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PosMachineNullableRelationFilter = {
    is?: PosMachineWhereInput | null
    isNot?: PosMachineWhereInput | null
  }

  export type MaintenanceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    posMachineId?: SortOrder
    customerName?: SortOrder
    machineModel?: SortOrder
    machineManufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    servicedByBranchId?: SortOrder
    technician?: SortOrder
    notes?: SortOrder
    complaint?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
    closingUserId?: SortOrder
    closingUserName?: SortOrder
    closingTimestamp?: SortOrder
    usedParts?: SortOrder
    receiptNumber?: SortOrder
    totalCost?: SortOrder
  }

  export type MaintenanceRequestAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type MaintenanceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    posMachineId?: SortOrder
    customerName?: SortOrder
    machineModel?: SortOrder
    machineManufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    servicedByBranchId?: SortOrder
    technician?: SortOrder
    notes?: SortOrder
    complaint?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
    closingUserId?: SortOrder
    closingUserName?: SortOrder
    closingTimestamp?: SortOrder
    usedParts?: SortOrder
    receiptNumber?: SortOrder
    totalCost?: SortOrder
  }

  export type MaintenanceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    posMachineId?: SortOrder
    customerName?: SortOrder
    machineModel?: SortOrder
    machineManufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    servicedByBranchId?: SortOrder
    technician?: SortOrder
    notes?: SortOrder
    complaint?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
    closingUserId?: SortOrder
    closingUserName?: SortOrder
    closingTimestamp?: SortOrder
    usedParts?: SortOrder
    receiptNumber?: SortOrder
    totalCost?: SortOrder
  }

  export type MaintenanceRequestSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PriceChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    oldCost?: SortOrder
    newCost?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type PriceChangeLogAvgOrderByAggregateInput = {
    oldCost?: SortOrder
    newCost?: SortOrder
  }

  export type PriceChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    oldCost?: SortOrder
    newCost?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type PriceChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    oldCost?: SortOrder
    newCost?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type PriceChangeLogSumOrderByAggregateInput = {
    oldCost?: SortOrder
    newCost?: SortOrder
  }

  export type UsedPartLogCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    posMachineId?: SortOrder
    technician?: SortOrder
    closedByUserId?: SortOrder
    closedAt?: SortOrder
    parts?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type UsedPartLogMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    posMachineId?: SortOrder
    technician?: SortOrder
    closedByUserId?: SortOrder
    closedAt?: SortOrder
    parts?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type UsedPartLogMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    posMachineId?: SortOrder
    technician?: SortOrder
    closedByUserId?: SortOrder
    closedAt?: SortOrder
    parts?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    paymentPlace?: SortOrder
    paymentMethod?: SortOrder
    receiptNumber?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    paymentPlace?: SortOrder
    paymentMethod?: SortOrder
    receiptNumber?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    paymentPlace?: SortOrder
    paymentMethod?: SortOrder
    receiptNumber?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MachineMovementLogCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineMovementLogMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineMovementLogMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineSaleRelationFilter = {
    is?: MachineSaleWhereInput
    isNot?: MachineSaleWhereInput
  }

  export type InstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    description?: SortOrder
    paidAmount?: SortOrder
    paymentPlace?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type InstallmentAvgOrderByAggregateInput = {
    amount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    description?: SortOrder
    paidAmount?: SortOrder
    paymentPlace?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type InstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    description?: SortOrder
    paidAmount?: SortOrder
    paymentPlace?: SortOrder
    receiptNumber?: SortOrder
    branchId?: SortOrder
  }

  export type InstallmentSumOrderByAggregateInput = {
    amount?: SortOrder
    paidAmount?: SortOrder
  }

  export type MachineSaleCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    type?: SortOrder
    totalPrice?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
  }

  export type MachineSaleAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    paidAmount?: SortOrder
  }

  export type MachineSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    type?: SortOrder
    totalPrice?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
  }

  export type MachineSaleMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    type?: SortOrder
    totalPrice?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
  }

  export type MachineSaleSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    paidAmount?: SortOrder
  }

  export type PosMachineCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    posId?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    customerId?: SortOrder
    isMain?: SortOrder
    branchId?: SortOrder
  }

  export type PosMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    posId?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    customerId?: SortOrder
    isMain?: SortOrder
    branchId?: SortOrder
  }

  export type PosMachineMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    posId?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    customerId?: SortOrder
    isMain?: SortOrder
    branchId?: SortOrder
  }

  export type SimCardCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
  }

  export type SimCardMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
  }

  export type SimCardMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceAssignmentListRelationFilter = {
    every?: ServiceAssignmentWhereInput
    some?: ServiceAssignmentWhereInput
    none?: ServiceAssignmentWhereInput
  }

  export type ServiceAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseMachineCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    originalOwnerId?: SortOrder
    branchId?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    readyForPickup?: SortOrder
    currentAssignmentId?: SortOrder
    currentTechnicianId?: SortOrder
    currentTechnicianName?: SortOrder
    originBranchId?: SortOrder
    proposedParts?: SortOrder
    proposedRepairNotes?: SortOrder
    proposedTotalCost?: SortOrder
    repairNotes?: SortOrder
    totalCost?: SortOrder
    usedParts?: SortOrder
  }

  export type WarehouseMachineAvgOrderByAggregateInput = {
    proposedTotalCost?: SortOrder
    totalCost?: SortOrder
  }

  export type WarehouseMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    originalOwnerId?: SortOrder
    branchId?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    readyForPickup?: SortOrder
    currentAssignmentId?: SortOrder
    currentTechnicianId?: SortOrder
    currentTechnicianName?: SortOrder
    originBranchId?: SortOrder
    proposedParts?: SortOrder
    proposedRepairNotes?: SortOrder
    proposedTotalCost?: SortOrder
    repairNotes?: SortOrder
    totalCost?: SortOrder
    usedParts?: SortOrder
  }

  export type WarehouseMachineMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    originalOwnerId?: SortOrder
    branchId?: SortOrder
    requestId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    readyForPickup?: SortOrder
    currentAssignmentId?: SortOrder
    currentTechnicianId?: SortOrder
    currentTechnicianName?: SortOrder
    originBranchId?: SortOrder
    proposedParts?: SortOrder
    proposedRepairNotes?: SortOrder
    proposedTotalCost?: SortOrder
    repairNotes?: SortOrder
    totalCost?: SortOrder
    usedParts?: SortOrder
  }

  export type WarehouseMachineSumOrderByAggregateInput = {
    proposedTotalCost?: SortOrder
    totalCost?: SortOrder
  }

  export type WarehouseSimCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type WarehouseSimMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type WarehouseSimMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    importDate?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type SimMovementLogCountOrderByAggregateInput = {
    id?: SortOrder
    simId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type SimMovementLogMaxOrderByAggregateInput = {
    id?: SortOrder
    simId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type SimMovementLogMinOrderByAggregateInput = {
    id?: SortOrder
    simId?: SortOrder
    serialNumber?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type TransferOrderItemListRelationFilter = {
    every?: TransferOrderItemWhereInput
    some?: TransferOrderItemWhereInput
    none?: TransferOrderItemWhereInput
  }

  export type TransferOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    waybillNumber?: SortOrder
    branchId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    createdByUserId?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    receivedByName?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    waybillNumber?: SortOrder
    branchId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    createdByUserId?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    receivedByName?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    waybillNumber?: SortOrder
    branchId?: SortOrder
    fromBranchId?: SortOrder
    toBranchId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    driverName?: SortOrder
    driverPhone?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    createdByUserId?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    receivedByName?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferOrderRelationFilter = {
    is?: TransferOrderWhereInput
    isNot?: TransferOrderWhereInput
  }

  export type TransferOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    isReceived?: SortOrder
    receivedAt?: SortOrder
    notes?: SortOrder
  }

  export type TransferOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    isReceived?: SortOrder
    receivedAt?: SortOrder
    notes?: SortOrder
  }

  export type TransferOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    serialNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    isReceived?: SortOrder
    receivedAt?: SortOrder
    notes?: SortOrder
  }

  export type MaintenanceRequestRelationFilter = {
    is?: MaintenanceRequestWhereInput
    isNot?: MaintenanceRequestWhereInput
  }

  export type MaintenanceApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    cost?: SortOrder
    parts?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
  }

  export type MaintenanceApprovalAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type MaintenanceApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    cost?: SortOrder
    parts?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
  }

  export type MaintenanceApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    cost?: SortOrder
    parts?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
  }

  export type MaintenanceApprovalSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type RepairVoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    parts?: SortOrder
    totalCost?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RepairVoucherAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type RepairVoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    parts?: SortOrder
    totalCost?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RepairVoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    parts?: SortOrder
    totalCost?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RepairVoucherSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    link?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    link?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    link?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type WarehouseMachineRelationFilter = {
    is?: WarehouseMachineWhereInput
    isNot?: WarehouseMachineWhereInput
  }

  export type ServiceAssignmentLogListRelationFilter = {
    every?: ServiceAssignmentLogWhereInput
    some?: ServiceAssignmentLogWhereInput
    none?: ServiceAssignmentLogWhereInput
  }

  export type ServiceAssignmentLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    technicianId?: SortOrder
    technicianName?: SortOrder
    status?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    usedParts?: SortOrder
    totalCost?: SortOrder
    needsApproval?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    actionTaken?: SortOrder
    resolution?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    branchId?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
  }

  export type ServiceAssignmentAvgOrderByAggregateInput = {
    proposedTotal?: SortOrder
    totalCost?: SortOrder
  }

  export type ServiceAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    technicianId?: SortOrder
    technicianName?: SortOrder
    status?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    usedParts?: SortOrder
    totalCost?: SortOrder
    needsApproval?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    actionTaken?: SortOrder
    resolution?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    branchId?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
  }

  export type ServiceAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    serialNumber?: SortOrder
    technicianId?: SortOrder
    technicianName?: SortOrder
    status?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    usedParts?: SortOrder
    totalCost?: SortOrder
    needsApproval?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    actionTaken?: SortOrder
    resolution?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    requestId?: SortOrder
    branchId?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
  }

  export type ServiceAssignmentSumOrderByAggregateInput = {
    proposedTotal?: SortOrder
    totalCost?: SortOrder
  }

  export type ServiceAssignmentRelationFilter = {
    is?: ServiceAssignmentWhereInput
    isNot?: ServiceAssignmentWhereInput
  }

  export type ServiceAssignmentLogCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
  }

  export type ServiceAssignmentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
  }

  export type ServiceAssignmentLogMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performedBy?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
  }

  export type BranchDebtCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    partsDetails?: SortOrder
    status?: SortOrder
    creditorBranchId?: SortOrder
    debtorBranchId?: SortOrder
    receiptNumber?: SortOrder
    paymentPlace?: SortOrder
    paidAt?: SortOrder
    paidBy?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchDebtAvgOrderByAggregateInput = {
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type BranchDebtMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    partsDetails?: SortOrder
    status?: SortOrder
    creditorBranchId?: SortOrder
    debtorBranchId?: SortOrder
    receiptNumber?: SortOrder
    paymentPlace?: SortOrder
    paidAt?: SortOrder
    paidBy?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchDebtMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    partsDetails?: SortOrder
    status?: SortOrder
    creditorBranchId?: SortOrder
    debtorBranchId?: SortOrder
    receiptNumber?: SortOrder
    paymentPlace?: SortOrder
    paidAt?: SortOrder
    paidBy?: SortOrder
    paidByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchDebtSumOrderByAggregateInput = {
    amount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type MaintenanceApprovalRequestCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    respondedBy?: SortOrder
    respondedById?: SortOrder
    respondedAt?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceApprovalRequestAvgOrderByAggregateInput = {
    proposedTotal?: SortOrder
  }

  export type MaintenanceApprovalRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    respondedBy?: SortOrder
    respondedById?: SortOrder
    respondedAt?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceApprovalRequestMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    machineSerial?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    proposedParts?: SortOrder
    proposedTotal?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    respondedBy?: SortOrder
    respondedById?: SortOrder
    respondedAt?: SortOrder
    centerBranchId?: SortOrder
    originBranchId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceApprovalRequestSumOrderByAggregateInput = {
    proposedTotal?: SortOrder
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchCreateNestedOneWithoutServicedBranchesInput = {
    create?: XOR<BranchCreateWithoutServicedBranchesInput, BranchUncheckedCreateWithoutServicedBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServicedBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedManyWithoutMaintenanceCenterInput = {
    create?: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput> | BranchCreateWithoutMaintenanceCenterInput[] | BranchUncheckedCreateWithoutMaintenanceCenterInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutMaintenanceCenterInput | BranchCreateOrConnectWithoutMaintenanceCenterInput[]
    createMany?: BranchCreateManyMaintenanceCenterInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BranchCreateNestedOneWithoutChildBranchesInput = {
    create?: XOR<BranchCreateWithoutChildBranchesInput, BranchUncheckedCreateWithoutChildBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutChildBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedManyWithoutParentBranchInput = {
    create?: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput> | BranchCreateWithoutParentBranchInput[] | BranchUncheckedCreateWithoutParentBranchInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutParentBranchInput | BranchCreateOrConnectWithoutParentBranchInput[]
    createMany?: BranchCreateManyParentBranchInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutBranchInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    createMany?: CustomerCreateManyBranchInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InstallmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput> | InstallmentCreateWithoutBranchInput[] | InstallmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutBranchInput | InstallmentCreateOrConnectWithoutBranchInput[]
    createMany?: InstallmentCreateManyBranchInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutBranchInput = {
    create?: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput> | InventoryItemCreateWithoutBranchInput[] | InventoryItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBranchInput | InventoryItemCreateOrConnectWithoutBranchInput[]
    createMany?: InventoryItemCreateManyBranchInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type MachineMovementLogCreateNestedManyWithoutBranchInput = {
    create?: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput> | MachineMovementLogCreateWithoutBranchInput[] | MachineMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineMovementLogCreateOrConnectWithoutBranchInput | MachineMovementLogCreateOrConnectWithoutBranchInput[]
    createMany?: MachineMovementLogCreateManyBranchInputEnvelope
    connect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
  }

  export type MachineSaleCreateNestedManyWithoutBranchInput = {
    create?: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput> | MachineSaleCreateWithoutBranchInput[] | MachineSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutBranchInput | MachineSaleCreateOrConnectWithoutBranchInput[]
    createMany?: MachineSaleCreateManyBranchInputEnvelope
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
  }

  export type MaintenanceApprovalCreateNestedManyWithoutBranchInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput> | MaintenanceApprovalCreateWithoutBranchInput[] | MaintenanceApprovalUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutBranchInput | MaintenanceApprovalCreateOrConnectWithoutBranchInput[]
    createMany?: MaintenanceApprovalCreateManyBranchInputEnvelope
    connect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutBranchInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput> | MaintenanceRequestCreateWithoutBranchInput[] | MaintenanceRequestUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBranchInput | MaintenanceRequestCreateOrConnectWithoutBranchInput[]
    createMany?: MaintenanceRequestCreateManyBranchInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutBranchInput = {
    create?: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput> | NotificationCreateWithoutBranchInput[] | NotificationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBranchInput | NotificationCreateOrConnectWithoutBranchInput[]
    createMany?: NotificationCreateManyBranchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutBranchInput = {
    create?: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput> | PaymentCreateWithoutBranchInput[] | PaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBranchInput | PaymentCreateOrConnectWithoutBranchInput[]
    createMany?: PaymentCreateManyBranchInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PosMachineCreateNestedManyWithoutBranchInput = {
    create?: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput> | PosMachineCreateWithoutBranchInput[] | PosMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutBranchInput | PosMachineCreateOrConnectWithoutBranchInput[]
    createMany?: PosMachineCreateManyBranchInputEnvelope
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
  }

  export type RepairVoucherCreateNestedManyWithoutBranchInput = {
    create?: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput> | RepairVoucherCreateWithoutBranchInput[] | RepairVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutBranchInput | RepairVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: RepairVoucherCreateManyBranchInputEnvelope
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
  }

  export type SimCardCreateNestedManyWithoutBranchInput = {
    create?: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput> | SimCardCreateWithoutBranchInput[] | SimCardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutBranchInput | SimCardCreateOrConnectWithoutBranchInput[]
    createMany?: SimCardCreateManyBranchInputEnvelope
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
  }

  export type SimMovementLogCreateNestedManyWithoutBranchInput = {
    create?: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput> | SimMovementLogCreateWithoutBranchInput[] | SimMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimMovementLogCreateOrConnectWithoutBranchInput | SimMovementLogCreateOrConnectWithoutBranchInput[]
    createMany?: SimMovementLogCreateManyBranchInputEnvelope
    connect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutBranchInput = {
    create?: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput> | StockMovementCreateWithoutBranchInput[] | StockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutBranchInput | StockMovementCreateOrConnectWithoutBranchInput[]
    createMany?: StockMovementCreateManyBranchInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SystemLogCreateNestedManyWithoutBranchInput = {
    create?: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput> | SystemLogCreateWithoutBranchInput[] | SystemLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutBranchInput | SystemLogCreateOrConnectWithoutBranchInput[]
    createMany?: SystemLogCreateManyBranchInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type TransferOrderCreateNestedManyWithoutToBranchInput = {
    create?: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput> | TransferOrderCreateWithoutToBranchInput[] | TransferOrderUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToBranchInput | TransferOrderCreateOrConnectWithoutToBranchInput[]
    createMany?: TransferOrderCreateManyToBranchInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type TransferOrderCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput> | TransferOrderCreateWithoutFromBranchInput[] | TransferOrderUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromBranchInput | TransferOrderCreateOrConnectWithoutFromBranchInput[]
    createMany?: TransferOrderCreateManyFromBranchInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type UsedPartLogCreateNestedManyWithoutBranchInput = {
    create?: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput> | UsedPartLogCreateWithoutBranchInput[] | UsedPartLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UsedPartLogCreateOrConnectWithoutBranchInput | UsedPartLogCreateOrConnectWithoutBranchInput[]
    createMany?: UsedPartLogCreateManyBranchInputEnvelope
    connect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WarehouseMachineCreateNestedManyWithoutBranchInput = {
    create?: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput> | WarehouseMachineCreateWithoutBranchInput[] | WarehouseMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutBranchInput | WarehouseMachineCreateOrConnectWithoutBranchInput[]
    createMany?: WarehouseMachineCreateManyBranchInputEnvelope
    connect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
  }

  export type WarehouseSimCreateNestedManyWithoutBranchInput = {
    create?: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput> | WarehouseSimCreateWithoutBranchInput[] | WarehouseSimUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseSimCreateOrConnectWithoutBranchInput | WarehouseSimCreateOrConnectWithoutBranchInput[]
    createMany?: WarehouseSimCreateManyBranchInputEnvelope
    connect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput = {
    create?: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput> | BranchCreateWithoutMaintenanceCenterInput[] | BranchUncheckedCreateWithoutMaintenanceCenterInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutMaintenanceCenterInput | BranchCreateOrConnectWithoutMaintenanceCenterInput[]
    createMany?: BranchCreateManyMaintenanceCenterInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutParentBranchInput = {
    create?: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput> | BranchCreateWithoutParentBranchInput[] | BranchUncheckedCreateWithoutParentBranchInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutParentBranchInput | BranchCreateOrConnectWithoutParentBranchInput[]
    createMany?: BranchCreateManyParentBranchInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    createMany?: CustomerCreateManyBranchInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InstallmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput> | InstallmentCreateWithoutBranchInput[] | InstallmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutBranchInput | InstallmentCreateOrConnectWithoutBranchInput[]
    createMany?: InstallmentCreateManyBranchInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput> | InventoryItemCreateWithoutBranchInput[] | InventoryItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBranchInput | InventoryItemCreateOrConnectWithoutBranchInput[]
    createMany?: InventoryItemCreateManyBranchInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput> | MachineMovementLogCreateWithoutBranchInput[] | MachineMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineMovementLogCreateOrConnectWithoutBranchInput | MachineMovementLogCreateOrConnectWithoutBranchInput[]
    createMany?: MachineMovementLogCreateManyBranchInputEnvelope
    connect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
  }

  export type MachineSaleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput> | MachineSaleCreateWithoutBranchInput[] | MachineSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutBranchInput | MachineSaleCreateOrConnectWithoutBranchInput[]
    createMany?: MachineSaleCreateManyBranchInputEnvelope
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
  }

  export type MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput> | MaintenanceApprovalCreateWithoutBranchInput[] | MaintenanceApprovalUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutBranchInput | MaintenanceApprovalCreateOrConnectWithoutBranchInput[]
    createMany?: MaintenanceApprovalCreateManyBranchInputEnvelope
    connect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput> | MaintenanceRequestCreateWithoutBranchInput[] | MaintenanceRequestUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBranchInput | MaintenanceRequestCreateOrConnectWithoutBranchInput[]
    createMany?: MaintenanceRequestCreateManyBranchInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput> | NotificationCreateWithoutBranchInput[] | NotificationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBranchInput | NotificationCreateOrConnectWithoutBranchInput[]
    createMany?: NotificationCreateManyBranchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput> | PaymentCreateWithoutBranchInput[] | PaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBranchInput | PaymentCreateOrConnectWithoutBranchInput[]
    createMany?: PaymentCreateManyBranchInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PosMachineUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput> | PosMachineCreateWithoutBranchInput[] | PosMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutBranchInput | PosMachineCreateOrConnectWithoutBranchInput[]
    createMany?: PosMachineCreateManyBranchInputEnvelope
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
  }

  export type RepairVoucherUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput> | RepairVoucherCreateWithoutBranchInput[] | RepairVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutBranchInput | RepairVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: RepairVoucherCreateManyBranchInputEnvelope
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
  }

  export type SimCardUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput> | SimCardCreateWithoutBranchInput[] | SimCardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutBranchInput | SimCardCreateOrConnectWithoutBranchInput[]
    createMany?: SimCardCreateManyBranchInputEnvelope
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
  }

  export type SimMovementLogUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput> | SimMovementLogCreateWithoutBranchInput[] | SimMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimMovementLogCreateOrConnectWithoutBranchInput | SimMovementLogCreateOrConnectWithoutBranchInput[]
    createMany?: SimMovementLogCreateManyBranchInputEnvelope
    connect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput> | StockMovementCreateWithoutBranchInput[] | StockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutBranchInput | StockMovementCreateOrConnectWithoutBranchInput[]
    createMany?: StockMovementCreateManyBranchInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SystemLogUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput> | SystemLogCreateWithoutBranchInput[] | SystemLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutBranchInput | SystemLogCreateOrConnectWithoutBranchInput[]
    createMany?: SystemLogCreateManyBranchInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type TransferOrderUncheckedCreateNestedManyWithoutToBranchInput = {
    create?: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput> | TransferOrderCreateWithoutToBranchInput[] | TransferOrderUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToBranchInput | TransferOrderCreateOrConnectWithoutToBranchInput[]
    createMany?: TransferOrderCreateManyToBranchInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput = {
    create?: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput> | TransferOrderCreateWithoutFromBranchInput[] | TransferOrderUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromBranchInput | TransferOrderCreateOrConnectWithoutFromBranchInput[]
    createMany?: TransferOrderCreateManyFromBranchInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type UsedPartLogUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput> | UsedPartLogCreateWithoutBranchInput[] | UsedPartLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UsedPartLogCreateOrConnectWithoutBranchInput | UsedPartLogCreateOrConnectWithoutBranchInput[]
    createMany?: UsedPartLogCreateManyBranchInputEnvelope
    connect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput> | WarehouseMachineCreateWithoutBranchInput[] | WarehouseMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutBranchInput | WarehouseMachineCreateOrConnectWithoutBranchInput[]
    createMany?: WarehouseMachineCreateManyBranchInputEnvelope
    connect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
  }

  export type WarehouseSimUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput> | WarehouseSimCreateWithoutBranchInput[] | WarehouseSimUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseSimCreateOrConnectWithoutBranchInput | WarehouseSimCreateOrConnectWithoutBranchInput[]
    createMany?: WarehouseSimCreateManyBranchInputEnvelope
    connect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutServicedBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutServicedBranchesInput, BranchUncheckedCreateWithoutServicedBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServicedBranchesInput
    upsert?: BranchUpsertWithoutServicedBranchesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServicedBranchesInput, BranchUpdateWithoutServicedBranchesInput>, BranchUncheckedUpdateWithoutServicedBranchesInput>
  }

  export type BranchUpdateManyWithoutMaintenanceCenterNestedInput = {
    create?: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput> | BranchCreateWithoutMaintenanceCenterInput[] | BranchUncheckedCreateWithoutMaintenanceCenterInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutMaintenanceCenterInput | BranchCreateOrConnectWithoutMaintenanceCenterInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutMaintenanceCenterInput | BranchUpsertWithWhereUniqueWithoutMaintenanceCenterInput[]
    createMany?: BranchCreateManyMaintenanceCenterInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutMaintenanceCenterInput | BranchUpdateWithWhereUniqueWithoutMaintenanceCenterInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutMaintenanceCenterInput | BranchUpdateManyWithWhereWithoutMaintenanceCenterInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BranchUpdateOneWithoutChildBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutChildBranchesInput, BranchUncheckedCreateWithoutChildBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutChildBranchesInput
    upsert?: BranchUpsertWithoutChildBranchesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutChildBranchesInput, BranchUpdateWithoutChildBranchesInput>, BranchUncheckedUpdateWithoutChildBranchesInput>
  }

  export type BranchUpdateManyWithoutParentBranchNestedInput = {
    create?: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput> | BranchCreateWithoutParentBranchInput[] | BranchUncheckedCreateWithoutParentBranchInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutParentBranchInput | BranchCreateOrConnectWithoutParentBranchInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutParentBranchInput | BranchUpsertWithWhereUniqueWithoutParentBranchInput[]
    createMany?: BranchCreateManyParentBranchInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutParentBranchInput | BranchUpdateWithWhereUniqueWithoutParentBranchInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutParentBranchInput | BranchUpdateManyWithWhereWithoutParentBranchInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutBranchInput | CustomerUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CustomerCreateManyBranchInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutBranchInput | CustomerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutBranchInput | CustomerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InstallmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput> | InstallmentCreateWithoutBranchInput[] | InstallmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutBranchInput | InstallmentCreateOrConnectWithoutBranchInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutBranchInput | InstallmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InstallmentCreateManyBranchInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutBranchInput | InstallmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutBranchInput | InstallmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput> | InventoryItemCreateWithoutBranchInput[] | InventoryItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBranchInput | InventoryItemCreateOrConnectWithoutBranchInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBranchInput | InventoryItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InventoryItemCreateManyBranchInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBranchInput | InventoryItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBranchInput | InventoryItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type MachineMovementLogUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput> | MachineMovementLogCreateWithoutBranchInput[] | MachineMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineMovementLogCreateOrConnectWithoutBranchInput | MachineMovementLogCreateOrConnectWithoutBranchInput[]
    upsert?: MachineMovementLogUpsertWithWhereUniqueWithoutBranchInput | MachineMovementLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MachineMovementLogCreateManyBranchInputEnvelope
    set?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    disconnect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    delete?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    connect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    update?: MachineMovementLogUpdateWithWhereUniqueWithoutBranchInput | MachineMovementLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MachineMovementLogUpdateManyWithWhereWithoutBranchInput | MachineMovementLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MachineMovementLogScalarWhereInput | MachineMovementLogScalarWhereInput[]
  }

  export type MachineSaleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput> | MachineSaleCreateWithoutBranchInput[] | MachineSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutBranchInput | MachineSaleCreateOrConnectWithoutBranchInput[]
    upsert?: MachineSaleUpsertWithWhereUniqueWithoutBranchInput | MachineSaleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MachineSaleCreateManyBranchInputEnvelope
    set?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    disconnect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    delete?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    update?: MachineSaleUpdateWithWhereUniqueWithoutBranchInput | MachineSaleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MachineSaleUpdateManyWithWhereWithoutBranchInput | MachineSaleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
  }

  export type MaintenanceApprovalUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput> | MaintenanceApprovalCreateWithoutBranchInput[] | MaintenanceApprovalUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutBranchInput | MaintenanceApprovalCreateOrConnectWithoutBranchInput[]
    upsert?: MaintenanceApprovalUpsertWithWhereUniqueWithoutBranchInput | MaintenanceApprovalUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MaintenanceApprovalCreateManyBranchInputEnvelope
    set?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    disconnect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    delete?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    connect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    update?: MaintenanceApprovalUpdateWithWhereUniqueWithoutBranchInput | MaintenanceApprovalUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MaintenanceApprovalUpdateManyWithWhereWithoutBranchInput | MaintenanceApprovalUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MaintenanceApprovalScalarWhereInput | MaintenanceApprovalScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput> | MaintenanceRequestCreateWithoutBranchInput[] | MaintenanceRequestUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBranchInput | MaintenanceRequestCreateOrConnectWithoutBranchInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutBranchInput | MaintenanceRequestUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MaintenanceRequestCreateManyBranchInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutBranchInput | MaintenanceRequestUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutBranchInput | MaintenanceRequestUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput> | NotificationCreateWithoutBranchInput[] | NotificationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBranchInput | NotificationCreateOrConnectWithoutBranchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBranchInput | NotificationUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NotificationCreateManyBranchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBranchInput | NotificationUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBranchInput | NotificationUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput> | PaymentCreateWithoutBranchInput[] | PaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBranchInput | PaymentCreateOrConnectWithoutBranchInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBranchInput | PaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PaymentCreateManyBranchInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBranchInput | PaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBranchInput | PaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PosMachineUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput> | PosMachineCreateWithoutBranchInput[] | PosMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutBranchInput | PosMachineCreateOrConnectWithoutBranchInput[]
    upsert?: PosMachineUpsertWithWhereUniqueWithoutBranchInput | PosMachineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PosMachineCreateManyBranchInputEnvelope
    set?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    disconnect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    delete?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    update?: PosMachineUpdateWithWhereUniqueWithoutBranchInput | PosMachineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PosMachineUpdateManyWithWhereWithoutBranchInput | PosMachineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
  }

  export type RepairVoucherUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput> | RepairVoucherCreateWithoutBranchInput[] | RepairVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutBranchInput | RepairVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: RepairVoucherUpsertWithWhereUniqueWithoutBranchInput | RepairVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RepairVoucherCreateManyBranchInputEnvelope
    set?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    disconnect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    delete?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    update?: RepairVoucherUpdateWithWhereUniqueWithoutBranchInput | RepairVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RepairVoucherUpdateManyWithWhereWithoutBranchInput | RepairVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
  }

  export type SimCardUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput> | SimCardCreateWithoutBranchInput[] | SimCardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutBranchInput | SimCardCreateOrConnectWithoutBranchInput[]
    upsert?: SimCardUpsertWithWhereUniqueWithoutBranchInput | SimCardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SimCardCreateManyBranchInputEnvelope
    set?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    disconnect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    delete?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    update?: SimCardUpdateWithWhereUniqueWithoutBranchInput | SimCardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SimCardUpdateManyWithWhereWithoutBranchInput | SimCardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
  }

  export type SimMovementLogUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput> | SimMovementLogCreateWithoutBranchInput[] | SimMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimMovementLogCreateOrConnectWithoutBranchInput | SimMovementLogCreateOrConnectWithoutBranchInput[]
    upsert?: SimMovementLogUpsertWithWhereUniqueWithoutBranchInput | SimMovementLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SimMovementLogCreateManyBranchInputEnvelope
    set?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    disconnect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    delete?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    connect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    update?: SimMovementLogUpdateWithWhereUniqueWithoutBranchInput | SimMovementLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SimMovementLogUpdateManyWithWhereWithoutBranchInput | SimMovementLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SimMovementLogScalarWhereInput | SimMovementLogScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput> | StockMovementCreateWithoutBranchInput[] | StockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutBranchInput | StockMovementCreateOrConnectWithoutBranchInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutBranchInput | StockMovementUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StockMovementCreateManyBranchInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutBranchInput | StockMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutBranchInput | StockMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SystemLogUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput> | SystemLogCreateWithoutBranchInput[] | SystemLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutBranchInput | SystemLogCreateOrConnectWithoutBranchInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutBranchInput | SystemLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SystemLogCreateManyBranchInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutBranchInput | SystemLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutBranchInput | SystemLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type TransferOrderUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput> | TransferOrderCreateWithoutToBranchInput[] | TransferOrderUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToBranchInput | TransferOrderCreateOrConnectWithoutToBranchInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutToBranchInput | TransferOrderUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: TransferOrderCreateManyToBranchInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutToBranchInput | TransferOrderUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutToBranchInput | TransferOrderUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type TransferOrderUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput> | TransferOrderCreateWithoutFromBranchInput[] | TransferOrderUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromBranchInput | TransferOrderCreateOrConnectWithoutFromBranchInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutFromBranchInput | TransferOrderUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: TransferOrderCreateManyFromBranchInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutFromBranchInput | TransferOrderUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutFromBranchInput | TransferOrderUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type UsedPartLogUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput> | UsedPartLogCreateWithoutBranchInput[] | UsedPartLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UsedPartLogCreateOrConnectWithoutBranchInput | UsedPartLogCreateOrConnectWithoutBranchInput[]
    upsert?: UsedPartLogUpsertWithWhereUniqueWithoutBranchInput | UsedPartLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UsedPartLogCreateManyBranchInputEnvelope
    set?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    disconnect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    delete?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    connect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    update?: UsedPartLogUpdateWithWhereUniqueWithoutBranchInput | UsedPartLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UsedPartLogUpdateManyWithWhereWithoutBranchInput | UsedPartLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UsedPartLogScalarWhereInput | UsedPartLogScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WarehouseMachineUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput> | WarehouseMachineCreateWithoutBranchInput[] | WarehouseMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutBranchInput | WarehouseMachineCreateOrConnectWithoutBranchInput[]
    upsert?: WarehouseMachineUpsertWithWhereUniqueWithoutBranchInput | WarehouseMachineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WarehouseMachineCreateManyBranchInputEnvelope
    set?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    disconnect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    delete?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    connect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    update?: WarehouseMachineUpdateWithWhereUniqueWithoutBranchInput | WarehouseMachineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WarehouseMachineUpdateManyWithWhereWithoutBranchInput | WarehouseMachineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WarehouseMachineScalarWhereInput | WarehouseMachineScalarWhereInput[]
  }

  export type WarehouseSimUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput> | WarehouseSimCreateWithoutBranchInput[] | WarehouseSimUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseSimCreateOrConnectWithoutBranchInput | WarehouseSimCreateOrConnectWithoutBranchInput[]
    upsert?: WarehouseSimUpsertWithWhereUniqueWithoutBranchInput | WarehouseSimUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WarehouseSimCreateManyBranchInputEnvelope
    set?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    disconnect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    delete?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    connect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    update?: WarehouseSimUpdateWithWhereUniqueWithoutBranchInput | WarehouseSimUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WarehouseSimUpdateManyWithWhereWithoutBranchInput | WarehouseSimUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WarehouseSimScalarWhereInput | WarehouseSimScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput = {
    create?: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput> | BranchCreateWithoutMaintenanceCenterInput[] | BranchUncheckedCreateWithoutMaintenanceCenterInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutMaintenanceCenterInput | BranchCreateOrConnectWithoutMaintenanceCenterInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutMaintenanceCenterInput | BranchUpsertWithWhereUniqueWithoutMaintenanceCenterInput[]
    createMany?: BranchCreateManyMaintenanceCenterInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutMaintenanceCenterInput | BranchUpdateWithWhereUniqueWithoutMaintenanceCenterInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutMaintenanceCenterInput | BranchUpdateManyWithWhereWithoutMaintenanceCenterInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutParentBranchNestedInput = {
    create?: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput> | BranchCreateWithoutParentBranchInput[] | BranchUncheckedCreateWithoutParentBranchInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutParentBranchInput | BranchCreateOrConnectWithoutParentBranchInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutParentBranchInput | BranchUpsertWithWhereUniqueWithoutParentBranchInput[]
    createMany?: BranchCreateManyParentBranchInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutParentBranchInput | BranchUpdateWithWhereUniqueWithoutParentBranchInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutParentBranchInput | BranchUpdateManyWithWhereWithoutParentBranchInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutBranchInput | CustomerUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: CustomerCreateManyBranchInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutBranchInput | CustomerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutBranchInput | CustomerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InstallmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput> | InstallmentCreateWithoutBranchInput[] | InstallmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutBranchInput | InstallmentCreateOrConnectWithoutBranchInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutBranchInput | InstallmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InstallmentCreateManyBranchInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutBranchInput | InstallmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutBranchInput | InstallmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput> | InventoryItemCreateWithoutBranchInput[] | InventoryItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBranchInput | InventoryItemCreateOrConnectWithoutBranchInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBranchInput | InventoryItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InventoryItemCreateManyBranchInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBranchInput | InventoryItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBranchInput | InventoryItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput> | MachineMovementLogCreateWithoutBranchInput[] | MachineMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineMovementLogCreateOrConnectWithoutBranchInput | MachineMovementLogCreateOrConnectWithoutBranchInput[]
    upsert?: MachineMovementLogUpsertWithWhereUniqueWithoutBranchInput | MachineMovementLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MachineMovementLogCreateManyBranchInputEnvelope
    set?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    disconnect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    delete?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    connect?: MachineMovementLogWhereUniqueInput | MachineMovementLogWhereUniqueInput[]
    update?: MachineMovementLogUpdateWithWhereUniqueWithoutBranchInput | MachineMovementLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MachineMovementLogUpdateManyWithWhereWithoutBranchInput | MachineMovementLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MachineMovementLogScalarWhereInput | MachineMovementLogScalarWhereInput[]
  }

  export type MachineSaleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput> | MachineSaleCreateWithoutBranchInput[] | MachineSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutBranchInput | MachineSaleCreateOrConnectWithoutBranchInput[]
    upsert?: MachineSaleUpsertWithWhereUniqueWithoutBranchInput | MachineSaleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MachineSaleCreateManyBranchInputEnvelope
    set?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    disconnect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    delete?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    update?: MachineSaleUpdateWithWhereUniqueWithoutBranchInput | MachineSaleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MachineSaleUpdateManyWithWhereWithoutBranchInput | MachineSaleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
  }

  export type MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput> | MaintenanceApprovalCreateWithoutBranchInput[] | MaintenanceApprovalUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutBranchInput | MaintenanceApprovalCreateOrConnectWithoutBranchInput[]
    upsert?: MaintenanceApprovalUpsertWithWhereUniqueWithoutBranchInput | MaintenanceApprovalUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MaintenanceApprovalCreateManyBranchInputEnvelope
    set?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    disconnect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    delete?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    connect?: MaintenanceApprovalWhereUniqueInput | MaintenanceApprovalWhereUniqueInput[]
    update?: MaintenanceApprovalUpdateWithWhereUniqueWithoutBranchInput | MaintenanceApprovalUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MaintenanceApprovalUpdateManyWithWhereWithoutBranchInput | MaintenanceApprovalUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MaintenanceApprovalScalarWhereInput | MaintenanceApprovalScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput> | MaintenanceRequestCreateWithoutBranchInput[] | MaintenanceRequestUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBranchInput | MaintenanceRequestCreateOrConnectWithoutBranchInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutBranchInput | MaintenanceRequestUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MaintenanceRequestCreateManyBranchInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutBranchInput | MaintenanceRequestUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutBranchInput | MaintenanceRequestUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput> | NotificationCreateWithoutBranchInput[] | NotificationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBranchInput | NotificationCreateOrConnectWithoutBranchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBranchInput | NotificationUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NotificationCreateManyBranchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBranchInput | NotificationUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBranchInput | NotificationUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput> | PaymentCreateWithoutBranchInput[] | PaymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBranchInput | PaymentCreateOrConnectWithoutBranchInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBranchInput | PaymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PaymentCreateManyBranchInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBranchInput | PaymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBranchInput | PaymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PosMachineUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput> | PosMachineCreateWithoutBranchInput[] | PosMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutBranchInput | PosMachineCreateOrConnectWithoutBranchInput[]
    upsert?: PosMachineUpsertWithWhereUniqueWithoutBranchInput | PosMachineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PosMachineCreateManyBranchInputEnvelope
    set?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    disconnect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    delete?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    update?: PosMachineUpdateWithWhereUniqueWithoutBranchInput | PosMachineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PosMachineUpdateManyWithWhereWithoutBranchInput | PosMachineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
  }

  export type RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput> | RepairVoucherCreateWithoutBranchInput[] | RepairVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutBranchInput | RepairVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: RepairVoucherUpsertWithWhereUniqueWithoutBranchInput | RepairVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RepairVoucherCreateManyBranchInputEnvelope
    set?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    disconnect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    delete?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    update?: RepairVoucherUpdateWithWhereUniqueWithoutBranchInput | RepairVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RepairVoucherUpdateManyWithWhereWithoutBranchInput | RepairVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
  }

  export type SimCardUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput> | SimCardCreateWithoutBranchInput[] | SimCardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutBranchInput | SimCardCreateOrConnectWithoutBranchInput[]
    upsert?: SimCardUpsertWithWhereUniqueWithoutBranchInput | SimCardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SimCardCreateManyBranchInputEnvelope
    set?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    disconnect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    delete?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    update?: SimCardUpdateWithWhereUniqueWithoutBranchInput | SimCardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SimCardUpdateManyWithWhereWithoutBranchInput | SimCardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
  }

  export type SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput> | SimMovementLogCreateWithoutBranchInput[] | SimMovementLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SimMovementLogCreateOrConnectWithoutBranchInput | SimMovementLogCreateOrConnectWithoutBranchInput[]
    upsert?: SimMovementLogUpsertWithWhereUniqueWithoutBranchInput | SimMovementLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SimMovementLogCreateManyBranchInputEnvelope
    set?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    disconnect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    delete?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    connect?: SimMovementLogWhereUniqueInput | SimMovementLogWhereUniqueInput[]
    update?: SimMovementLogUpdateWithWhereUniqueWithoutBranchInput | SimMovementLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SimMovementLogUpdateManyWithWhereWithoutBranchInput | SimMovementLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SimMovementLogScalarWhereInput | SimMovementLogScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput> | StockMovementCreateWithoutBranchInput[] | StockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutBranchInput | StockMovementCreateOrConnectWithoutBranchInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutBranchInput | StockMovementUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StockMovementCreateManyBranchInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutBranchInput | StockMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutBranchInput | StockMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SystemLogUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput> | SystemLogCreateWithoutBranchInput[] | SystemLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutBranchInput | SystemLogCreateOrConnectWithoutBranchInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutBranchInput | SystemLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SystemLogCreateManyBranchInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutBranchInput | SystemLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutBranchInput | SystemLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput = {
    create?: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput> | TransferOrderCreateWithoutToBranchInput[] | TransferOrderUncheckedCreateWithoutToBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToBranchInput | TransferOrderCreateOrConnectWithoutToBranchInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutToBranchInput | TransferOrderUpsertWithWhereUniqueWithoutToBranchInput[]
    createMany?: TransferOrderCreateManyToBranchInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutToBranchInput | TransferOrderUpdateWithWhereUniqueWithoutToBranchInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutToBranchInput | TransferOrderUpdateManyWithWhereWithoutToBranchInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput = {
    create?: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput> | TransferOrderCreateWithoutFromBranchInput[] | TransferOrderUncheckedCreateWithoutFromBranchInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromBranchInput | TransferOrderCreateOrConnectWithoutFromBranchInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutFromBranchInput | TransferOrderUpsertWithWhereUniqueWithoutFromBranchInput[]
    createMany?: TransferOrderCreateManyFromBranchInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutFromBranchInput | TransferOrderUpdateWithWhereUniqueWithoutFromBranchInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutFromBranchInput | TransferOrderUpdateManyWithWhereWithoutFromBranchInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput> | UsedPartLogCreateWithoutBranchInput[] | UsedPartLogUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UsedPartLogCreateOrConnectWithoutBranchInput | UsedPartLogCreateOrConnectWithoutBranchInput[]
    upsert?: UsedPartLogUpsertWithWhereUniqueWithoutBranchInput | UsedPartLogUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UsedPartLogCreateManyBranchInputEnvelope
    set?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    disconnect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    delete?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    connect?: UsedPartLogWhereUniqueInput | UsedPartLogWhereUniqueInput[]
    update?: UsedPartLogUpdateWithWhereUniqueWithoutBranchInput | UsedPartLogUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UsedPartLogUpdateManyWithWhereWithoutBranchInput | UsedPartLogUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UsedPartLogScalarWhereInput | UsedPartLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput> | WarehouseMachineCreateWithoutBranchInput[] | WarehouseMachineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutBranchInput | WarehouseMachineCreateOrConnectWithoutBranchInput[]
    upsert?: WarehouseMachineUpsertWithWhereUniqueWithoutBranchInput | WarehouseMachineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WarehouseMachineCreateManyBranchInputEnvelope
    set?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    disconnect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    delete?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    connect?: WarehouseMachineWhereUniqueInput | WarehouseMachineWhereUniqueInput[]
    update?: WarehouseMachineUpdateWithWhereUniqueWithoutBranchInput | WarehouseMachineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WarehouseMachineUpdateManyWithWhereWithoutBranchInput | WarehouseMachineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WarehouseMachineScalarWhereInput | WarehouseMachineScalarWhereInput[]
  }

  export type WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput> | WarehouseSimCreateWithoutBranchInput[] | WarehouseSimUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WarehouseSimCreateOrConnectWithoutBranchInput | WarehouseSimCreateOrConnectWithoutBranchInput[]
    upsert?: WarehouseSimUpsertWithWhereUniqueWithoutBranchInput | WarehouseSimUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WarehouseSimCreateManyBranchInputEnvelope
    set?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    disconnect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    delete?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    connect?: WarehouseSimWhereUniqueInput | WarehouseSimWhereUniqueInput[]
    update?: WarehouseSimUpdateWithWhereUniqueWithoutBranchInput | WarehouseSimUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WarehouseSimUpdateManyWithWhereWithoutBranchInput | WarehouseSimUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WarehouseSimScalarWhereInput | WarehouseSimScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutCustomersInput = {
    create?: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCustomersInput
    connect?: BranchWhereUniqueInput
  }

  export type MachineSaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput> | MachineSaleCreateWithoutCustomerInput[] | MachineSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutCustomerInput | MachineSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: MachineSaleCreateManyCustomerInputEnvelope
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutCustomerInput = {
    create?: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput> | MaintenanceRequestCreateWithoutCustomerInput[] | MaintenanceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutCustomerInput | MaintenanceRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: MaintenanceRequestCreateManyCustomerInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PosMachineCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput> | PosMachineCreateWithoutCustomerInput[] | PosMachineUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutCustomerInput | PosMachineCreateOrConnectWithoutCustomerInput[]
    createMany?: PosMachineCreateManyCustomerInputEnvelope
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
  }

  export type SimCardCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput> | SimCardCreateWithoutCustomerInput[] | SimCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutCustomerInput | SimCardCreateOrConnectWithoutCustomerInput[]
    createMany?: SimCardCreateManyCustomerInputEnvelope
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
  }

  export type MachineSaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput> | MachineSaleCreateWithoutCustomerInput[] | MachineSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutCustomerInput | MachineSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: MachineSaleCreateManyCustomerInputEnvelope
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput> | MaintenanceRequestCreateWithoutCustomerInput[] | MaintenanceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutCustomerInput | MaintenanceRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: MaintenanceRequestCreateManyCustomerInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PosMachineUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput> | PosMachineCreateWithoutCustomerInput[] | PosMachineUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutCustomerInput | PosMachineCreateOrConnectWithoutCustomerInput[]
    createMany?: PosMachineCreateManyCustomerInputEnvelope
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
  }

  export type SimCardUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput> | SimCardCreateWithoutCustomerInput[] | SimCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutCustomerInput | SimCardCreateOrConnectWithoutCustomerInput[]
    createMany?: SimCardCreateManyCustomerInputEnvelope
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BranchUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCustomersInput
    upsert?: BranchUpsertWithoutCustomersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCustomersInput, BranchUpdateWithoutCustomersInput>, BranchUncheckedUpdateWithoutCustomersInput>
  }

  export type MachineSaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput> | MachineSaleCreateWithoutCustomerInput[] | MachineSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutCustomerInput | MachineSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: MachineSaleUpsertWithWhereUniqueWithoutCustomerInput | MachineSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: MachineSaleCreateManyCustomerInputEnvelope
    set?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    disconnect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    delete?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    update?: MachineSaleUpdateWithWhereUniqueWithoutCustomerInput | MachineSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: MachineSaleUpdateManyWithWhereWithoutCustomerInput | MachineSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput> | MaintenanceRequestCreateWithoutCustomerInput[] | MaintenanceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutCustomerInput | MaintenanceRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutCustomerInput | MaintenanceRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: MaintenanceRequestCreateManyCustomerInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutCustomerInput | MaintenanceRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutCustomerInput | MaintenanceRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PosMachineUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput> | PosMachineCreateWithoutCustomerInput[] | PosMachineUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutCustomerInput | PosMachineCreateOrConnectWithoutCustomerInput[]
    upsert?: PosMachineUpsertWithWhereUniqueWithoutCustomerInput | PosMachineUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PosMachineCreateManyCustomerInputEnvelope
    set?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    disconnect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    delete?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    update?: PosMachineUpdateWithWhereUniqueWithoutCustomerInput | PosMachineUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PosMachineUpdateManyWithWhereWithoutCustomerInput | PosMachineUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
  }

  export type SimCardUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput> | SimCardCreateWithoutCustomerInput[] | SimCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutCustomerInput | SimCardCreateOrConnectWithoutCustomerInput[]
    upsert?: SimCardUpsertWithWhereUniqueWithoutCustomerInput | SimCardUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SimCardCreateManyCustomerInputEnvelope
    set?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    disconnect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    delete?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    update?: SimCardUpdateWithWhereUniqueWithoutCustomerInput | SimCardUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SimCardUpdateManyWithWhereWithoutCustomerInput | SimCardUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
  }

  export type MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput> | MachineSaleCreateWithoutCustomerInput[] | MachineSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MachineSaleCreateOrConnectWithoutCustomerInput | MachineSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: MachineSaleUpsertWithWhereUniqueWithoutCustomerInput | MachineSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: MachineSaleCreateManyCustomerInputEnvelope
    set?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    disconnect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    delete?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    connect?: MachineSaleWhereUniqueInput | MachineSaleWhereUniqueInput[]
    update?: MachineSaleUpdateWithWhereUniqueWithoutCustomerInput | MachineSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: MachineSaleUpdateManyWithWhereWithoutCustomerInput | MachineSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput> | MaintenanceRequestCreateWithoutCustomerInput[] | MaintenanceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutCustomerInput | MaintenanceRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutCustomerInput | MaintenanceRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: MaintenanceRequestCreateManyCustomerInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutCustomerInput | MaintenanceRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutCustomerInput | MaintenanceRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PosMachineUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput> | PosMachineCreateWithoutCustomerInput[] | PosMachineUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosMachineCreateOrConnectWithoutCustomerInput | PosMachineCreateOrConnectWithoutCustomerInput[]
    upsert?: PosMachineUpsertWithWhereUniqueWithoutCustomerInput | PosMachineUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PosMachineCreateManyCustomerInputEnvelope
    set?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    disconnect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    delete?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    connect?: PosMachineWhereUniqueInput | PosMachineWhereUniqueInput[]
    update?: PosMachineUpdateWithWhereUniqueWithoutCustomerInput | PosMachineUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PosMachineUpdateManyWithWhereWithoutCustomerInput | PosMachineUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
  }

  export type SimCardUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput> | SimCardCreateWithoutCustomerInput[] | SimCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SimCardCreateOrConnectWithoutCustomerInput | SimCardCreateOrConnectWithoutCustomerInput[]
    upsert?: SimCardUpsertWithWhereUniqueWithoutCustomerInput | SimCardUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SimCardCreateManyCustomerInputEnvelope
    set?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    disconnect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    delete?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    connect?: SimCardWhereUniqueInput | SimCardWhereUniqueInput[]
    update?: SimCardUpdateWithWhereUniqueWithoutCustomerInput | SimCardUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SimCardUpdateManyWithWhereWithoutCustomerInput | SimCardUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutPartInput = {
    create?: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput> | InventoryItemCreateWithoutPartInput[] | InventoryItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPartInput | InventoryItemCreateOrConnectWithoutPartInput[]
    createMany?: InventoryItemCreateManyPartInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput> | InventoryItemCreateWithoutPartInput[] | InventoryItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPartInput | InventoryItemCreateOrConnectWithoutPartInput[]
    createMany?: InventoryItemCreateManyPartInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput> | InventoryItemCreateWithoutPartInput[] | InventoryItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPartInput | InventoryItemCreateOrConnectWithoutPartInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutPartInput | InventoryItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: InventoryItemCreateManyPartInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutPartInput | InventoryItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutPartInput | InventoryItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput> | InventoryItemCreateWithoutPartInput[] | InventoryItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPartInput | InventoryItemCreateOrConnectWithoutPartInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutPartInput | InventoryItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: InventoryItemCreateManyPartInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutPartInput | InventoryItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutPartInput | InventoryItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SparePartCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<SparePartCreateWithoutInventoryItemsInput, SparePartUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: SparePartCreateOrConnectWithoutInventoryItemsInput
    connect?: SparePartWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutInventoryInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    connect?: BranchWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SparePartUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<SparePartCreateWithoutInventoryItemsInput, SparePartUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: SparePartCreateOrConnectWithoutInventoryItemsInput
    upsert?: SparePartUpsertWithoutInventoryItemsInput
    connect?: SparePartWhereUniqueInput
    update?: XOR<XOR<SparePartUpdateToOneWithWhereWithoutInventoryItemsInput, SparePartUpdateWithoutInventoryItemsInput>, SparePartUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type BranchUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    upsert?: BranchUpsertWithoutInventoryInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInventoryInput, BranchUpdateWithoutInventoryInput>, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type MaintenanceApprovalCreateNestedOneWithoutRequestInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutRequestInput
    connect?: MaintenanceApprovalWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutRequestsInput = {
    create?: XOR<CustomerCreateWithoutRequestsInput, CustomerUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRequestsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PosMachineCreateNestedOneWithoutRequestsInput = {
    create?: XOR<PosMachineCreateWithoutRequestsInput, PosMachineUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: PosMachineCreateOrConnectWithoutRequestsInput
    connect?: PosMachineWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutRequestsInput = {
    create?: XOR<BranchCreateWithoutRequestsInput, BranchUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRequestsInput
    connect?: BranchWhereUniqueInput
  }

  export type RepairVoucherCreateNestedManyWithoutRequestInput = {
    create?: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput> | RepairVoucherCreateWithoutRequestInput[] | RepairVoucherUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutRequestInput | RepairVoucherCreateOrConnectWithoutRequestInput[]
    createMany?: RepairVoucherCreateManyRequestInputEnvelope
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
  }

  export type MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutRequestInput
    connect?: MaintenanceApprovalWhereUniqueInput
  }

  export type RepairVoucherUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput> | RepairVoucherCreateWithoutRequestInput[] | RepairVoucherUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutRequestInput | RepairVoucherCreateOrConnectWithoutRequestInput[]
    createMany?: RepairVoucherCreateManyRequestInputEnvelope
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MaintenanceApprovalUpdateOneWithoutRequestNestedInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutRequestInput
    upsert?: MaintenanceApprovalUpsertWithoutRequestInput
    disconnect?: MaintenanceApprovalWhereInput | boolean
    delete?: MaintenanceApprovalWhereInput | boolean
    connect?: MaintenanceApprovalWhereUniqueInput
    update?: XOR<XOR<MaintenanceApprovalUpdateToOneWithWhereWithoutRequestInput, MaintenanceApprovalUpdateWithoutRequestInput>, MaintenanceApprovalUncheckedUpdateWithoutRequestInput>
  }

  export type CustomerUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<CustomerCreateWithoutRequestsInput, CustomerUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRequestsInput
    upsert?: CustomerUpsertWithoutRequestsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRequestsInput, CustomerUpdateWithoutRequestsInput>, CustomerUncheckedUpdateWithoutRequestsInput>
  }

  export type PosMachineUpdateOneWithoutRequestsNestedInput = {
    create?: XOR<PosMachineCreateWithoutRequestsInput, PosMachineUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: PosMachineCreateOrConnectWithoutRequestsInput
    upsert?: PosMachineUpsertWithoutRequestsInput
    disconnect?: PosMachineWhereInput | boolean
    delete?: PosMachineWhereInput | boolean
    connect?: PosMachineWhereUniqueInput
    update?: XOR<XOR<PosMachineUpdateToOneWithWhereWithoutRequestsInput, PosMachineUpdateWithoutRequestsInput>, PosMachineUncheckedUpdateWithoutRequestsInput>
  }

  export type BranchUpdateOneWithoutRequestsNestedInput = {
    create?: XOR<BranchCreateWithoutRequestsInput, BranchUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRequestsInput
    upsert?: BranchUpsertWithoutRequestsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutRequestsInput, BranchUpdateWithoutRequestsInput>, BranchUncheckedUpdateWithoutRequestsInput>
  }

  export type RepairVoucherUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput> | RepairVoucherCreateWithoutRequestInput[] | RepairVoucherUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutRequestInput | RepairVoucherCreateOrConnectWithoutRequestInput[]
    upsert?: RepairVoucherUpsertWithWhereUniqueWithoutRequestInput | RepairVoucherUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RepairVoucherCreateManyRequestInputEnvelope
    set?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    disconnect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    delete?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    update?: RepairVoucherUpdateWithWhereUniqueWithoutRequestInput | RepairVoucherUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RepairVoucherUpdateManyWithWhereWithoutRequestInput | RepairVoucherUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
  }

  export type MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput = {
    create?: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
    connectOrCreate?: MaintenanceApprovalCreateOrConnectWithoutRequestInput
    upsert?: MaintenanceApprovalUpsertWithoutRequestInput
    disconnect?: MaintenanceApprovalWhereInput | boolean
    delete?: MaintenanceApprovalWhereInput | boolean
    connect?: MaintenanceApprovalWhereUniqueInput
    update?: XOR<XOR<MaintenanceApprovalUpdateToOneWithWhereWithoutRequestInput, MaintenanceApprovalUpdateWithoutRequestInput>, MaintenanceApprovalUncheckedUpdateWithoutRequestInput>
  }

  export type RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput> | RepairVoucherCreateWithoutRequestInput[] | RepairVoucherUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RepairVoucherCreateOrConnectWithoutRequestInput | RepairVoucherCreateOrConnectWithoutRequestInput[]
    upsert?: RepairVoucherUpsertWithWhereUniqueWithoutRequestInput | RepairVoucherUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RepairVoucherCreateManyRequestInputEnvelope
    set?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    disconnect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    delete?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    connect?: RepairVoucherWhereUniqueInput | RepairVoucherWhereUniqueInput[]
    update?: RepairVoucherUpdateWithWhereUniqueWithoutRequestInput | RepairVoucherUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RepairVoucherUpdateManyWithWhereWithoutRequestInput | RepairVoucherUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutUsedPartLogsInput = {
    create?: XOR<BranchCreateWithoutUsedPartLogsInput, BranchUncheckedCreateWithoutUsedPartLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsedPartLogsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutUsedPartLogsNestedInput = {
    create?: XOR<BranchCreateWithoutUsedPartLogsInput, BranchUncheckedCreateWithoutUsedPartLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsedPartLogsInput
    upsert?: BranchUpsertWithoutUsedPartLogsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsedPartLogsInput, BranchUpdateWithoutUsedPartLogsInput>, BranchUncheckedUpdateWithoutUsedPartLogsInput>
  }

  export type BranchCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<BranchCreateWithoutStockMovementsInput, BranchUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStockMovementsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutStockMovementsNestedInput = {
    create?: XOR<BranchCreateWithoutStockMovementsInput, BranchUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStockMovementsInput
    upsert?: BranchUpsertWithoutStockMovementsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStockMovementsInput, BranchUpdateWithoutStockMovementsInput>, BranchUncheckedUpdateWithoutStockMovementsInput>
  }

  export type BranchCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BranchCreateWithoutPaymentsInput, BranchUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPaymentsInput
    connect?: BranchWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type BranchUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BranchCreateWithoutPaymentsInput, BranchUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPaymentsInput
    upsert?: BranchUpsertWithoutPaymentsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPaymentsInput, BranchUpdateWithoutPaymentsInput>, BranchUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsInput, CustomerUpdateWithoutPaymentsInput>, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type BranchCreateNestedOneWithoutMachineMovementsInput = {
    create?: XOR<BranchCreateWithoutMachineMovementsInput, BranchUncheckedCreateWithoutMachineMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMachineMovementsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutMachineMovementsNestedInput = {
    create?: XOR<BranchCreateWithoutMachineMovementsInput, BranchUncheckedCreateWithoutMachineMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMachineMovementsInput
    upsert?: BranchUpsertWithoutMachineMovementsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMachineMovementsInput, BranchUpdateWithoutMachineMovementsInput>, BranchUncheckedUpdateWithoutMachineMovementsInput>
  }

  export type BranchCreateNestedOneWithoutSystemLogsInput = {
    create?: XOR<BranchCreateWithoutSystemLogsInput, BranchUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSystemLogsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutSystemLogsNestedInput = {
    create?: XOR<BranchCreateWithoutSystemLogsInput, BranchUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSystemLogsInput
    upsert?: BranchUpsertWithoutSystemLogsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSystemLogsInput, BranchUpdateWithoutSystemLogsInput>, BranchUncheckedUpdateWithoutSystemLogsInput>
  }

  export type MachineSaleCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<MachineSaleCreateWithoutInstallmentsInput, MachineSaleUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: MachineSaleCreateOrConnectWithoutInstallmentsInput
    connect?: MachineSaleWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<BranchCreateWithoutInstallmentsInput, BranchUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInstallmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type MachineSaleUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<MachineSaleCreateWithoutInstallmentsInput, MachineSaleUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: MachineSaleCreateOrConnectWithoutInstallmentsInput
    upsert?: MachineSaleUpsertWithoutInstallmentsInput
    connect?: MachineSaleWhereUniqueInput
    update?: XOR<XOR<MachineSaleUpdateToOneWithWhereWithoutInstallmentsInput, MachineSaleUpdateWithoutInstallmentsInput>, MachineSaleUncheckedUpdateWithoutInstallmentsInput>
  }

  export type BranchUpdateOneWithoutInstallmentsNestedInput = {
    create?: XOR<BranchCreateWithoutInstallmentsInput, BranchUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInstallmentsInput
    upsert?: BranchUpsertWithoutInstallmentsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInstallmentsInput, BranchUpdateWithoutInstallmentsInput>, BranchUncheckedUpdateWithoutInstallmentsInput>
  }

  export type InstallmentCreateNestedManyWithoutSaleInput = {
    create?: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput> | InstallmentCreateWithoutSaleInput[] | InstallmentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutSaleInput | InstallmentCreateOrConnectWithoutSaleInput[]
    createMany?: InstallmentCreateManySaleInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutSalesInput = {
    create?: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSalesInput
    connect?: BranchWhereUniqueInput
  }

  export type InstallmentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput> | InstallmentCreateWithoutSaleInput[] | InstallmentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutSaleInput | InstallmentCreateOrConnectWithoutSaleInput[]
    createMany?: InstallmentCreateManySaleInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type InstallmentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput> | InstallmentCreateWithoutSaleInput[] | InstallmentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutSaleInput | InstallmentCreateOrConnectWithoutSaleInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutSaleInput | InstallmentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: InstallmentCreateManySaleInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutSaleInput | InstallmentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutSaleInput | InstallmentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type BranchUpdateOneWithoutSalesNestedInput = {
    create?: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSalesInput
    upsert?: BranchUpsertWithoutSalesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSalesInput, BranchUpdateWithoutSalesInput>, BranchUncheckedUpdateWithoutSalesInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput> | InstallmentCreateWithoutSaleInput[] | InstallmentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutSaleInput | InstallmentCreateOrConnectWithoutSaleInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutSaleInput | InstallmentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: InstallmentCreateManySaleInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutSaleInput | InstallmentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutSaleInput | InstallmentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutPosMachineInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput> | MaintenanceRequestCreateWithoutPosMachineInput[] | MaintenanceRequestUncheckedCreateWithoutPosMachineInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPosMachineInput | MaintenanceRequestCreateOrConnectWithoutPosMachineInput[]
    createMany?: MaintenanceRequestCreateManyPosMachineInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutMachinesInput = {
    create?: XOR<CustomerCreateWithoutMachinesInput, CustomerUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMachinesInput
    connect?: CustomerWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutPosMachinesInput = {
    create?: XOR<BranchCreateWithoutPosMachinesInput, BranchUncheckedCreateWithoutPosMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPosMachinesInput
    connect?: BranchWhereUniqueInput
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutPosMachineInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput> | MaintenanceRequestCreateWithoutPosMachineInput[] | MaintenanceRequestUncheckedCreateWithoutPosMachineInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPosMachineInput | MaintenanceRequestCreateOrConnectWithoutPosMachineInput[]
    createMany?: MaintenanceRequestCreateManyPosMachineInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutPosMachineNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput> | MaintenanceRequestCreateWithoutPosMachineInput[] | MaintenanceRequestUncheckedCreateWithoutPosMachineInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPosMachineInput | MaintenanceRequestCreateOrConnectWithoutPosMachineInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutPosMachineInput | MaintenanceRequestUpsertWithWhereUniqueWithoutPosMachineInput[]
    createMany?: MaintenanceRequestCreateManyPosMachineInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutPosMachineInput | MaintenanceRequestUpdateWithWhereUniqueWithoutPosMachineInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutPosMachineInput | MaintenanceRequestUpdateManyWithWhereWithoutPosMachineInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutMachinesNestedInput = {
    create?: XOR<CustomerCreateWithoutMachinesInput, CustomerUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMachinesInput
    upsert?: CustomerUpsertWithoutMachinesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutMachinesInput, CustomerUpdateWithoutMachinesInput>, CustomerUncheckedUpdateWithoutMachinesInput>
  }

  export type BranchUpdateOneWithoutPosMachinesNestedInput = {
    create?: XOR<BranchCreateWithoutPosMachinesInput, BranchUncheckedCreateWithoutPosMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPosMachinesInput
    upsert?: BranchUpsertWithoutPosMachinesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPosMachinesInput, BranchUpdateWithoutPosMachinesInput>, BranchUncheckedUpdateWithoutPosMachinesInput>
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutPosMachineNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput> | MaintenanceRequestCreateWithoutPosMachineInput[] | MaintenanceRequestUncheckedCreateWithoutPosMachineInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPosMachineInput | MaintenanceRequestCreateOrConnectWithoutPosMachineInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutPosMachineInput | MaintenanceRequestUpsertWithWhereUniqueWithoutPosMachineInput[]
    createMany?: MaintenanceRequestCreateManyPosMachineInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutPosMachineInput | MaintenanceRequestUpdateWithWhereUniqueWithoutPosMachineInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutPosMachineInput | MaintenanceRequestUpdateManyWithWhereWithoutPosMachineInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutSimCardsInput = {
    create?: XOR<CustomerCreateWithoutSimCardsInput, CustomerUncheckedCreateWithoutSimCardsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSimCardsInput
    connect?: CustomerWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutSimCardsInput = {
    create?: XOR<BranchCreateWithoutSimCardsInput, BranchUncheckedCreateWithoutSimCardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSimCardsInput
    connect?: BranchWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutSimCardsNestedInput = {
    create?: XOR<CustomerCreateWithoutSimCardsInput, CustomerUncheckedCreateWithoutSimCardsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSimCardsInput
    upsert?: CustomerUpsertWithoutSimCardsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSimCardsInput, CustomerUpdateWithoutSimCardsInput>, CustomerUncheckedUpdateWithoutSimCardsInput>
  }

  export type BranchUpdateOneWithoutSimCardsNestedInput = {
    create?: XOR<BranchCreateWithoutSimCardsInput, BranchUncheckedCreateWithoutSimCardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSimCardsInput
    upsert?: BranchUpsertWithoutSimCardsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSimCardsInput, BranchUpdateWithoutSimCardsInput>, BranchUncheckedUpdateWithoutSimCardsInput>
  }

  export type ServiceAssignmentCreateNestedManyWithoutMachineInput = {
    create?: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput> | ServiceAssignmentCreateWithoutMachineInput[] | ServiceAssignmentUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutMachineInput | ServiceAssignmentCreateOrConnectWithoutMachineInput[]
    createMany?: ServiceAssignmentCreateManyMachineInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type BranchCreateNestedOneWithoutWarehouseMachinesInput = {
    create?: XOR<BranchCreateWithoutWarehouseMachinesInput, BranchUncheckedCreateWithoutWarehouseMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWarehouseMachinesInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceAssignmentUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput> | ServiceAssignmentCreateWithoutMachineInput[] | ServiceAssignmentUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutMachineInput | ServiceAssignmentCreateOrConnectWithoutMachineInput[]
    createMany?: ServiceAssignmentCreateManyMachineInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type ServiceAssignmentUpdateManyWithoutMachineNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput> | ServiceAssignmentCreateWithoutMachineInput[] | ServiceAssignmentUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutMachineInput | ServiceAssignmentCreateOrConnectWithoutMachineInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutMachineInput | ServiceAssignmentUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: ServiceAssignmentCreateManyMachineInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutMachineInput | ServiceAssignmentUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutMachineInput | ServiceAssignmentUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type BranchUpdateOneWithoutWarehouseMachinesNestedInput = {
    create?: XOR<BranchCreateWithoutWarehouseMachinesInput, BranchUncheckedCreateWithoutWarehouseMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWarehouseMachinesInput
    upsert?: BranchUpsertWithoutWarehouseMachinesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWarehouseMachinesInput, BranchUpdateWithoutWarehouseMachinesInput>, BranchUncheckedUpdateWithoutWarehouseMachinesInput>
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput> | ServiceAssignmentCreateWithoutMachineInput[] | ServiceAssignmentUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutMachineInput | ServiceAssignmentCreateOrConnectWithoutMachineInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutMachineInput | ServiceAssignmentUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: ServiceAssignmentCreateManyMachineInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutMachineInput | ServiceAssignmentUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutMachineInput | ServiceAssignmentUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutWarehouseSimsInput = {
    create?: XOR<BranchCreateWithoutWarehouseSimsInput, BranchUncheckedCreateWithoutWarehouseSimsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWarehouseSimsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutWarehouseSimsNestedInput = {
    create?: XOR<BranchCreateWithoutWarehouseSimsInput, BranchUncheckedCreateWithoutWarehouseSimsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWarehouseSimsInput
    upsert?: BranchUpsertWithoutWarehouseSimsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWarehouseSimsInput, BranchUpdateWithoutWarehouseSimsInput>, BranchUncheckedUpdateWithoutWarehouseSimsInput>
  }

  export type BranchCreateNestedOneWithoutSimMovementsInput = {
    create?: XOR<BranchCreateWithoutSimMovementsInput, BranchUncheckedCreateWithoutSimMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSimMovementsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutSimMovementsNestedInput = {
    create?: XOR<BranchCreateWithoutSimMovementsInput, BranchUncheckedCreateWithoutSimMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSimMovementsInput
    upsert?: BranchUpsertWithoutSimMovementsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSimMovementsInput, BranchUpdateWithoutSimMovementsInput>, BranchUncheckedUpdateWithoutSimMovementsInput>
  }

  export type BranchCreateNestedOneWithoutReceivedTransfersInput = {
    create?: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceivedTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutSentTransfersInput = {
    create?: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSentTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type TransferOrderItemCreateNestedManyWithoutTransferOrderInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceivedTransfersInput
    upsert?: BranchUpsertWithoutReceivedTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceivedTransfersInput, BranchUpdateWithoutReceivedTransfersInput>, BranchUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type BranchUpdateOneRequiredWithoutSentTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSentTransfersInput
    upsert?: BranchUpsertWithoutSentTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSentTransfersInput, BranchUpdateWithoutSentTransfersInput>, BranchUncheckedUpdateWithoutSentTransfersInput>
  }

  export type TransferOrderItemUpdateManyWithoutTransferOrderNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput | TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput | TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type TransferOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferOrderCreateOrConnectWithoutItemsInput
    connect?: TransferOrderWhereUniqueInput
  }

  export type TransferOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferOrderCreateOrConnectWithoutItemsInput
    upsert?: TransferOrderUpsertWithoutItemsInput
    connect?: TransferOrderWhereUniqueInput
    update?: XOR<XOR<TransferOrderUpdateToOneWithWhereWithoutItemsInput, TransferOrderUpdateWithoutItemsInput>, TransferOrderUncheckedUpdateWithoutItemsInput>
  }

  export type BranchCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<BranchCreateWithoutApprovalsInput, BranchUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutApprovalsInput
    connect?: BranchWhereUniqueInput
  }

  export type MaintenanceRequestCreateNestedOneWithoutApprovalInput = {
    create?: XOR<MaintenanceRequestCreateWithoutApprovalInput, MaintenanceRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutApprovalInput
    connect?: MaintenanceRequestWhereUniqueInput
  }

  export type BranchUpdateOneWithoutApprovalsNestedInput = {
    create?: XOR<BranchCreateWithoutApprovalsInput, BranchUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutApprovalsInput
    upsert?: BranchUpsertWithoutApprovalsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutApprovalsInput, BranchUpdateWithoutApprovalsInput>, BranchUncheckedUpdateWithoutApprovalsInput>
  }

  export type MaintenanceRequestUpdateOneRequiredWithoutApprovalNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutApprovalInput, MaintenanceRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutApprovalInput
    upsert?: MaintenanceRequestUpsertWithoutApprovalInput
    connect?: MaintenanceRequestWhereUniqueInput
    update?: XOR<XOR<MaintenanceRequestUpdateToOneWithWhereWithoutApprovalInput, MaintenanceRequestUpdateWithoutApprovalInput>, MaintenanceRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type BranchCreateNestedOneWithoutVouchersInput = {
    create?: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutVouchersInput
    connect?: BranchWhereUniqueInput
  }

  export type MaintenanceRequestCreateNestedOneWithoutVouchersInput = {
    create?: XOR<MaintenanceRequestCreateWithoutVouchersInput, MaintenanceRequestUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutVouchersInput
    connect?: MaintenanceRequestWhereUniqueInput
  }

  export type BranchUpdateOneWithoutVouchersNestedInput = {
    create?: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutVouchersInput
    upsert?: BranchUpsertWithoutVouchersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutVouchersInput, BranchUpdateWithoutVouchersInput>, BranchUncheckedUpdateWithoutVouchersInput>
  }

  export type MaintenanceRequestUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutVouchersInput, MaintenanceRequestUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutVouchersInput
    upsert?: MaintenanceRequestUpsertWithoutVouchersInput
    connect?: MaintenanceRequestWhereUniqueInput
    update?: XOR<XOR<MaintenanceRequestUpdateToOneWithWhereWithoutVouchersInput, MaintenanceRequestUpdateWithoutVouchersInput>, MaintenanceRequestUncheckedUpdateWithoutVouchersInput>
  }

  export type BranchCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BranchCreateWithoutNotificationsInput, BranchUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNotificationsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<BranchCreateWithoutNotificationsInput, BranchUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNotificationsInput
    upsert?: BranchUpsertWithoutNotificationsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutNotificationsInput, BranchUpdateWithoutNotificationsInput>, BranchUncheckedUpdateWithoutNotificationsInput>
  }

  export type WarehouseMachineCreateNestedOneWithoutServiceAssignmentsInput = {
    create?: XOR<WarehouseMachineCreateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedCreateWithoutServiceAssignmentsInput>
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutServiceAssignmentsInput
    connect?: WarehouseMachineWhereUniqueInput
  }

  export type ServiceAssignmentLogCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput> | ServiceAssignmentLogCreateWithoutAssignmentInput[] | ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput | ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput[]
    createMany?: ServiceAssignmentLogCreateManyAssignmentInputEnvelope
    connect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
  }

  export type ServiceAssignmentLogUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput> | ServiceAssignmentLogCreateWithoutAssignmentInput[] | ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput | ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput[]
    createMany?: ServiceAssignmentLogCreateManyAssignmentInputEnvelope
    connect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
  }

  export type WarehouseMachineUpdateOneRequiredWithoutServiceAssignmentsNestedInput = {
    create?: XOR<WarehouseMachineCreateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedCreateWithoutServiceAssignmentsInput>
    connectOrCreate?: WarehouseMachineCreateOrConnectWithoutServiceAssignmentsInput
    upsert?: WarehouseMachineUpsertWithoutServiceAssignmentsInput
    connect?: WarehouseMachineWhereUniqueInput
    update?: XOR<XOR<WarehouseMachineUpdateToOneWithWhereWithoutServiceAssignmentsInput, WarehouseMachineUpdateWithoutServiceAssignmentsInput>, WarehouseMachineUncheckedUpdateWithoutServiceAssignmentsInput>
  }

  export type ServiceAssignmentLogUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput> | ServiceAssignmentLogCreateWithoutAssignmentInput[] | ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput | ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput[]
    upsert?: ServiceAssignmentLogUpsertWithWhereUniqueWithoutAssignmentInput | ServiceAssignmentLogUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: ServiceAssignmentLogCreateManyAssignmentInputEnvelope
    set?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    disconnect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    delete?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    connect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    update?: ServiceAssignmentLogUpdateWithWhereUniqueWithoutAssignmentInput | ServiceAssignmentLogUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: ServiceAssignmentLogUpdateManyWithWhereWithoutAssignmentInput | ServiceAssignmentLogUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: ServiceAssignmentLogScalarWhereInput | ServiceAssignmentLogScalarWhereInput[]
  }

  export type ServiceAssignmentLogUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput> | ServiceAssignmentLogCreateWithoutAssignmentInput[] | ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput | ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput[]
    upsert?: ServiceAssignmentLogUpsertWithWhereUniqueWithoutAssignmentInput | ServiceAssignmentLogUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: ServiceAssignmentLogCreateManyAssignmentInputEnvelope
    set?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    disconnect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    delete?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    connect?: ServiceAssignmentLogWhereUniqueInput | ServiceAssignmentLogWhereUniqueInput[]
    update?: ServiceAssignmentLogUpdateWithWhereUniqueWithoutAssignmentInput | ServiceAssignmentLogUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: ServiceAssignmentLogUpdateManyWithWhereWithoutAssignmentInput | ServiceAssignmentLogUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: ServiceAssignmentLogScalarWhereInput | ServiceAssignmentLogScalarWhereInput[]
  }

  export type ServiceAssignmentCreateNestedOneWithoutLogsInput = {
    create?: XOR<ServiceAssignmentCreateWithoutLogsInput, ServiceAssignmentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutLogsInput
    connect?: ServiceAssignmentWhereUniqueInput
  }

  export type ServiceAssignmentUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutLogsInput, ServiceAssignmentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutLogsInput
    upsert?: ServiceAssignmentUpsertWithoutLogsInput
    connect?: ServiceAssignmentWhereUniqueInput
    update?: XOR<XOR<ServiceAssignmentUpdateToOneWithWhereWithoutLogsInput, ServiceAssignmentUpdateWithoutLogsInput>, ServiceAssignmentUncheckedUpdateWithoutLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutServicedBranchesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServicedBranchesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServicedBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServicedBranchesInput, BranchUncheckedCreateWithoutServicedBranchesInput>
  }

  export type BranchCreateWithoutMaintenanceCenterInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMaintenanceCenterInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMaintenanceCenterInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput>
  }

  export type BranchCreateManyMaintenanceCenterInputEnvelope = {
    data: BranchCreateManyMaintenanceCenterInput | BranchCreateManyMaintenanceCenterInput[]
  }

  export type BranchCreateWithoutChildBranchesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutChildBranchesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutChildBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutChildBranchesInput, BranchUncheckedCreateWithoutChildBranchesInput>
  }

  export type BranchCreateWithoutParentBranchInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutParentBranchInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutParentBranchInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput>
  }

  export type BranchCreateManyParentBranchInputEnvelope = {
    data: BranchCreateManyParentBranchInput | BranchCreateManyParentBranchInput[]
  }

  export type CustomerCreateWithoutBranchInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutBranchInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput>
  }

  export type CustomerCreateManyBranchInputEnvelope = {
    data: CustomerCreateManyBranchInput | CustomerCreateManyBranchInput[]
  }

  export type InstallmentCreateWithoutBranchInput = {
    id?: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    sale: MachineSaleCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateWithoutBranchInput = {
    id?: string
    saleId: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
  }

  export type InstallmentCreateOrConnectWithoutBranchInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput>
  }

  export type InstallmentCreateManyBranchInputEnvelope = {
    data: InstallmentCreateManyBranchInput | InstallmentCreateManyBranchInput[]
  }

  export type InventoryItemCreateWithoutBranchInput = {
    id?: string
    quantity?: number
    minLevel?: number
    location?: string | null
    part: SparePartCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutBranchInput = {
    id?: string
    partId: string
    quantity?: number
    minLevel?: number
    location?: string | null
  }

  export type InventoryItemCreateOrConnectWithoutBranchInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput>
  }

  export type InventoryItemCreateManyBranchInputEnvelope = {
    data: InventoryItemCreateManyBranchInput | InventoryItemCreateManyBranchInput[]
  }

  export type MachineMovementLogCreateWithoutBranchInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type MachineMovementLogUncheckedCreateWithoutBranchInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type MachineMovementLogCreateOrConnectWithoutBranchInput = {
    where: MachineMovementLogWhereUniqueInput
    create: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput>
  }

  export type MachineMovementLogCreateManyBranchInputEnvelope = {
    data: MachineMovementLogCreateManyBranchInput | MachineMovementLogCreateManyBranchInput[]
  }

  export type MachineSaleCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    installments?: InstallmentCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type MachineSaleUncheckedCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    customerId: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type MachineSaleCreateOrConnectWithoutBranchInput = {
    where: MachineSaleWhereUniqueInput
    create: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput>
  }

  export type MachineSaleCreateManyBranchInputEnvelope = {
    data: MachineSaleCreateManyBranchInput | MachineSaleCreateManyBranchInput[]
  }

  export type MaintenanceApprovalCreateWithoutBranchInput = {
    id?: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
    request: MaintenanceRequestCreateNestedOneWithoutApprovalInput
  }

  export type MaintenanceApprovalUncheckedCreateWithoutBranchInput = {
    id?: string
    requestId: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
  }

  export type MaintenanceApprovalCreateOrConnectWithoutBranchInput = {
    where: MaintenanceApprovalWhereUniqueInput
    create: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput>
  }

  export type MaintenanceApprovalCreateManyBranchInputEnvelope = {
    data: MaintenanceApprovalCreateManyBranchInput | MaintenanceApprovalCreateManyBranchInput[]
  }

  export type MaintenanceRequestCreateWithoutBranchInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalCreateNestedOneWithoutRequestInput
    customer: CustomerCreateNestedOneWithoutRequestsInput
    posMachine?: PosMachineCreateNestedOneWithoutRequestsInput
    vouchers?: RepairVoucherCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutBranchInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutBranchInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput>
  }

  export type MaintenanceRequestCreateManyBranchInputEnvelope = {
    data: MaintenanceRequestCreateManyBranchInput | MaintenanceRequestCreateManyBranchInput[]
  }

  export type NotificationCreateWithoutBranchInput = {
    id?: string
    userId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutBranchInput = {
    id?: string
    userId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBranchInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput>
  }

  export type NotificationCreateManyBranchInputEnvelope = {
    data: NotificationCreateManyBranchInput | NotificationCreateManyBranchInput[]
  }

  export type PaymentCreateWithoutBranchInput = {
    id?: string
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    createdAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBranchInput = {
    id?: string
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBranchInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput>
  }

  export type PaymentCreateManyBranchInputEnvelope = {
    data: PaymentCreateManyBranchInput | PaymentCreateManyBranchInput[]
  }

  export type PosMachineCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    requests?: MaintenanceRequestCreateNestedManyWithoutPosMachineInput
    customer?: CustomerCreateNestedOneWithoutMachinesInput
  }

  export type PosMachineUncheckedCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    customerId?: string | null
    isMain?: boolean | null
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutPosMachineInput
  }

  export type PosMachineCreateOrConnectWithoutBranchInput = {
    where: PosMachineWhereUniqueInput
    create: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput>
  }

  export type PosMachineCreateManyBranchInputEnvelope = {
    data: PosMachineCreateManyBranchInput | PosMachineCreateManyBranchInput[]
  }

  export type RepairVoucherCreateWithoutBranchInput = {
    id?: string
    code: string
    type: string
    parts: string
    totalCost: number
    createdAt?: Date | string
    createdBy?: string | null
    request: MaintenanceRequestCreateNestedOneWithoutVouchersInput
  }

  export type RepairVoucherUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    requestId: string
    type: string
    parts: string
    totalCost: number
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type RepairVoucherCreateOrConnectWithoutBranchInput = {
    where: RepairVoucherWhereUniqueInput
    create: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput>
  }

  export type RepairVoucherCreateManyBranchInputEnvelope = {
    data: RepairVoucherCreateManyBranchInput | RepairVoucherCreateManyBranchInput[]
  }

  export type SimCardCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customer?: CustomerCreateNestedOneWithoutSimCardsInput
  }

  export type SimCardUncheckedCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customerId?: string | null
  }

  export type SimCardCreateOrConnectWithoutBranchInput = {
    where: SimCardWhereUniqueInput
    create: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput>
  }

  export type SimCardCreateManyBranchInputEnvelope = {
    data: SimCardCreateManyBranchInput | SimCardCreateManyBranchInput[]
  }

  export type SimMovementLogCreateWithoutBranchInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type SimMovementLogUncheckedCreateWithoutBranchInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type SimMovementLogCreateOrConnectWithoutBranchInput = {
    where: SimMovementLogWhereUniqueInput
    create: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput>
  }

  export type SimMovementLogCreateManyBranchInputEnvelope = {
    data: SimMovementLogCreateManyBranchInput | SimMovementLogCreateManyBranchInput[]
  }

  export type StockMovementCreateWithoutBranchInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUncheckedCreateWithoutBranchInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutBranchInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput>
  }

  export type StockMovementCreateManyBranchInputEnvelope = {
    data: StockMovementCreateManyBranchInput | StockMovementCreateManyBranchInput[]
  }

  export type SystemLogCreateWithoutBranchInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateWithoutBranchInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type SystemLogCreateOrConnectWithoutBranchInput = {
    where: SystemLogWhereUniqueInput
    create: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput>
  }

  export type SystemLogCreateManyBranchInputEnvelope = {
    data: SystemLogCreateManyBranchInput | SystemLogCreateManyBranchInput[]
  }

  export type TransferOrderCreateWithoutToBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromBranch: BranchCreateNestedOneWithoutSentTransfersInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateWithoutToBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    fromBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderCreateOrConnectWithoutToBranchInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput>
  }

  export type TransferOrderCreateManyToBranchInputEnvelope = {
    data: TransferOrderCreateManyToBranchInput | TransferOrderCreateManyToBranchInput[]
  }

  export type TransferOrderCreateWithoutFromBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    toBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateWithoutFromBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    toBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderCreateOrConnectWithoutFromBranchInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput>
  }

  export type TransferOrderCreateManyFromBranchInputEnvelope = {
    data: TransferOrderCreateManyFromBranchInput | TransferOrderCreateManyFromBranchInput[]
  }

  export type UsedPartLogCreateWithoutBranchInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
  }

  export type UsedPartLogUncheckedCreateWithoutBranchInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
  }

  export type UsedPartLogCreateOrConnectWithoutBranchInput = {
    where: UsedPartLogWhereUniqueInput
    create: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput>
  }

  export type UsedPartLogCreateManyBranchInputEnvelope = {
    data: UsedPartLogCreateManyBranchInput | UsedPartLogCreateManyBranchInput[]
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
  }

  export type WarehouseMachineCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutMachineInput
  }

  export type WarehouseMachineUncheckedCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WarehouseMachineCreateOrConnectWithoutBranchInput = {
    where: WarehouseMachineWhereUniqueInput
    create: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput>
  }

  export type WarehouseMachineCreateManyBranchInputEnvelope = {
    data: WarehouseMachineCreateManyBranchInput | WarehouseMachineCreateManyBranchInput[]
  }

  export type WarehouseSimCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseSimUncheckedCreateWithoutBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseSimCreateOrConnectWithoutBranchInput = {
    where: WarehouseSimWhereUniqueInput
    create: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput>
  }

  export type WarehouseSimCreateManyBranchInputEnvelope = {
    data: WarehouseSimCreateManyBranchInput | WarehouseSimCreateManyBranchInput[]
  }

  export type BranchUpsertWithoutServicedBranchesInput = {
    update: XOR<BranchUpdateWithoutServicedBranchesInput, BranchUncheckedUpdateWithoutServicedBranchesInput>
    create: XOR<BranchCreateWithoutServicedBranchesInput, BranchUncheckedCreateWithoutServicedBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServicedBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServicedBranchesInput, BranchUncheckedUpdateWithoutServicedBranchesInput>
  }

  export type BranchUpdateWithoutServicedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServicedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUpsertWithWhereUniqueWithoutMaintenanceCenterInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutMaintenanceCenterInput, BranchUncheckedUpdateWithoutMaintenanceCenterInput>
    create: XOR<BranchCreateWithoutMaintenanceCenterInput, BranchUncheckedCreateWithoutMaintenanceCenterInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutMaintenanceCenterInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutMaintenanceCenterInput, BranchUncheckedUpdateWithoutMaintenanceCenterInput>
  }

  export type BranchUpdateManyWithWhereWithoutMaintenanceCenterInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutMaintenanceCenterInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    type?: StringFilter<"Branch"> | string
    isActive?: BoolFilter<"Branch"> | boolean
    parentBranchId?: StringNullableFilter<"Branch"> | string | null
    maintenanceCenterId?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type BranchUpsertWithoutChildBranchesInput = {
    update: XOR<BranchUpdateWithoutChildBranchesInput, BranchUncheckedUpdateWithoutChildBranchesInput>
    create: XOR<BranchCreateWithoutChildBranchesInput, BranchUncheckedCreateWithoutChildBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutChildBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutChildBranchesInput, BranchUncheckedUpdateWithoutChildBranchesInput>
  }

  export type BranchUpdateWithoutChildBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutChildBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUpsertWithWhereUniqueWithoutParentBranchInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutParentBranchInput, BranchUncheckedUpdateWithoutParentBranchInput>
    create: XOR<BranchCreateWithoutParentBranchInput, BranchUncheckedCreateWithoutParentBranchInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutParentBranchInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutParentBranchInput, BranchUncheckedUpdateWithoutParentBranchInput>
  }

  export type BranchUpdateManyWithWhereWithoutParentBranchInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutParentBranchInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutBranchInput, CustomerUncheckedUpdateWithoutBranchInput>
    create: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutBranchInput, CustomerUncheckedUpdateWithoutBranchInput>
  }

  export type CustomerUpdateManyWithWhereWithoutBranchInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutBranchInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    bkcode?: StringFilter<"Customer"> | string
    client_name?: StringFilter<"Customer"> | string
    supply_office?: StringNullableFilter<"Customer"> | string | null
    operating_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    contact_person?: StringNullableFilter<"Customer"> | string | null
    scanned_id_path?: StringNullableFilter<"Customer"> | string | null
    national_id?: StringNullableFilter<"Customer"> | string | null
    dept?: StringNullableFilter<"Customer"> | string | null
    telephone_1?: StringNullableFilter<"Customer"> | string | null
    telephone_2?: StringNullableFilter<"Customer"> | string | null
    has_gates?: BoolNullableFilter<"Customer"> | boolean | null
    bk_type?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    papers_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isSpecial?: BoolNullableFilter<"Customer"> | boolean | null
    clienttype?: StringNullableFilter<"Customer"> | string | null
    branchId?: StringNullableFilter<"Customer"> | string | null
  }

  export type InstallmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutBranchInput, InstallmentUncheckedUpdateWithoutBranchInput>
    create: XOR<InstallmentCreateWithoutBranchInput, InstallmentUncheckedCreateWithoutBranchInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutBranchInput, InstallmentUncheckedUpdateWithoutBranchInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutBranchInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type InstallmentScalarWhereInput = {
    AND?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    OR?: InstallmentScalarWhereInput[]
    NOT?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    id?: StringFilter<"Installment"> | string
    saleId?: StringFilter<"Installment"> | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: FloatFilter<"Installment"> | number
    isPaid?: BoolFilter<"Installment"> | boolean
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    description?: StringNullableFilter<"Installment"> | string | null
    paidAmount?: FloatNullableFilter<"Installment"> | number | null
    paymentPlace?: StringNullableFilter<"Installment"> | string | null
    receiptNumber?: StringNullableFilter<"Installment"> | string | null
    branchId?: StringNullableFilter<"Installment"> | string | null
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutBranchInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutBranchInput, InventoryItemUncheckedUpdateWithoutBranchInput>
    create: XOR<InventoryItemCreateWithoutBranchInput, InventoryItemUncheckedCreateWithoutBranchInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutBranchInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutBranchInput, InventoryItemUncheckedUpdateWithoutBranchInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutBranchInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutBranchInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    partId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    minLevel?: IntFilter<"InventoryItem"> | number
    location?: StringNullableFilter<"InventoryItem"> | string | null
    branchId?: StringNullableFilter<"InventoryItem"> | string | null
  }

  export type MachineMovementLogUpsertWithWhereUniqueWithoutBranchInput = {
    where: MachineMovementLogWhereUniqueInput
    update: XOR<MachineMovementLogUpdateWithoutBranchInput, MachineMovementLogUncheckedUpdateWithoutBranchInput>
    create: XOR<MachineMovementLogCreateWithoutBranchInput, MachineMovementLogUncheckedCreateWithoutBranchInput>
  }

  export type MachineMovementLogUpdateWithWhereUniqueWithoutBranchInput = {
    where: MachineMovementLogWhereUniqueInput
    data: XOR<MachineMovementLogUpdateWithoutBranchInput, MachineMovementLogUncheckedUpdateWithoutBranchInput>
  }

  export type MachineMovementLogUpdateManyWithWhereWithoutBranchInput = {
    where: MachineMovementLogScalarWhereInput
    data: XOR<MachineMovementLogUpdateManyMutationInput, MachineMovementLogUncheckedUpdateManyWithoutBranchInput>
  }

  export type MachineMovementLogScalarWhereInput = {
    AND?: MachineMovementLogScalarWhereInput | MachineMovementLogScalarWhereInput[]
    OR?: MachineMovementLogScalarWhereInput[]
    NOT?: MachineMovementLogScalarWhereInput | MachineMovementLogScalarWhereInput[]
    id?: StringFilter<"MachineMovementLog"> | string
    machineId?: StringNullableFilter<"MachineMovementLog"> | string | null
    serialNumber?: StringFilter<"MachineMovementLog"> | string
    action?: StringFilter<"MachineMovementLog"> | string
    details?: StringNullableFilter<"MachineMovementLog"> | string | null
    performedBy?: StringNullableFilter<"MachineMovementLog"> | string | null
    branchId?: StringNullableFilter<"MachineMovementLog"> | string | null
    createdAt?: DateTimeFilter<"MachineMovementLog"> | Date | string
  }

  export type MachineSaleUpsertWithWhereUniqueWithoutBranchInput = {
    where: MachineSaleWhereUniqueInput
    update: XOR<MachineSaleUpdateWithoutBranchInput, MachineSaleUncheckedUpdateWithoutBranchInput>
    create: XOR<MachineSaleCreateWithoutBranchInput, MachineSaleUncheckedCreateWithoutBranchInput>
  }

  export type MachineSaleUpdateWithWhereUniqueWithoutBranchInput = {
    where: MachineSaleWhereUniqueInput
    data: XOR<MachineSaleUpdateWithoutBranchInput, MachineSaleUncheckedUpdateWithoutBranchInput>
  }

  export type MachineSaleUpdateManyWithWhereWithoutBranchInput = {
    where: MachineSaleScalarWhereInput
    data: XOR<MachineSaleUpdateManyMutationInput, MachineSaleUncheckedUpdateManyWithoutBranchInput>
  }

  export type MachineSaleScalarWhereInput = {
    AND?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
    OR?: MachineSaleScalarWhereInput[]
    NOT?: MachineSaleScalarWhereInput | MachineSaleScalarWhereInput[]
    id?: StringFilter<"MachineSale"> | string
    serialNumber?: StringFilter<"MachineSale"> | string
    customerId?: StringFilter<"MachineSale"> | string
    saleDate?: DateTimeFilter<"MachineSale"> | Date | string
    type?: StringFilter<"MachineSale"> | string
    totalPrice?: FloatFilter<"MachineSale"> | number
    paidAmount?: FloatFilter<"MachineSale"> | number
    status?: StringFilter<"MachineSale"> | string
    notes?: StringNullableFilter<"MachineSale"> | string | null
    branchId?: StringNullableFilter<"MachineSale"> | string | null
  }

  export type MaintenanceApprovalUpsertWithWhereUniqueWithoutBranchInput = {
    where: MaintenanceApprovalWhereUniqueInput
    update: XOR<MaintenanceApprovalUpdateWithoutBranchInput, MaintenanceApprovalUncheckedUpdateWithoutBranchInput>
    create: XOR<MaintenanceApprovalCreateWithoutBranchInput, MaintenanceApprovalUncheckedCreateWithoutBranchInput>
  }

  export type MaintenanceApprovalUpdateWithWhereUniqueWithoutBranchInput = {
    where: MaintenanceApprovalWhereUniqueInput
    data: XOR<MaintenanceApprovalUpdateWithoutBranchInput, MaintenanceApprovalUncheckedUpdateWithoutBranchInput>
  }

  export type MaintenanceApprovalUpdateManyWithWhereWithoutBranchInput = {
    where: MaintenanceApprovalScalarWhereInput
    data: XOR<MaintenanceApprovalUpdateManyMutationInput, MaintenanceApprovalUncheckedUpdateManyWithoutBranchInput>
  }

  export type MaintenanceApprovalScalarWhereInput = {
    AND?: MaintenanceApprovalScalarWhereInput | MaintenanceApprovalScalarWhereInput[]
    OR?: MaintenanceApprovalScalarWhereInput[]
    NOT?: MaintenanceApprovalScalarWhereInput | MaintenanceApprovalScalarWhereInput[]
    id?: StringFilter<"MaintenanceApproval"> | string
    requestId?: StringFilter<"MaintenanceApproval"> | string
    cost?: FloatFilter<"MaintenanceApproval"> | number
    parts?: StringFilter<"MaintenanceApproval"> | string
    status?: StringFilter<"MaintenanceApproval"> | string
    notes?: StringNullableFilter<"MaintenanceApproval"> | string | null
    branchId?: StringNullableFilter<"MaintenanceApproval"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceApproval"> | Date | string
    respondedAt?: DateTimeNullableFilter<"MaintenanceApproval"> | Date | string | null
    respondedBy?: StringNullableFilter<"MaintenanceApproval"> | string | null
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutBranchInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutBranchInput, MaintenanceRequestUncheckedUpdateWithoutBranchInput>
    create: XOR<MaintenanceRequestCreateWithoutBranchInput, MaintenanceRequestUncheckedCreateWithoutBranchInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutBranchInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutBranchInput, MaintenanceRequestUncheckedUpdateWithoutBranchInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutBranchInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutBranchInput>
  }

  export type MaintenanceRequestScalarWhereInput = {
    AND?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    OR?: MaintenanceRequestScalarWhereInput[]
    NOT?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    customerId?: StringFilter<"MaintenanceRequest"> | string
    posMachineId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    customerName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineModel?: StringNullableFilter<"MaintenanceRequest"> | string | null
    machineManufacturer?: StringNullableFilter<"MaintenanceRequest"> | string | null
    serialNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: StringFilter<"MaintenanceRequest"> | string
    branchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    servicedByBranchId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    technician?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    complaint?: StringNullableFilter<"MaintenanceRequest"> | string | null
    actionTaken?: StringNullableFilter<"MaintenanceRequest"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    closingUserId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingUserName?: StringNullableFilter<"MaintenanceRequest"> | string | null
    closingTimestamp?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    usedParts?: StringNullableFilter<"MaintenanceRequest"> | string | null
    receiptNumber?: StringNullableFilter<"MaintenanceRequest"> | string | null
    totalCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutBranchInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBranchInput, NotificationUncheckedUpdateWithoutBranchInput>
    create: XOR<NotificationCreateWithoutBranchInput, NotificationUncheckedCreateWithoutBranchInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBranchInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBranchInput, NotificationUncheckedUpdateWithoutBranchInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBranchInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBranchInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    branchId?: StringNullableFilter<"Notification"> | string | null
    link?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBranchInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBranchInput, PaymentUncheckedUpdateWithoutBranchInput>
    create: XOR<PaymentCreateWithoutBranchInput, PaymentUncheckedCreateWithoutBranchInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBranchInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBranchInput, PaymentUncheckedUpdateWithoutBranchInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBranchInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBranchInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    customerName?: StringNullableFilter<"Payment"> | string | null
    requestId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    type?: StringNullableFilter<"Payment"> | string | null
    reason?: StringNullableFilter<"Payment"> | string | null
    paymentPlace?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    receiptNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    userId?: StringNullableFilter<"Payment"> | string | null
    userName?: StringNullableFilter<"Payment"> | string | null
    branchId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PosMachineUpsertWithWhereUniqueWithoutBranchInput = {
    where: PosMachineWhereUniqueInput
    update: XOR<PosMachineUpdateWithoutBranchInput, PosMachineUncheckedUpdateWithoutBranchInput>
    create: XOR<PosMachineCreateWithoutBranchInput, PosMachineUncheckedCreateWithoutBranchInput>
  }

  export type PosMachineUpdateWithWhereUniqueWithoutBranchInput = {
    where: PosMachineWhereUniqueInput
    data: XOR<PosMachineUpdateWithoutBranchInput, PosMachineUncheckedUpdateWithoutBranchInput>
  }

  export type PosMachineUpdateManyWithWhereWithoutBranchInput = {
    where: PosMachineScalarWhereInput
    data: XOR<PosMachineUpdateManyMutationInput, PosMachineUncheckedUpdateManyWithoutBranchInput>
  }

  export type PosMachineScalarWhereInput = {
    AND?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
    OR?: PosMachineScalarWhereInput[]
    NOT?: PosMachineScalarWhereInput | PosMachineScalarWhereInput[]
    id?: StringFilter<"PosMachine"> | string
    serialNumber?: StringFilter<"PosMachine"> | string
    posId?: StringNullableFilter<"PosMachine"> | string | null
    model?: StringNullableFilter<"PosMachine"> | string | null
    manufacturer?: StringNullableFilter<"PosMachine"> | string | null
    customerId?: StringNullableFilter<"PosMachine"> | string | null
    isMain?: BoolNullableFilter<"PosMachine"> | boolean | null
    branchId?: StringNullableFilter<"PosMachine"> | string | null
  }

  export type RepairVoucherUpsertWithWhereUniqueWithoutBranchInput = {
    where: RepairVoucherWhereUniqueInput
    update: XOR<RepairVoucherUpdateWithoutBranchInput, RepairVoucherUncheckedUpdateWithoutBranchInput>
    create: XOR<RepairVoucherCreateWithoutBranchInput, RepairVoucherUncheckedCreateWithoutBranchInput>
  }

  export type RepairVoucherUpdateWithWhereUniqueWithoutBranchInput = {
    where: RepairVoucherWhereUniqueInput
    data: XOR<RepairVoucherUpdateWithoutBranchInput, RepairVoucherUncheckedUpdateWithoutBranchInput>
  }

  export type RepairVoucherUpdateManyWithWhereWithoutBranchInput = {
    where: RepairVoucherScalarWhereInput
    data: XOR<RepairVoucherUpdateManyMutationInput, RepairVoucherUncheckedUpdateManyWithoutBranchInput>
  }

  export type RepairVoucherScalarWhereInput = {
    AND?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
    OR?: RepairVoucherScalarWhereInput[]
    NOT?: RepairVoucherScalarWhereInput | RepairVoucherScalarWhereInput[]
    id?: StringFilter<"RepairVoucher"> | string
    code?: StringFilter<"RepairVoucher"> | string
    requestId?: StringFilter<"RepairVoucher"> | string
    type?: StringFilter<"RepairVoucher"> | string
    parts?: StringFilter<"RepairVoucher"> | string
    totalCost?: FloatFilter<"RepairVoucher"> | number
    branchId?: StringNullableFilter<"RepairVoucher"> | string | null
    createdAt?: DateTimeFilter<"RepairVoucher"> | Date | string
    createdBy?: StringNullableFilter<"RepairVoucher"> | string | null
  }

  export type SimCardUpsertWithWhereUniqueWithoutBranchInput = {
    where: SimCardWhereUniqueInput
    update: XOR<SimCardUpdateWithoutBranchInput, SimCardUncheckedUpdateWithoutBranchInput>
    create: XOR<SimCardCreateWithoutBranchInput, SimCardUncheckedCreateWithoutBranchInput>
  }

  export type SimCardUpdateWithWhereUniqueWithoutBranchInput = {
    where: SimCardWhereUniqueInput
    data: XOR<SimCardUpdateWithoutBranchInput, SimCardUncheckedUpdateWithoutBranchInput>
  }

  export type SimCardUpdateManyWithWhereWithoutBranchInput = {
    where: SimCardScalarWhereInput
    data: XOR<SimCardUpdateManyMutationInput, SimCardUncheckedUpdateManyWithoutBranchInput>
  }

  export type SimCardScalarWhereInput = {
    AND?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
    OR?: SimCardScalarWhereInput[]
    NOT?: SimCardScalarWhereInput | SimCardScalarWhereInput[]
    id?: StringFilter<"SimCard"> | string
    serialNumber?: StringFilter<"SimCard"> | string
    type?: StringNullableFilter<"SimCard"> | string | null
    customerId?: StringNullableFilter<"SimCard"> | string | null
    branchId?: StringNullableFilter<"SimCard"> | string | null
  }

  export type SimMovementLogUpsertWithWhereUniqueWithoutBranchInput = {
    where: SimMovementLogWhereUniqueInput
    update: XOR<SimMovementLogUpdateWithoutBranchInput, SimMovementLogUncheckedUpdateWithoutBranchInput>
    create: XOR<SimMovementLogCreateWithoutBranchInput, SimMovementLogUncheckedCreateWithoutBranchInput>
  }

  export type SimMovementLogUpdateWithWhereUniqueWithoutBranchInput = {
    where: SimMovementLogWhereUniqueInput
    data: XOR<SimMovementLogUpdateWithoutBranchInput, SimMovementLogUncheckedUpdateWithoutBranchInput>
  }

  export type SimMovementLogUpdateManyWithWhereWithoutBranchInput = {
    where: SimMovementLogScalarWhereInput
    data: XOR<SimMovementLogUpdateManyMutationInput, SimMovementLogUncheckedUpdateManyWithoutBranchInput>
  }

  export type SimMovementLogScalarWhereInput = {
    AND?: SimMovementLogScalarWhereInput | SimMovementLogScalarWhereInput[]
    OR?: SimMovementLogScalarWhereInput[]
    NOT?: SimMovementLogScalarWhereInput | SimMovementLogScalarWhereInput[]
    id?: StringFilter<"SimMovementLog"> | string
    simId?: StringFilter<"SimMovementLog"> | string
    serialNumber?: StringFilter<"SimMovementLog"> | string
    action?: StringFilter<"SimMovementLog"> | string
    details?: StringNullableFilter<"SimMovementLog"> | string | null
    performedBy?: StringNullableFilter<"SimMovementLog"> | string | null
    branchId?: StringNullableFilter<"SimMovementLog"> | string | null
    createdAt?: DateTimeFilter<"SimMovementLog"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutBranchInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutBranchInput, StockMovementUncheckedUpdateWithoutBranchInput>
    create: XOR<StockMovementCreateWithoutBranchInput, StockMovementUncheckedCreateWithoutBranchInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutBranchInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutBranchInput, StockMovementUncheckedUpdateWithoutBranchInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutBranchInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutBranchInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    partId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    requestId?: StringNullableFilter<"StockMovement"> | string | null
    userId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    branchId?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type SystemLogUpsertWithWhereUniqueWithoutBranchInput = {
    where: SystemLogWhereUniqueInput
    update: XOR<SystemLogUpdateWithoutBranchInput, SystemLogUncheckedUpdateWithoutBranchInput>
    create: XOR<SystemLogCreateWithoutBranchInput, SystemLogUncheckedCreateWithoutBranchInput>
  }

  export type SystemLogUpdateWithWhereUniqueWithoutBranchInput = {
    where: SystemLogWhereUniqueInput
    data: XOR<SystemLogUpdateWithoutBranchInput, SystemLogUncheckedUpdateWithoutBranchInput>
  }

  export type SystemLogUpdateManyWithWhereWithoutBranchInput = {
    where: SystemLogScalarWhereInput
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyWithoutBranchInput>
  }

  export type SystemLogScalarWhereInput = {
    AND?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    OR?: SystemLogScalarWhereInput[]
    NOT?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    performedBy?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringNullableFilter<"SystemLog"> | string | null
    branchId?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type TransferOrderUpsertWithWhereUniqueWithoutToBranchInput = {
    where: TransferOrderWhereUniqueInput
    update: XOR<TransferOrderUpdateWithoutToBranchInput, TransferOrderUncheckedUpdateWithoutToBranchInput>
    create: XOR<TransferOrderCreateWithoutToBranchInput, TransferOrderUncheckedCreateWithoutToBranchInput>
  }

  export type TransferOrderUpdateWithWhereUniqueWithoutToBranchInput = {
    where: TransferOrderWhereUniqueInput
    data: XOR<TransferOrderUpdateWithoutToBranchInput, TransferOrderUncheckedUpdateWithoutToBranchInput>
  }

  export type TransferOrderUpdateManyWithWhereWithoutToBranchInput = {
    where: TransferOrderScalarWhereInput
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyWithoutToBranchInput>
  }

  export type TransferOrderScalarWhereInput = {
    AND?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
    OR?: TransferOrderScalarWhereInput[]
    NOT?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
    id?: StringFilter<"TransferOrder"> | string
    orderNumber?: StringFilter<"TransferOrder"> | string
    waybillNumber?: StringNullableFilter<"TransferOrder"> | string | null
    branchId?: StringNullableFilter<"TransferOrder"> | string | null
    fromBranchId?: StringFilter<"TransferOrder"> | string
    toBranchId?: StringFilter<"TransferOrder"> | string
    status?: StringFilter<"TransferOrder"> | string
    type?: StringFilter<"TransferOrder"> | string
    driverName?: StringNullableFilter<"TransferOrder"> | string | null
    driverPhone?: StringNullableFilter<"TransferOrder"> | string | null
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    createdBy?: StringNullableFilter<"TransferOrder"> | string | null
    createdByName?: StringNullableFilter<"TransferOrder"> | string | null
    createdByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByUserId?: StringNullableFilter<"TransferOrder"> | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedBy?: StringNullableFilter<"TransferOrder"> | string | null
    receivedByName?: StringNullableFilter<"TransferOrder"> | string | null
    rejectionReason?: StringNullableFilter<"TransferOrder"> | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
  }

  export type TransferOrderUpsertWithWhereUniqueWithoutFromBranchInput = {
    where: TransferOrderWhereUniqueInput
    update: XOR<TransferOrderUpdateWithoutFromBranchInput, TransferOrderUncheckedUpdateWithoutFromBranchInput>
    create: XOR<TransferOrderCreateWithoutFromBranchInput, TransferOrderUncheckedCreateWithoutFromBranchInput>
  }

  export type TransferOrderUpdateWithWhereUniqueWithoutFromBranchInput = {
    where: TransferOrderWhereUniqueInput
    data: XOR<TransferOrderUpdateWithoutFromBranchInput, TransferOrderUncheckedUpdateWithoutFromBranchInput>
  }

  export type TransferOrderUpdateManyWithWhereWithoutFromBranchInput = {
    where: TransferOrderScalarWhereInput
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyWithoutFromBranchInput>
  }

  export type UsedPartLogUpsertWithWhereUniqueWithoutBranchInput = {
    where: UsedPartLogWhereUniqueInput
    update: XOR<UsedPartLogUpdateWithoutBranchInput, UsedPartLogUncheckedUpdateWithoutBranchInput>
    create: XOR<UsedPartLogCreateWithoutBranchInput, UsedPartLogUncheckedCreateWithoutBranchInput>
  }

  export type UsedPartLogUpdateWithWhereUniqueWithoutBranchInput = {
    where: UsedPartLogWhereUniqueInput
    data: XOR<UsedPartLogUpdateWithoutBranchInput, UsedPartLogUncheckedUpdateWithoutBranchInput>
  }

  export type UsedPartLogUpdateManyWithWhereWithoutBranchInput = {
    where: UsedPartLogScalarWhereInput
    data: XOR<UsedPartLogUpdateManyMutationInput, UsedPartLogUncheckedUpdateManyWithoutBranchInput>
  }

  export type UsedPartLogScalarWhereInput = {
    AND?: UsedPartLogScalarWhereInput | UsedPartLogScalarWhereInput[]
    OR?: UsedPartLogScalarWhereInput[]
    NOT?: UsedPartLogScalarWhereInput | UsedPartLogScalarWhereInput[]
    id?: StringFilter<"UsedPartLog"> | string
    requestId?: StringFilter<"UsedPartLog"> | string
    customerId?: StringFilter<"UsedPartLog"> | string
    customerName?: StringNullableFilter<"UsedPartLog"> | string | null
    posMachineId?: StringNullableFilter<"UsedPartLog"> | string | null
    technician?: StringNullableFilter<"UsedPartLog"> | string | null
    closedByUserId?: StringNullableFilter<"UsedPartLog"> | string | null
    closedAt?: DateTimeFilter<"UsedPartLog"> | Date | string
    parts?: StringFilter<"UsedPartLog"> | string
    receiptNumber?: StringNullableFilter<"UsedPartLog"> | string | null
    branchId?: StringNullableFilter<"UsedPartLog"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    uid?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    canDoMaintenance?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    theme?: StringNullableFilter<"User"> | string | null
    fontFamily?: StringNullableFilter<"User"> | string | null
    fontSize?: StringNullableFilter<"User"> | string | null
    highlightEffect?: BoolFilter<"User"> | boolean
    notificationSound?: BoolFilter<"User"> | boolean
    mobilePush?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
  }

  export type WarehouseMachineUpsertWithWhereUniqueWithoutBranchInput = {
    where: WarehouseMachineWhereUniqueInput
    update: XOR<WarehouseMachineUpdateWithoutBranchInput, WarehouseMachineUncheckedUpdateWithoutBranchInput>
    create: XOR<WarehouseMachineCreateWithoutBranchInput, WarehouseMachineUncheckedCreateWithoutBranchInput>
  }

  export type WarehouseMachineUpdateWithWhereUniqueWithoutBranchInput = {
    where: WarehouseMachineWhereUniqueInput
    data: XOR<WarehouseMachineUpdateWithoutBranchInput, WarehouseMachineUncheckedUpdateWithoutBranchInput>
  }

  export type WarehouseMachineUpdateManyWithWhereWithoutBranchInput = {
    where: WarehouseMachineScalarWhereInput
    data: XOR<WarehouseMachineUpdateManyMutationInput, WarehouseMachineUncheckedUpdateManyWithoutBranchInput>
  }

  export type WarehouseMachineScalarWhereInput = {
    AND?: WarehouseMachineScalarWhereInput | WarehouseMachineScalarWhereInput[]
    OR?: WarehouseMachineScalarWhereInput[]
    NOT?: WarehouseMachineScalarWhereInput | WarehouseMachineScalarWhereInput[]
    id?: StringFilter<"WarehouseMachine"> | string
    serialNumber?: StringFilter<"WarehouseMachine"> | string
    model?: StringNullableFilter<"WarehouseMachine"> | string | null
    manufacturer?: StringNullableFilter<"WarehouseMachine"> | string | null
    status?: StringFilter<"WarehouseMachine"> | string
    resolution?: StringNullableFilter<"WarehouseMachine"> | string | null
    notes?: StringNullableFilter<"WarehouseMachine"> | string | null
    importDate?: DateTimeFilter<"WarehouseMachine"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseMachine"> | Date | string
    originalOwnerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    branchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    requestId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerId?: StringNullableFilter<"WarehouseMachine"> | string | null
    customerName?: StringNullableFilter<"WarehouseMachine"> | string | null
    readyForPickup?: BoolFilter<"WarehouseMachine"> | boolean
    currentAssignmentId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianId?: StringNullableFilter<"WarehouseMachine"> | string | null
    currentTechnicianName?: StringNullableFilter<"WarehouseMachine"> | string | null
    originBranchId?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedRepairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    proposedTotalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    repairNotes?: StringNullableFilter<"WarehouseMachine"> | string | null
    totalCost?: FloatNullableFilter<"WarehouseMachine"> | number | null
    usedParts?: StringNullableFilter<"WarehouseMachine"> | string | null
  }

  export type WarehouseSimUpsertWithWhereUniqueWithoutBranchInput = {
    where: WarehouseSimWhereUniqueInput
    update: XOR<WarehouseSimUpdateWithoutBranchInput, WarehouseSimUncheckedUpdateWithoutBranchInput>
    create: XOR<WarehouseSimCreateWithoutBranchInput, WarehouseSimUncheckedCreateWithoutBranchInput>
  }

  export type WarehouseSimUpdateWithWhereUniqueWithoutBranchInput = {
    where: WarehouseSimWhereUniqueInput
    data: XOR<WarehouseSimUpdateWithoutBranchInput, WarehouseSimUncheckedUpdateWithoutBranchInput>
  }

  export type WarehouseSimUpdateManyWithWhereWithoutBranchInput = {
    where: WarehouseSimScalarWhereInput
    data: XOR<WarehouseSimUpdateManyMutationInput, WarehouseSimUncheckedUpdateManyWithoutBranchInput>
  }

  export type WarehouseSimScalarWhereInput = {
    AND?: WarehouseSimScalarWhereInput | WarehouseSimScalarWhereInput[]
    OR?: WarehouseSimScalarWhereInput[]
    NOT?: WarehouseSimScalarWhereInput | WarehouseSimScalarWhereInput[]
    id?: StringFilter<"WarehouseSim"> | string
    serialNumber?: StringFilter<"WarehouseSim"> | string
    type?: StringNullableFilter<"WarehouseSim"> | string | null
    status?: StringFilter<"WarehouseSim"> | string
    notes?: StringNullableFilter<"WarehouseSim"> | string | null
    importDate?: DateTimeFilter<"WarehouseSim"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseSim"> | Date | string
    branchId?: StringNullableFilter<"WarehouseSim"> | string | null
  }

  export type BranchCreateWithoutCustomersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCustomersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCustomersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
  }

  export type MachineSaleCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    installments?: InstallmentCreateNestedManyWithoutSaleInput
    branch?: BranchCreateNestedOneWithoutSalesInput
  }

  export type MachineSaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    branchId?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type MachineSaleCreateOrConnectWithoutCustomerInput = {
    where: MachineSaleWhereUniqueInput
    create: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput>
  }

  export type MachineSaleCreateManyCustomerInputEnvelope = {
    data: MachineSaleCreateManyCustomerInput | MachineSaleCreateManyCustomerInput[]
  }

  export type MaintenanceRequestCreateWithoutCustomerInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalCreateNestedOneWithoutRequestInput
    posMachine?: PosMachineCreateNestedOneWithoutRequestsInput
    branch?: BranchCreateNestedOneWithoutRequestsInput
    vouchers?: RepairVoucherCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutCustomerInput = {
    id?: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutCustomerInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput>
  }

  export type MaintenanceRequestCreateManyCustomerInputEnvelope = {
    data: MaintenanceRequestCreateManyCustomerInput | MaintenanceRequestCreateManyCustomerInput[]
  }

  export type PaymentCreateWithoutCustomerInput = {
    id?: string
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
  }

  export type PosMachineCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    requests?: MaintenanceRequestCreateNestedManyWithoutPosMachineInput
    branch?: BranchCreateNestedOneWithoutPosMachinesInput
  }

  export type PosMachineUncheckedCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    branchId?: string | null
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutPosMachineInput
  }

  export type PosMachineCreateOrConnectWithoutCustomerInput = {
    where: PosMachineWhereUniqueInput
    create: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput>
  }

  export type PosMachineCreateManyCustomerInputEnvelope = {
    data: PosMachineCreateManyCustomerInput | PosMachineCreateManyCustomerInput[]
  }

  export type SimCardCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    type?: string | null
    branch?: BranchCreateNestedOneWithoutSimCardsInput
  }

  export type SimCardUncheckedCreateWithoutCustomerInput = {
    id?: string
    serialNumber: string
    type?: string | null
    branchId?: string | null
  }

  export type SimCardCreateOrConnectWithoutCustomerInput = {
    where: SimCardWhereUniqueInput
    create: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput>
  }

  export type SimCardCreateManyCustomerInputEnvelope = {
    data: SimCardCreateManyCustomerInput | SimCardCreateManyCustomerInput[]
  }

  export type BranchUpsertWithoutCustomersInput = {
    update: XOR<BranchUpdateWithoutCustomersInput, BranchUncheckedUpdateWithoutCustomersInput>
    create: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCustomersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCustomersInput, BranchUncheckedUpdateWithoutCustomersInput>
  }

  export type BranchUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MachineSaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: MachineSaleWhereUniqueInput
    update: XOR<MachineSaleUpdateWithoutCustomerInput, MachineSaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<MachineSaleCreateWithoutCustomerInput, MachineSaleUncheckedCreateWithoutCustomerInput>
  }

  export type MachineSaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: MachineSaleWhereUniqueInput
    data: XOR<MachineSaleUpdateWithoutCustomerInput, MachineSaleUncheckedUpdateWithoutCustomerInput>
  }

  export type MachineSaleUpdateManyWithWhereWithoutCustomerInput = {
    where: MachineSaleScalarWhereInput
    data: XOR<MachineSaleUpdateManyMutationInput, MachineSaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutCustomerInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutCustomerInput, MaintenanceRequestUncheckedUpdateWithoutCustomerInput>
    create: XOR<MaintenanceRequestCreateWithoutCustomerInput, MaintenanceRequestUncheckedCreateWithoutCustomerInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutCustomerInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutCustomerInput, MaintenanceRequestUncheckedUpdateWithoutCustomerInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutCustomerInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PosMachineUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PosMachineWhereUniqueInput
    update: XOR<PosMachineUpdateWithoutCustomerInput, PosMachineUncheckedUpdateWithoutCustomerInput>
    create: XOR<PosMachineCreateWithoutCustomerInput, PosMachineUncheckedCreateWithoutCustomerInput>
  }

  export type PosMachineUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PosMachineWhereUniqueInput
    data: XOR<PosMachineUpdateWithoutCustomerInput, PosMachineUncheckedUpdateWithoutCustomerInput>
  }

  export type PosMachineUpdateManyWithWhereWithoutCustomerInput = {
    where: PosMachineScalarWhereInput
    data: XOR<PosMachineUpdateManyMutationInput, PosMachineUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SimCardUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SimCardWhereUniqueInput
    update: XOR<SimCardUpdateWithoutCustomerInput, SimCardUncheckedUpdateWithoutCustomerInput>
    create: XOR<SimCardCreateWithoutCustomerInput, SimCardUncheckedCreateWithoutCustomerInput>
  }

  export type SimCardUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SimCardWhereUniqueInput
    data: XOR<SimCardUpdateWithoutCustomerInput, SimCardUncheckedUpdateWithoutCustomerInput>
  }

  export type SimCardUpdateManyWithWhereWithoutCustomerInput = {
    where: SimCardScalarWhereInput
    data: XOR<SimCardUpdateManyMutationInput, SimCardUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InventoryItemCreateWithoutPartInput = {
    id?: string
    quantity?: number
    minLevel?: number
    location?: string | null
    branch?: BranchCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateWithoutPartInput = {
    id?: string
    quantity?: number
    minLevel?: number
    location?: string | null
    branchId?: string | null
  }

  export type InventoryItemCreateOrConnectWithoutPartInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput>
  }

  export type InventoryItemCreateManyPartInputEnvelope = {
    data: InventoryItemCreateManyPartInput | InventoryItemCreateManyPartInput[]
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutPartInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutPartInput, InventoryItemUncheckedUpdateWithoutPartInput>
    create: XOR<InventoryItemCreateWithoutPartInput, InventoryItemUncheckedCreateWithoutPartInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutPartInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutPartInput, InventoryItemUncheckedUpdateWithoutPartInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutPartInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutPartInput>
  }

  export type SparePartCreateWithoutInventoryItemsInput = {
    id?: string
    partNumber?: string | null
    name: string
    description?: string | null
    compatibleModels?: string | null
    defaultCost?: number
    isConsumable?: boolean | null
    allowsMultiple?: boolean | null
  }

  export type SparePartUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    partNumber?: string | null
    name: string
    description?: string | null
    compatibleModels?: string | null
    defaultCost?: number
    isConsumable?: boolean | null
    allowsMultiple?: boolean | null
  }

  export type SparePartCreateOrConnectWithoutInventoryItemsInput = {
    where: SparePartWhereUniqueInput
    create: XOR<SparePartCreateWithoutInventoryItemsInput, SparePartUncheckedCreateWithoutInventoryItemsInput>
  }

  export type BranchCreateWithoutInventoryInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutInventoryInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutInventoryInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
  }

  export type SparePartUpsertWithoutInventoryItemsInput = {
    update: XOR<SparePartUpdateWithoutInventoryItemsInput, SparePartUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<SparePartCreateWithoutInventoryItemsInput, SparePartUncheckedCreateWithoutInventoryItemsInput>
    where?: SparePartWhereInput
  }

  export type SparePartUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: SparePartWhereInput
    data: XOR<SparePartUpdateWithoutInventoryItemsInput, SparePartUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type SparePartUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SparePartUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compatibleModels?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: FloatFieldUpdateOperationsInput | number
    isConsumable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowsMultiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BranchUpsertWithoutInventoryInput = {
    update: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInventoryInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type BranchUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MaintenanceApprovalCreateWithoutRequestInput = {
    id?: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
    branch?: BranchCreateNestedOneWithoutApprovalsInput
  }

  export type MaintenanceApprovalUncheckedCreateWithoutRequestInput = {
    id?: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    branchId?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
  }

  export type MaintenanceApprovalCreateOrConnectWithoutRequestInput = {
    where: MaintenanceApprovalWhereUniqueInput
    create: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
  }

  export type CustomerCreateWithoutRequestsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRequestsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRequestsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRequestsInput, CustomerUncheckedCreateWithoutRequestsInput>
  }

  export type PosMachineCreateWithoutRequestsInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    customer?: CustomerCreateNestedOneWithoutMachinesInput
    branch?: BranchCreateNestedOneWithoutPosMachinesInput
  }

  export type PosMachineUncheckedCreateWithoutRequestsInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    customerId?: string | null
    isMain?: boolean | null
    branchId?: string | null
  }

  export type PosMachineCreateOrConnectWithoutRequestsInput = {
    where: PosMachineWhereUniqueInput
    create: XOR<PosMachineCreateWithoutRequestsInput, PosMachineUncheckedCreateWithoutRequestsInput>
  }

  export type BranchCreateWithoutRequestsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutRequestsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutRequestsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutRequestsInput, BranchUncheckedCreateWithoutRequestsInput>
  }

  export type RepairVoucherCreateWithoutRequestInput = {
    id?: string
    code: string
    type: string
    parts: string
    totalCost: number
    createdAt?: Date | string
    createdBy?: string | null
    branch?: BranchCreateNestedOneWithoutVouchersInput
  }

  export type RepairVoucherUncheckedCreateWithoutRequestInput = {
    id?: string
    code: string
    type: string
    parts: string
    totalCost: number
    branchId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type RepairVoucherCreateOrConnectWithoutRequestInput = {
    where: RepairVoucherWhereUniqueInput
    create: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput>
  }

  export type RepairVoucherCreateManyRequestInputEnvelope = {
    data: RepairVoucherCreateManyRequestInput | RepairVoucherCreateManyRequestInput[]
  }

  export type MaintenanceApprovalUpsertWithoutRequestInput = {
    update: XOR<MaintenanceApprovalUpdateWithoutRequestInput, MaintenanceApprovalUncheckedUpdateWithoutRequestInput>
    create: XOR<MaintenanceApprovalCreateWithoutRequestInput, MaintenanceApprovalUncheckedCreateWithoutRequestInput>
    where?: MaintenanceApprovalWhereInput
  }

  export type MaintenanceApprovalUpdateToOneWithWhereWithoutRequestInput = {
    where?: MaintenanceApprovalWhereInput
    data: XOR<MaintenanceApprovalUpdateWithoutRequestInput, MaintenanceApprovalUncheckedUpdateWithoutRequestInput>
  }

  export type MaintenanceApprovalUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutApprovalsNestedInput
  }

  export type MaintenanceApprovalUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpsertWithoutRequestsInput = {
    update: XOR<CustomerUpdateWithoutRequestsInput, CustomerUncheckedUpdateWithoutRequestsInput>
    create: XOR<CustomerCreateWithoutRequestsInput, CustomerUncheckedCreateWithoutRequestsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRequestsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRequestsInput, CustomerUncheckedUpdateWithoutRequestsInput>
  }

  export type CustomerUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PosMachineUpsertWithoutRequestsInput = {
    update: XOR<PosMachineUpdateWithoutRequestsInput, PosMachineUncheckedUpdateWithoutRequestsInput>
    create: XOR<PosMachineCreateWithoutRequestsInput, PosMachineUncheckedCreateWithoutRequestsInput>
    where?: PosMachineWhereInput
  }

  export type PosMachineUpdateToOneWithWhereWithoutRequestsInput = {
    where?: PosMachineWhereInput
    data: XOR<PosMachineUpdateWithoutRequestsInput, PosMachineUncheckedUpdateWithoutRequestsInput>
  }

  export type PosMachineUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer?: CustomerUpdateOneWithoutMachinesNestedInput
    branch?: BranchUpdateOneWithoutPosMachinesNestedInput
  }

  export type PosMachineUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUpsertWithoutRequestsInput = {
    update: XOR<BranchUpdateWithoutRequestsInput, BranchUncheckedUpdateWithoutRequestsInput>
    create: XOR<BranchCreateWithoutRequestsInput, BranchUncheckedCreateWithoutRequestsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutRequestsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutRequestsInput, BranchUncheckedUpdateWithoutRequestsInput>
  }

  export type BranchUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type RepairVoucherUpsertWithWhereUniqueWithoutRequestInput = {
    where: RepairVoucherWhereUniqueInput
    update: XOR<RepairVoucherUpdateWithoutRequestInput, RepairVoucherUncheckedUpdateWithoutRequestInput>
    create: XOR<RepairVoucherCreateWithoutRequestInput, RepairVoucherUncheckedCreateWithoutRequestInput>
  }

  export type RepairVoucherUpdateWithWhereUniqueWithoutRequestInput = {
    where: RepairVoucherWhereUniqueInput
    data: XOR<RepairVoucherUpdateWithoutRequestInput, RepairVoucherUncheckedUpdateWithoutRequestInput>
  }

  export type RepairVoucherUpdateManyWithWhereWithoutRequestInput = {
    where: RepairVoucherScalarWhereInput
    data: XOR<RepairVoucherUpdateManyMutationInput, RepairVoucherUncheckedUpdateManyWithoutRequestInput>
  }

  export type BranchCreateWithoutUsedPartLogsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsedPartLogsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsedPartLogsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsedPartLogsInput, BranchUncheckedCreateWithoutUsedPartLogsInput>
  }

  export type BranchUpsertWithoutUsedPartLogsInput = {
    update: XOR<BranchUpdateWithoutUsedPartLogsInput, BranchUncheckedUpdateWithoutUsedPartLogsInput>
    create: XOR<BranchCreateWithoutUsedPartLogsInput, BranchUncheckedCreateWithoutUsedPartLogsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsedPartLogsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsedPartLogsInput, BranchUncheckedUpdateWithoutUsedPartLogsInput>
  }

  export type BranchUpdateWithoutUsedPartLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsedPartLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutStockMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStockMovementsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStockMovementsInput, BranchUncheckedCreateWithoutStockMovementsInput>
  }

  export type BranchUpsertWithoutStockMovementsInput = {
    update: XOR<BranchUpdateWithoutStockMovementsInput, BranchUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<BranchCreateWithoutStockMovementsInput, BranchUncheckedCreateWithoutStockMovementsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStockMovementsInput, BranchUncheckedUpdateWithoutStockMovementsInput>
  }

  export type BranchUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutPaymentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPaymentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPaymentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPaymentsInput, BranchUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerCreateWithoutPaymentsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type BranchUpsertWithoutPaymentsInput = {
    update: XOR<BranchUpdateWithoutPaymentsInput, BranchUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BranchCreateWithoutPaymentsInput, BranchUncheckedCreateWithoutPaymentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPaymentsInput, BranchUncheckedUpdateWithoutPaymentsInput>
  }

  export type BranchUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BranchCreateWithoutMachineMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMachineMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMachineMovementsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMachineMovementsInput, BranchUncheckedCreateWithoutMachineMovementsInput>
  }

  export type BranchUpsertWithoutMachineMovementsInput = {
    update: XOR<BranchUpdateWithoutMachineMovementsInput, BranchUncheckedUpdateWithoutMachineMovementsInput>
    create: XOR<BranchCreateWithoutMachineMovementsInput, BranchUncheckedCreateWithoutMachineMovementsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMachineMovementsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMachineMovementsInput, BranchUncheckedUpdateWithoutMachineMovementsInput>
  }

  export type BranchUpdateWithoutMachineMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMachineMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutSystemLogsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSystemLogsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSystemLogsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSystemLogsInput, BranchUncheckedCreateWithoutSystemLogsInput>
  }

  export type BranchUpsertWithoutSystemLogsInput = {
    update: XOR<BranchUpdateWithoutSystemLogsInput, BranchUncheckedUpdateWithoutSystemLogsInput>
    create: XOR<BranchCreateWithoutSystemLogsInput, BranchUncheckedCreateWithoutSystemLogsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSystemLogsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSystemLogsInput, BranchUncheckedUpdateWithoutSystemLogsInput>
  }

  export type BranchUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MachineSaleCreateWithoutInstallmentsInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    customer: CustomerCreateNestedOneWithoutSalesInput
    branch?: BranchCreateNestedOneWithoutSalesInput
  }

  export type MachineSaleUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    serialNumber: string
    customerId: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    branchId?: string | null
  }

  export type MachineSaleCreateOrConnectWithoutInstallmentsInput = {
    where: MachineSaleWhereUniqueInput
    create: XOR<MachineSaleCreateWithoutInstallmentsInput, MachineSaleUncheckedCreateWithoutInstallmentsInput>
  }

  export type BranchCreateWithoutInstallmentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutInstallmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInstallmentsInput, BranchUncheckedCreateWithoutInstallmentsInput>
  }

  export type MachineSaleUpsertWithoutInstallmentsInput = {
    update: XOR<MachineSaleUpdateWithoutInstallmentsInput, MachineSaleUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<MachineSaleCreateWithoutInstallmentsInput, MachineSaleUncheckedCreateWithoutInstallmentsInput>
    where?: MachineSaleWhereInput
  }

  export type MachineSaleUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: MachineSaleWhereInput
    data: XOR<MachineSaleUpdateWithoutInstallmentsInput, MachineSaleUncheckedUpdateWithoutInstallmentsInput>
  }

  export type MachineSaleUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    branch?: BranchUpdateOneWithoutSalesNestedInput
  }

  export type MachineSaleUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUpsertWithoutInstallmentsInput = {
    update: XOR<BranchUpdateWithoutInstallmentsInput, BranchUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<BranchCreateWithoutInstallmentsInput, BranchUncheckedCreateWithoutInstallmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInstallmentsInput, BranchUncheckedUpdateWithoutInstallmentsInput>
  }

  export type BranchUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type InstallmentCreateWithoutSaleInput = {
    id?: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    branch?: BranchCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateWithoutSaleInput = {
    id?: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type InstallmentCreateOrConnectWithoutSaleInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput>
  }

  export type InstallmentCreateManySaleInputEnvelope = {
    data: InstallmentCreateManySaleInput | InstallmentCreateManySaleInput[]
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type BranchCreateWithoutSalesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSalesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSalesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
  }

  export type InstallmentUpsertWithWhereUniqueWithoutSaleInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutSaleInput, InstallmentUncheckedUpdateWithoutSaleInput>
    create: XOR<InstallmentCreateWithoutSaleInput, InstallmentUncheckedCreateWithoutSaleInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutSaleInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutSaleInput, InstallmentUncheckedUpdateWithoutSaleInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutSaleInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutSaleInput>
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BranchUpsertWithoutSalesInput = {
    update: XOR<BranchUpdateWithoutSalesInput, BranchUncheckedUpdateWithoutSalesInput>
    create: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSalesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSalesInput, BranchUncheckedUpdateWithoutSalesInput>
  }

  export type BranchUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MaintenanceRequestCreateWithoutPosMachineInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalCreateNestedOneWithoutRequestInput
    customer: CustomerCreateNestedOneWithoutRequestsInput
    branch?: BranchCreateNestedOneWithoutRequestsInput
    vouchers?: RepairVoucherCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutPosMachineInput = {
    id?: string
    customerId: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutPosMachineInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput>
  }

  export type MaintenanceRequestCreateManyPosMachineInputEnvelope = {
    data: MaintenanceRequestCreateManyPosMachineInput | MaintenanceRequestCreateManyPosMachineInput[]
  }

  export type CustomerCreateWithoutMachinesInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    simCards?: SimCardCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutMachinesInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutMachinesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutMachinesInput, CustomerUncheckedCreateWithoutMachinesInput>
  }

  export type BranchCreateWithoutPosMachinesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPosMachinesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPosMachinesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPosMachinesInput, BranchUncheckedCreateWithoutPosMachinesInput>
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutPosMachineInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutPosMachineInput, MaintenanceRequestUncheckedUpdateWithoutPosMachineInput>
    create: XOR<MaintenanceRequestCreateWithoutPosMachineInput, MaintenanceRequestUncheckedCreateWithoutPosMachineInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutPosMachineInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutPosMachineInput, MaintenanceRequestUncheckedUpdateWithoutPosMachineInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutPosMachineInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutPosMachineInput>
  }

  export type CustomerUpsertWithoutMachinesInput = {
    update: XOR<CustomerUpdateWithoutMachinesInput, CustomerUncheckedUpdateWithoutMachinesInput>
    create: XOR<CustomerCreateWithoutMachinesInput, CustomerUncheckedCreateWithoutMachinesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutMachinesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutMachinesInput, CustomerUncheckedUpdateWithoutMachinesInput>
  }

  export type CustomerUpdateWithoutMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BranchUpsertWithoutPosMachinesInput = {
    update: XOR<BranchUpdateWithoutPosMachinesInput, BranchUncheckedUpdateWithoutPosMachinesInput>
    create: XOR<BranchCreateWithoutPosMachinesInput, BranchUncheckedCreateWithoutPosMachinesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPosMachinesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPosMachinesInput, BranchUncheckedUpdateWithoutPosMachinesInput>
  }

  export type BranchUpdateWithoutPosMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPosMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CustomerCreateWithoutSimCardsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: MachineSaleCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    machines?: PosMachineCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSimCardsInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
    branchId?: string | null
    sales?: MachineSaleUncheckedCreateNestedManyWithoutCustomerInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    machines?: PosMachineUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSimCardsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSimCardsInput, CustomerUncheckedCreateWithoutSimCardsInput>
  }

  export type BranchCreateWithoutSimCardsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSimCardsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSimCardsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSimCardsInput, BranchUncheckedCreateWithoutSimCardsInput>
  }

  export type CustomerUpsertWithoutSimCardsInput = {
    update: XOR<CustomerUpdateWithoutSimCardsInput, CustomerUncheckedUpdateWithoutSimCardsInput>
    create: XOR<CustomerCreateWithoutSimCardsInput, CustomerUncheckedCreateWithoutSimCardsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSimCardsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSimCardsInput, CustomerUncheckedUpdateWithoutSimCardsInput>
  }

  export type CustomerUpdateWithoutSimCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSimCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BranchUpsertWithoutSimCardsInput = {
    update: XOR<BranchUpdateWithoutSimCardsInput, BranchUncheckedUpdateWithoutSimCardsInput>
    create: XOR<BranchCreateWithoutSimCardsInput, BranchUncheckedCreateWithoutSimCardsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSimCardsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSimCardsInput, BranchUncheckedUpdateWithoutSimCardsInput>
  }

  export type BranchUpdateWithoutSimCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSimCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceAssignmentCreateWithoutMachineInput = {
    id?: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
    logs?: ServiceAssignmentLogCreateNestedManyWithoutAssignmentInput
  }

  export type ServiceAssignmentUncheckedCreateWithoutMachineInput = {
    id?: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
    logs?: ServiceAssignmentLogUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type ServiceAssignmentCreateOrConnectWithoutMachineInput = {
    where: ServiceAssignmentWhereUniqueInput
    create: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput>
  }

  export type ServiceAssignmentCreateManyMachineInputEnvelope = {
    data: ServiceAssignmentCreateManyMachineInput | ServiceAssignmentCreateManyMachineInput[]
  }

  export type BranchCreateWithoutWarehouseMachinesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWarehouseMachinesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWarehouseMachinesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWarehouseMachinesInput, BranchUncheckedCreateWithoutWarehouseMachinesInput>
  }

  export type ServiceAssignmentUpsertWithWhereUniqueWithoutMachineInput = {
    where: ServiceAssignmentWhereUniqueInput
    update: XOR<ServiceAssignmentUpdateWithoutMachineInput, ServiceAssignmentUncheckedUpdateWithoutMachineInput>
    create: XOR<ServiceAssignmentCreateWithoutMachineInput, ServiceAssignmentUncheckedCreateWithoutMachineInput>
  }

  export type ServiceAssignmentUpdateWithWhereUniqueWithoutMachineInput = {
    where: ServiceAssignmentWhereUniqueInput
    data: XOR<ServiceAssignmentUpdateWithoutMachineInput, ServiceAssignmentUncheckedUpdateWithoutMachineInput>
  }

  export type ServiceAssignmentUpdateManyWithWhereWithoutMachineInput = {
    where: ServiceAssignmentScalarWhereInput
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyWithoutMachineInput>
  }

  export type ServiceAssignmentScalarWhereInput = {
    AND?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
    OR?: ServiceAssignmentScalarWhereInput[]
    NOT?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
    id?: StringFilter<"ServiceAssignment"> | string
    machineId?: StringFilter<"ServiceAssignment"> | string
    serialNumber?: StringFilter<"ServiceAssignment"> | string
    technicianId?: StringFilter<"ServiceAssignment"> | string
    technicianName?: StringFilter<"ServiceAssignment"> | string
    status?: StringFilter<"ServiceAssignment"> | string
    proposedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    proposedTotal?: FloatFilter<"ServiceAssignment"> | number
    usedParts?: StringNullableFilter<"ServiceAssignment"> | string | null
    totalCost?: FloatFilter<"ServiceAssignment"> | number
    needsApproval?: BoolFilter<"ServiceAssignment"> | boolean
    approvedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    rejectionReason?: StringNullableFilter<"ServiceAssignment"> | string | null
    actionTaken?: StringNullableFilter<"ServiceAssignment"> | string | null
    resolution?: StringNullableFilter<"ServiceAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    customerId?: StringNullableFilter<"ServiceAssignment"> | string | null
    customerName?: StringNullableFilter<"ServiceAssignment"> | string | null
    requestId?: StringNullableFilter<"ServiceAssignment"> | string | null
    branchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    centerBranchId?: StringNullableFilter<"ServiceAssignment"> | string | null
    originBranchId?: StringFilter<"ServiceAssignment"> | string
  }

  export type BranchUpsertWithoutWarehouseMachinesInput = {
    update: XOR<BranchUpdateWithoutWarehouseMachinesInput, BranchUncheckedUpdateWithoutWarehouseMachinesInput>
    create: XOR<BranchCreateWithoutWarehouseMachinesInput, BranchUncheckedCreateWithoutWarehouseMachinesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWarehouseMachinesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWarehouseMachinesInput, BranchUncheckedUpdateWithoutWarehouseMachinesInput>
  }

  export type BranchUpdateWithoutWarehouseMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWarehouseMachinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutWarehouseSimsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWarehouseSimsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWarehouseSimsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWarehouseSimsInput, BranchUncheckedCreateWithoutWarehouseSimsInput>
  }

  export type BranchUpsertWithoutWarehouseSimsInput = {
    update: XOR<BranchUpdateWithoutWarehouseSimsInput, BranchUncheckedUpdateWithoutWarehouseSimsInput>
    create: XOR<BranchCreateWithoutWarehouseSimsInput, BranchUncheckedCreateWithoutWarehouseSimsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWarehouseSimsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWarehouseSimsInput, BranchUncheckedUpdateWithoutWarehouseSimsInput>
  }

  export type BranchUpdateWithoutWarehouseSimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWarehouseSimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutSimMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSimMovementsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSimMovementsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSimMovementsInput, BranchUncheckedCreateWithoutSimMovementsInput>
  }

  export type BranchUpsertWithoutSimMovementsInput = {
    update: XOR<BranchUpdateWithoutSimMovementsInput, BranchUncheckedUpdateWithoutSimMovementsInput>
    create: XOR<BranchCreateWithoutSimMovementsInput, BranchUncheckedCreateWithoutSimMovementsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSimMovementsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSimMovementsInput, BranchUncheckedUpdateWithoutSimMovementsInput>
  }

  export type BranchUpdateWithoutSimMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSimMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutReceivedTransfersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutReceivedTransfersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutReceivedTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
  }

  export type BranchCreateWithoutSentTransfersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSentTransfersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSentTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
  }

  export type TransferOrderItemCreateWithoutTransferOrderInput = {
    id?: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
  }

  export type TransferOrderItemUncheckedCreateWithoutTransferOrderInput = {
    id?: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
  }

  export type TransferOrderItemCreateOrConnectWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    create: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput>
  }

  export type TransferOrderItemCreateManyTransferOrderInputEnvelope = {
    data: TransferOrderItemCreateManyTransferOrderInput | TransferOrderItemCreateManyTransferOrderInput[]
  }

  export type BranchUpsertWithoutReceivedTransfersInput = {
    update: XOR<BranchUpdateWithoutReceivedTransfersInput, BranchUncheckedUpdateWithoutReceivedTransfersInput>
    create: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceivedTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceivedTransfersInput, BranchUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type BranchUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUpsertWithoutSentTransfersInput = {
    update: XOR<BranchUpdateWithoutSentTransfersInput, BranchUncheckedUpdateWithoutSentTransfersInput>
    create: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSentTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSentTransfersInput, BranchUncheckedUpdateWithoutSentTransfersInput>
  }

  export type BranchUpdateWithoutSentTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSentTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    update: XOR<TransferOrderItemUpdateWithoutTransferOrderInput, TransferOrderItemUncheckedUpdateWithoutTransferOrderInput>
    create: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput>
  }

  export type TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    data: XOR<TransferOrderItemUpdateWithoutTransferOrderInput, TransferOrderItemUncheckedUpdateWithoutTransferOrderInput>
  }

  export type TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput = {
    where: TransferOrderItemScalarWhereInput
    data: XOR<TransferOrderItemUpdateManyMutationInput, TransferOrderItemUncheckedUpdateManyWithoutTransferOrderInput>
  }

  export type TransferOrderItemScalarWhereInput = {
    AND?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
    OR?: TransferOrderItemScalarWhereInput[]
    NOT?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
    id?: StringFilter<"TransferOrderItem"> | string
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    serialNumber?: StringNullableFilter<"TransferOrderItem"> | string | null
    type?: StringNullableFilter<"TransferOrderItem"> | string | null
    model?: StringNullableFilter<"TransferOrderItem"> | string | null
    manufacturer?: StringNullableFilter<"TransferOrderItem"> | string | null
    isReceived?: BoolFilter<"TransferOrderItem"> | boolean
    receivedAt?: DateTimeNullableFilter<"TransferOrderItem"> | Date | string | null
    notes?: StringNullableFilter<"TransferOrderItem"> | string | null
  }

  export type TransferOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    toBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
    fromBranch: BranchCreateNestedOneWithoutSentTransfersInput
  }

  export type TransferOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    fromBranchId: string
    toBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderCreateOrConnectWithoutItemsInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
  }

  export type TransferOrderUpsertWithoutItemsInput = {
    update: XOR<TransferOrderUpdateWithoutItemsInput, TransferOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    where?: TransferOrderWhereInput
  }

  export type TransferOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransferOrderWhereInput
    data: XOR<TransferOrderUpdateWithoutItemsInput, TransferOrderUncheckedUpdateWithoutItemsInput>
  }

  export type TransferOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
    fromBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    fromBranchId?: StringFieldUpdateOperationsInput | string
    toBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutApprovalsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutApprovalsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutApprovalsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutApprovalsInput, BranchUncheckedCreateWithoutApprovalsInput>
  }

  export type MaintenanceRequestCreateWithoutApprovalInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    customer: CustomerCreateNestedOneWithoutRequestsInput
    posMachine?: PosMachineCreateNestedOneWithoutRequestsInput
    branch?: BranchCreateNestedOneWithoutRequestsInput
    vouchers?: RepairVoucherCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutApprovalInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutApprovalInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutApprovalInput, MaintenanceRequestUncheckedCreateWithoutApprovalInput>
  }

  export type BranchUpsertWithoutApprovalsInput = {
    update: XOR<BranchUpdateWithoutApprovalsInput, BranchUncheckedUpdateWithoutApprovalsInput>
    create: XOR<BranchCreateWithoutApprovalsInput, BranchUncheckedCreateWithoutApprovalsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutApprovalsInput, BranchUncheckedUpdateWithoutApprovalsInput>
  }

  export type BranchUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MaintenanceRequestUpsertWithoutApprovalInput = {
    update: XOR<MaintenanceRequestUpdateWithoutApprovalInput, MaintenanceRequestUncheckedUpdateWithoutApprovalInput>
    create: XOR<MaintenanceRequestCreateWithoutApprovalInput, MaintenanceRequestUncheckedCreateWithoutApprovalInput>
    where?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestUpdateToOneWithWhereWithoutApprovalInput = {
    where?: MaintenanceRequestWhereInput
    data: XOR<MaintenanceRequestUpdateWithoutApprovalInput, MaintenanceRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type MaintenanceRequestUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    customer?: CustomerUpdateOneRequiredWithoutRequestsNestedInput
    posMachine?: PosMachineUpdateOneWithoutRequestsNestedInput
    branch?: BranchUpdateOneWithoutRequestsNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type BranchCreateWithoutVouchersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    notifications?: NotificationCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutVouchersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutVouchersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
  }

  export type MaintenanceRequestCreateWithoutVouchersInput = {
    id?: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalCreateNestedOneWithoutRequestInput
    customer: CustomerCreateNestedOneWithoutRequestsInput
    posMachine?: PosMachineCreateNestedOneWithoutRequestsInput
    branch?: BranchCreateNestedOneWithoutRequestsInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutVouchersInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
    approval?: MaintenanceApprovalUncheckedCreateNestedOneWithoutRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutVouchersInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutVouchersInput, MaintenanceRequestUncheckedCreateWithoutVouchersInput>
  }

  export type BranchUpsertWithoutVouchersInput = {
    update: XOR<BranchUpdateWithoutVouchersInput, BranchUncheckedUpdateWithoutVouchersInput>
    create: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutVouchersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutVouchersInput, BranchUncheckedUpdateWithoutVouchersInput>
  }

  export type BranchUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MaintenanceRequestUpsertWithoutVouchersInput = {
    update: XOR<MaintenanceRequestUpdateWithoutVouchersInput, MaintenanceRequestUncheckedUpdateWithoutVouchersInput>
    create: XOR<MaintenanceRequestCreateWithoutVouchersInput, MaintenanceRequestUncheckedCreateWithoutVouchersInput>
    where?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestUpdateToOneWithWhereWithoutVouchersInput = {
    where?: MaintenanceRequestWhereInput
    data: XOR<MaintenanceRequestUpdateWithoutVouchersInput, MaintenanceRequestUncheckedUpdateWithoutVouchersInput>
  }

  export type MaintenanceRequestUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUpdateOneWithoutRequestNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRequestsNestedInput
    posMachine?: PosMachineUpdateOneWithoutRequestsNestedInput
    branch?: BranchUpdateOneWithoutRequestsNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput
  }

  export type BranchCreateWithoutNotificationsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    maintenanceCenter?: BranchCreateNestedOneWithoutServicedBranchesInput
    servicedBranches?: BranchCreateNestedManyWithoutMaintenanceCenterInput
    parentBranch?: BranchCreateNestedOneWithoutChildBranchesInput
    childBranches?: BranchCreateNestedManyWithoutParentBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    installments?: InstallmentCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogCreateNestedManyWithoutBranchInput
    sales?: MachineSaleCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestCreateNestedManyWithoutBranchInput
    payments?: PaymentCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherCreateNestedManyWithoutBranchInput
    simCards?: SimCardCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutNotificationsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    maintenanceCenterId?: string | null
    createdAt?: Date | string
    servicedBranches?: BranchUncheckedCreateNestedManyWithoutMaintenanceCenterInput
    childBranches?: BranchUncheckedCreateNestedManyWithoutParentBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutBranchInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutBranchInput
    machineMovements?: MachineMovementLogUncheckedCreateNestedManyWithoutBranchInput
    sales?: MachineSaleUncheckedCreateNestedManyWithoutBranchInput
    approvals?: MaintenanceApprovalUncheckedCreateNestedManyWithoutBranchInput
    requests?: MaintenanceRequestUncheckedCreateNestedManyWithoutBranchInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBranchInput
    posMachines?: PosMachineUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: RepairVoucherUncheckedCreateNestedManyWithoutBranchInput
    simCards?: SimCardUncheckedCreateNestedManyWithoutBranchInput
    simMovements?: SimMovementLogUncheckedCreateNestedManyWithoutBranchInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutBranchInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: TransferOrderUncheckedCreateNestedManyWithoutToBranchInput
    sentTransfers?: TransferOrderUncheckedCreateNestedManyWithoutFromBranchInput
    usedPartLogs?: UsedPartLogUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    warehouseMachines?: WarehouseMachineUncheckedCreateNestedManyWithoutBranchInput
    warehouseSims?: WarehouseSimUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutNotificationsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutNotificationsInput, BranchUncheckedCreateWithoutNotificationsInput>
  }

  export type BranchUpsertWithoutNotificationsInput = {
    update: XOR<BranchUpdateWithoutNotificationsInput, BranchUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BranchCreateWithoutNotificationsInput, BranchUncheckedCreateWithoutNotificationsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutNotificationsInput, BranchUncheckedUpdateWithoutNotificationsInput>
  }

  export type BranchUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type WarehouseMachineCreateWithoutServiceAssignmentsInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
    branch?: BranchCreateNestedOneWithoutWarehouseMachinesInput
  }

  export type WarehouseMachineUncheckedCreateWithoutServiceAssignmentsInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    branchId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
  }

  export type WarehouseMachineCreateOrConnectWithoutServiceAssignmentsInput = {
    where: WarehouseMachineWhereUniqueInput
    create: XOR<WarehouseMachineCreateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedCreateWithoutServiceAssignmentsInput>
  }

  export type ServiceAssignmentLogCreateWithoutAssignmentInput = {
    id?: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
  }

  export type ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput = {
    id?: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
  }

  export type ServiceAssignmentLogCreateOrConnectWithoutAssignmentInput = {
    where: ServiceAssignmentLogWhereUniqueInput
    create: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput>
  }

  export type ServiceAssignmentLogCreateManyAssignmentInputEnvelope = {
    data: ServiceAssignmentLogCreateManyAssignmentInput | ServiceAssignmentLogCreateManyAssignmentInput[]
  }

  export type WarehouseMachineUpsertWithoutServiceAssignmentsInput = {
    update: XOR<WarehouseMachineUpdateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedUpdateWithoutServiceAssignmentsInput>
    create: XOR<WarehouseMachineCreateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedCreateWithoutServiceAssignmentsInput>
    where?: WarehouseMachineWhereInput
  }

  export type WarehouseMachineUpdateToOneWithWhereWithoutServiceAssignmentsInput = {
    where?: WarehouseMachineWhereInput
    data: XOR<WarehouseMachineUpdateWithoutServiceAssignmentsInput, WarehouseMachineUncheckedUpdateWithoutServiceAssignmentsInput>
  }

  export type WarehouseMachineUpdateWithoutServiceAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutWarehouseMachinesNestedInput
  }

  export type WarehouseMachineUncheckedUpdateWithoutServiceAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentLogUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: ServiceAssignmentLogWhereUniqueInput
    update: XOR<ServiceAssignmentLogUpdateWithoutAssignmentInput, ServiceAssignmentLogUncheckedUpdateWithoutAssignmentInput>
    create: XOR<ServiceAssignmentLogCreateWithoutAssignmentInput, ServiceAssignmentLogUncheckedCreateWithoutAssignmentInput>
  }

  export type ServiceAssignmentLogUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: ServiceAssignmentLogWhereUniqueInput
    data: XOR<ServiceAssignmentLogUpdateWithoutAssignmentInput, ServiceAssignmentLogUncheckedUpdateWithoutAssignmentInput>
  }

  export type ServiceAssignmentLogUpdateManyWithWhereWithoutAssignmentInput = {
    where: ServiceAssignmentLogScalarWhereInput
    data: XOR<ServiceAssignmentLogUpdateManyMutationInput, ServiceAssignmentLogUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type ServiceAssignmentLogScalarWhereInput = {
    AND?: ServiceAssignmentLogScalarWhereInput | ServiceAssignmentLogScalarWhereInput[]
    OR?: ServiceAssignmentLogScalarWhereInput[]
    NOT?: ServiceAssignmentLogScalarWhereInput | ServiceAssignmentLogScalarWhereInput[]
    id?: StringFilter<"ServiceAssignmentLog"> | string
    assignmentId?: StringFilter<"ServiceAssignmentLog"> | string
    action?: StringFilter<"ServiceAssignmentLog"> | string
    details?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedBy?: StringFilter<"ServiceAssignmentLog"> | string
    performedById?: StringNullableFilter<"ServiceAssignmentLog"> | string | null
    performedAt?: DateTimeFilter<"ServiceAssignmentLog"> | Date | string
  }

  export type ServiceAssignmentCreateWithoutLogsInput = {
    id?: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
    machine: WarehouseMachineCreateNestedOneWithoutServiceAssignmentsInput
  }

  export type ServiceAssignmentUncheckedCreateWithoutLogsInput = {
    id?: string
    machineId: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
  }

  export type ServiceAssignmentCreateOrConnectWithoutLogsInput = {
    where: ServiceAssignmentWhereUniqueInput
    create: XOR<ServiceAssignmentCreateWithoutLogsInput, ServiceAssignmentUncheckedCreateWithoutLogsInput>
  }

  export type ServiceAssignmentUpsertWithoutLogsInput = {
    update: XOR<ServiceAssignmentUpdateWithoutLogsInput, ServiceAssignmentUncheckedUpdateWithoutLogsInput>
    create: XOR<ServiceAssignmentCreateWithoutLogsInput, ServiceAssignmentUncheckedCreateWithoutLogsInput>
    where?: ServiceAssignmentWhereInput
  }

  export type ServiceAssignmentUpdateToOneWithWhereWithoutLogsInput = {
    where?: ServiceAssignmentWhereInput
    data: XOR<ServiceAssignmentUpdateWithoutLogsInput, ServiceAssignmentUncheckedUpdateWithoutLogsInput>
  }

  export type ServiceAssignmentUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
    machine?: WarehouseMachineUpdateOneRequiredWithoutServiceAssignmentsNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type BranchCreateManyMaintenanceCenterInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    parentBranchId?: string | null
    createdAt?: Date | string
  }

  export type BranchCreateManyParentBranchInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    type?: string
    isActive?: boolean
    maintenanceCenterId?: string | null
    createdAt?: Date | string
  }

  export type CustomerCreateManyBranchInput = {
    id?: string
    bkcode: string
    client_name: string
    supply_office?: string | null
    operating_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    scanned_id_path?: string | null
    national_id?: string | null
    dept?: string | null
    telephone_1?: string | null
    telephone_2?: string | null
    has_gates?: boolean | null
    bk_type?: string | null
    notes?: string | null
    papers_date?: Date | string | null
    isSpecial?: boolean | null
    clienttype?: string | null
  }

  export type InstallmentCreateManyBranchInput = {
    id?: string
    saleId: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
  }

  export type InventoryItemCreateManyBranchInput = {
    id?: string
    partId: string
    quantity?: number
    minLevel?: number
    location?: string | null
  }

  export type MachineMovementLogCreateManyBranchInput = {
    id?: string
    machineId?: string | null
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type MachineSaleCreateManyBranchInput = {
    id?: string
    serialNumber: string
    customerId: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
  }

  export type MaintenanceApprovalCreateManyBranchInput = {
    id?: string
    requestId: string
    cost: number
    parts: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    respondedBy?: string | null
  }

  export type MaintenanceRequestCreateManyBranchInput = {
    id?: string
    customerId: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
  }

  export type NotificationCreateManyBranchInput = {
    id?: string
    userId?: string | null
    link?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyBranchInput = {
    id?: string
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    createdAt?: Date | string
  }

  export type PosMachineCreateManyBranchInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    customerId?: string | null
    isMain?: boolean | null
  }

  export type RepairVoucherCreateManyBranchInput = {
    id?: string
    code: string
    requestId: string
    type: string
    parts: string
    totalCost: number
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type SimCardCreateManyBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    customerId?: string | null
  }

  export type SimMovementLogCreateManyBranchInput = {
    id?: string
    simId: string
    serialNumber: string
    action: string
    details?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateManyBranchInput = {
    id?: string
    partId: string
    type: string
    quantity: number
    reason?: string | null
    requestId?: string | null
    userId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type SystemLogCreateManyBranchInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    details?: string | null
    performedBy?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type TransferOrderCreateManyToBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    fromBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderCreateManyFromBranchInput = {
    id?: string
    orderNumber: string
    waybillNumber?: string | null
    branchId?: string | null
    toBranchId: string
    status?: string
    type: string
    driverName?: string | null
    driverPhone?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    createdByUserId?: string | null
    receivedByUserId?: string | null
    receivedAt?: Date | string | null
    receivedBy?: string | null
    receivedByName?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsedPartLogCreateManyBranchInput = {
    id?: string
    requestId: string
    customerId: string
    customerName?: string | null
    posMachineId?: string | null
    technician?: string | null
    closedByUserId?: string | null
    closedAt?: Date | string
    parts: string
    receiptNumber?: string | null
  }

  export type UserCreateManyBranchInput = {
    id?: string
    uid?: string | null
    email?: string | null
    displayName?: string | null
    role?: string | null
    canDoMaintenance?: boolean
    password?: string | null
    theme?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    highlightEffect?: boolean
    notificationSound?: boolean
    mobilePush?: boolean
    createdAt?: Date | string
  }

  export type WarehouseMachineCreateManyBranchInput = {
    id?: string
    serialNumber: string
    model?: string | null
    manufacturer?: string | null
    status?: string
    resolution?: string | null
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
    originalOwnerId?: string | null
    requestId?: string | null
    customerId?: string | null
    customerName?: string | null
    readyForPickup?: boolean
    currentAssignmentId?: string | null
    currentTechnicianId?: string | null
    currentTechnicianName?: string | null
    originBranchId?: string | null
    proposedParts?: string | null
    proposedRepairNotes?: string | null
    proposedTotalCost?: number | null
    repairNotes?: string | null
    totalCost?: number | null
    usedParts?: string | null
  }

  export type WarehouseSimCreateManyBranchInput = {
    id?: string
    serialNumber: string
    type?: string | null
    status?: string
    notes?: string | null
    importDate?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateWithoutMaintenanceCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    parentBranch?: BranchUpdateOneWithoutChildBranchesNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMaintenanceCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutMaintenanceCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpdateWithoutParentBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceCenter?: BranchUpdateOneWithoutServicedBranchesNestedInput
    servicedBranches?: BranchUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUpdateManyWithoutBranchNestedInput
    payments?: PaymentUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutParentBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicedBranches?: BranchUncheckedUpdateManyWithoutMaintenanceCenterNestedInput
    childBranches?: BranchUncheckedUpdateManyWithoutParentBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutBranchNestedInput
    machineMovements?: MachineMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    sales?: MachineSaleUncheckedUpdateManyWithoutBranchNestedInput
    approvals?: MaintenanceApprovalUncheckedUpdateManyWithoutBranchNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutBranchNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBranchNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBranchNestedInput
    posMachines?: PosMachineUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutBranchNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutBranchNestedInput
    simMovements?: SimMovementLogUncheckedUpdateManyWithoutBranchNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutBranchNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: TransferOrderUncheckedUpdateManyWithoutToBranchNestedInput
    sentTransfers?: TransferOrderUncheckedUpdateManyWithoutFromBranchNestedInput
    usedPartLogs?: UsedPartLogUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    warehouseMachines?: WarehouseMachineUncheckedUpdateManyWithoutBranchNestedInput
    warehouseSims?: WarehouseSimUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutParentBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maintenanceCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: MachineSaleUncheckedUpdateManyWithoutCustomerNestedInput
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    machines?: PosMachineUncheckedUpdateManyWithoutCustomerNestedInput
    simCards?: SimCardUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    bkcode?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    supply_office?: NullableStringFieldUpdateOperationsInput | string | null
    operating_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    scanned_id_path?: NullableStringFieldUpdateOperationsInput | string | null
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    dept?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_1?: NullableStringFieldUpdateOperationsInput | string | null
    telephone_2?: NullableStringFieldUpdateOperationsInput | string | null
    has_gates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bk_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    papers_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSpecial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clienttype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: MachineSaleUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    part?: SparePartUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MachineMovementLogUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMovementLogUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMovementLogUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSaleUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type MachineSaleUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type MachineSaleUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceApprovalUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    request?: MaintenanceRequestUpdateOneRequiredWithoutApprovalNestedInput
  }

  export type MaintenanceApprovalUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceApprovalUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    parts?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUpdateOneWithoutRequestNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRequestsNestedInput
    posMachine?: PosMachineUpdateOneWithoutRequestsNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type NotificationUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosMachineUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requests?: MaintenanceRequestUpdateManyWithoutPosMachineNestedInput
    customer?: CustomerUpdateOneWithoutMachinesNestedInput
  }

  export type PosMachineUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutPosMachineNestedInput
  }

  export type PosMachineUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RepairVoucherUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    request?: MaintenanceRequestUpdateOneRequiredWithoutVouchersNestedInput
  }

  export type RepairVoucherUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSimCardsNestedInput
  }

  export type SimCardUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimMovementLogUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimMovementLogUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimMovementLogUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    simId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderUpdateWithoutToBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutToBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    fromBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateManyWithoutToBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    fromBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderUpdateWithoutFromBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutFromBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    toBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateManyWithoutFromBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    waybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    toBranchId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsedPartLogUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsedPartLogUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsedPartLogUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: StringFieldUpdateOperationsInput | string
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    canDoMaintenance?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    highlightEffect?: BoolFieldUpdateOperationsInput | boolean
    notificationSound?: BoolFieldUpdateOperationsInput | boolean
    mobilePush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseMachineUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutMachineNestedInput
  }

  export type WarehouseMachineUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WarehouseMachineUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    readyForPickup?: BoolFieldUpdateOperationsInput | boolean
    currentAssignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianId?: NullableStringFieldUpdateOperationsInput | string | null
    currentTechnicianName?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedRepairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    repairNotes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseSimUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseSimUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseSimUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSaleCreateManyCustomerInput = {
    id?: string
    serialNumber: string
    saleDate?: Date | string
    type: string
    totalPrice: number
    paidAmount: number
    status: string
    notes?: string | null
    branchId?: string | null
  }

  export type MaintenanceRequestCreateManyCustomerInput = {
    id?: string
    posMachineId?: string | null
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
  }

  export type PaymentCreateManyCustomerInput = {
    id?: string
    customerName?: string | null
    requestId?: string | null
    amount: number
    type?: string | null
    reason?: string | null
    paymentPlace?: string | null
    paymentMethod?: string | null
    receiptNumber?: string | null
    notes?: string | null
    userId?: string | null
    userName?: string | null
    branchId?: string | null
    createdAt?: Date | string
  }

  export type PosMachineCreateManyCustomerInput = {
    id?: string
    serialNumber: string
    posId?: string | null
    model?: string | null
    manufacturer?: string | null
    isMain?: boolean | null
    branchId?: string | null
  }

  export type SimCardCreateManyCustomerInput = {
    id?: string
    serialNumber: string
    type?: string | null
    branchId?: string | null
  }

  export type MachineSaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUpdateManyWithoutSaleNestedInput
    branch?: BranchUpdateOneWithoutSalesNestedInput
  }

  export type MachineSaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type MachineSaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUpdateOneWithoutRequestNestedInput
    posMachine?: PosMachineUpdateOneWithoutRequestsNestedInput
    branch?: BranchUpdateOneWithoutRequestsNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    posMachineId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosMachineUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requests?: MaintenanceRequestUpdateManyWithoutPosMachineNestedInput
    branch?: BranchUpdateOneWithoutPosMachinesNestedInput
  }

  export type PosMachineUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    requests?: MaintenanceRequestUncheckedUpdateManyWithoutPosMachineNestedInput
  }

  export type PosMachineUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    posId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutSimCardsNestedInput
  }

  export type SimCardUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimCardUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemCreateManyPartInput = {
    id?: string
    quantity?: number
    minLevel?: number
    location?: string | null
    branchId?: string | null
  }

  export type InventoryItemUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherCreateManyRequestInput = {
    id?: string
    code: string
    type: string
    parts: string
    totalCost: number
    branchId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type RepairVoucherUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutVouchersNestedInput
  }

  export type RepairVoucherUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairVoucherUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parts?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentCreateManySaleInput = {
    id?: string
    dueDate: Date | string
    amount: number
    isPaid?: boolean
    paidAt?: Date | string | null
    description?: string | null
    paidAmount?: number | null
    paymentPlace?: string | null
    receiptNumber?: string | null
    branchId?: string | null
  }

  export type InstallmentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentPlace?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestCreateManyPosMachineInput = {
    id?: string
    customerId: string
    customerName?: string | null
    machineModel?: string | null
    machineManufacturer?: string | null
    serialNumber?: string | null
    status?: string
    branchId?: string | null
    servicedByBranchId?: string | null
    technician?: string | null
    notes?: string | null
    complaint?: string | null
    actionTaken?: string | null
    createdAt?: Date | string
    closingUserId?: string | null
    closingUserName?: string | null
    closingTimestamp?: Date | string | null
    usedParts?: string | null
    receiptNumber?: string | null
    totalCost?: number | null
  }

  export type MaintenanceRequestUpdateWithoutPosMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUpdateOneWithoutRequestNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRequestsNestedInput
    branch?: BranchUpdateOneWithoutRequestsNestedInput
    vouchers?: RepairVoucherUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutPosMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    approval?: MaintenanceApprovalUncheckedUpdateOneWithoutRequestNestedInput
    vouchers?: RepairVoucherUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutPosMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    machineModel?: NullableStringFieldUpdateOperationsInput | string | null
    machineManufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    servicedByBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    complaint?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closingUserId?: NullableStringFieldUpdateOperationsInput | string | null
    closingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    closingTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ServiceAssignmentCreateManyMachineInput = {
    id?: string
    serialNumber: string
    technicianId: string
    technicianName: string
    status?: string
    proposedParts?: string | null
    proposedTotal?: number
    usedParts?: string | null
    totalCost?: number
    needsApproval?: boolean
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    actionTaken?: string | null
    resolution?: string | null
    assignedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    customerId?: string | null
    customerName?: string | null
    requestId?: string | null
    branchId?: string | null
    centerBranchId?: string | null
    originBranchId: string
  }

  export type ServiceAssignmentUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
    logs?: ServiceAssignmentLogUpdateManyWithoutAssignmentNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
    logs?: ServiceAssignmentLogUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    proposedParts?: NullableStringFieldUpdateOperationsInput | string | null
    proposedTotal?: FloatFieldUpdateOperationsInput | number
    usedParts?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    needsApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    centerBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    originBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type TransferOrderItemCreateManyTransferOrderInput = {
    id?: string
    serialNumber?: string | null
    type?: string | null
    model?: string | null
    manufacturer?: string | null
    isReceived?: boolean
    receivedAt?: Date | string | null
    notes?: string | null
  }

  export type TransferOrderItemUpdateWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferOrderItemUncheckedUpdateWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentLogCreateManyAssignmentInput = {
    id?: string
    action: string
    details?: string | null
    performedBy: string
    performedById?: string | null
    performedAt?: Date | string
  }

  export type ServiceAssignmentLogUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentLogUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentLogUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SparePartCountOutputTypeDefaultArgs instead
     */
    export type SparePartCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SparePartCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceRequestCountOutputTypeDefaultArgs instead
     */
    export type MaintenanceRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MachineSaleCountOutputTypeDefaultArgs instead
     */
    export type MachineSaleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MachineSaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PosMachineCountOutputTypeDefaultArgs instead
     */
    export type PosMachineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PosMachineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseMachineCountOutputTypeDefaultArgs instead
     */
    export type WarehouseMachineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseMachineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderCountOutputTypeDefaultArgs instead
     */
    export type TransferOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceAssignmentCountOutputTypeDefaultArgs instead
     */
    export type ServiceAssignmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceAssignmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientTypeDefaultArgs instead
     */
    export type ClientTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MachineParameterDefaultArgs instead
     */
    export type MachineParameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MachineParameterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SparePartDefaultArgs instead
     */
    export type SparePartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SparePartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemDefaultArgs instead
     */
    export type InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceRequestDefaultArgs instead
     */
    export type MaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceChangeLogDefaultArgs instead
     */
    export type PriceChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsedPartLogDefaultArgs instead
     */
    export type UsedPartLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsedPartLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MachineMovementLogDefaultArgs instead
     */
    export type MachineMovementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MachineMovementLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLogDefaultArgs instead
     */
    export type SystemLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallmentDefaultArgs instead
     */
    export type InstallmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MachineSaleDefaultArgs instead
     */
    export type MachineSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MachineSaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PosMachineDefaultArgs instead
     */
    export type PosMachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PosMachineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimCardDefaultArgs instead
     */
    export type SimCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseMachineDefaultArgs instead
     */
    export type WarehouseMachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseMachineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseSimDefaultArgs instead
     */
    export type WarehouseSimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseSimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimMovementLogDefaultArgs instead
     */
    export type SimMovementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimMovementLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderDefaultArgs instead
     */
    export type TransferOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderItemDefaultArgs instead
     */
    export type TransferOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceApprovalDefaultArgs instead
     */
    export type MaintenanceApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepairVoucherDefaultArgs instead
     */
    export type RepairVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepairVoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceAssignmentDefaultArgs instead
     */
    export type ServiceAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceAssignmentLogDefaultArgs instead
     */
    export type ServiceAssignmentLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceAssignmentLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDebtDefaultArgs instead
     */
    export type BranchDebtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDebtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceApprovalRequestDefaultArgs instead
     */
    export type MaintenanceApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceApprovalRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}